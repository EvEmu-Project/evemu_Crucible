/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "Inventory.h"
#include "../common/PyRep.h"




NotifyOnItemChange::NotifyOnItemChange() {
	/*  0: this is a util.Row  */
	itemRow = NULL;
	/*  1: map from row index (ix* constants) to the old value for the item.   */
}

NotifyOnItemChange::~NotifyOnItemChange() {
	/*  0: this is a util.Row  */
	delete itemRow;
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	std::map<uint32, PyRep *>::iterator changes_cur, changes_end;
	//free any existing elements first
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		delete changes_cur->second;
	}
	
}

void NotifyOnItemChange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnItemChange", pfx);
	/*  0: this is a util.Row  */
	_log(l_type, "%sitemRow:", pfx);
	std::string itemRow_n(pfx);
	itemRow_n += "    ";
	if(itemRow == NULL) {
		_log(l_type, "%sERROR: NULL REP!", itemRow_n.c_str());
	} else {
		itemRow->Dump(l_type, itemRow_n.c_str());
	}
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	_log(l_type, "%schanges: Dictionaty with %d enetires", pfx, changes.size());
	std::map<uint32, PyRep *>::const_iterator changes_cur, changes_end;
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, changes_cur->first);
		std::string n(pfx);
		n += "        ";
		changes_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *NotifyOnItemChange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: this is a util.Row  */
	if(itemRow == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnItemChange: itemRow is NULL! hacking in a PyRepNone");
		itemRow = new PyRepNone();
	}
	tuple0->items[0] = itemRow->Clone();
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator changes_cur, changes_end;
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		dict1->items[
			new PyRepInteger(changes_cur->first)
		] = changes_cur->second->Clone();
	}
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnItemChange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: this is a util.Row  */
	if(itemRow == NULL) {
		_log(NET__PACKET_ERROR, "Encode NotifyOnItemChange: itemRow is NULL! hacking in a PyRepNone");
		itemRow = new PyRepNone();
	}
	tuple0->items[0] = itemRow;
	itemRow = NULL;
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator changes_cur, changes_end;
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		dict1->items[
			new PyRepInteger(changes_cur->first)
		] = changes_cur->second;
	}
	changes.clear();
	tuple0->items[1] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool NotifyOnItemChange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnItemChange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnItemChange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnItemChange failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: this is a util.Row  */
	delete itemRow;
	itemRow = tuple0->items[0];
	tuple0->items[0] = NULL;
	
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	if(!tuple0->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnItemChange failed: changes is not a dict: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	changes.clear();
	PyRepDict *dict_1 = (PyRepDict *) tuple0->items[1];
	PyRepDict::iterator changes_cur, changes_end;
	changes_cur = dict_1->items.begin();
	changes_end = dict_1->items.end();
	int changes_index;
	for(changes_index = 0; changes_cur != changes_end; changes_cur++, changes_index++) {
		if(!changes_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode NotifyOnItemChange failed: Key %d in dict changes is not an integer: %s", changes_index, changes_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) changes_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode NotifyOnItemChange: truncating 64 bit into into 32 bit int in key of entry %d in field changes", changes_index);
		}
		changes[k->value] = changes_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

NotifyOnItemChange *NotifyOnItemChange::Clone() const {
	NotifyOnItemChange *res = new NotifyOnItemChange;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnItemChange::CloneFrom(const NotifyOnItemChange *from) {
	/*  0: this is a util.Row  */
	delete itemRow;
	if(from->itemRow == NULL) {
		itemRow = NULL;
	} else {
		itemRow = from->itemRow->Clone();
	}
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	std::map<uint32, PyRep *>::const_iterator changes_cur, changes_end;
	//free any existing elements first
	changes_cur = changes.begin();
	changes_end = changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		delete changes_cur->second;
	}
	changes.clear();
	//now we can copy in the new ones...
	changes_cur = from->changes.begin();
	changes_end = from->changes.end();
	for(; changes_cur != changes_end; changes_cur++) {
		changes[changes_cur->first] = changes_cur->second->Clone();
	}
	
	
}


NotifyOnSkillStartTraining::NotifyOnSkillStartTraining() {
	itemID = 0;
	endOfTraining = 0;
}

NotifyOnSkillStartTraining::~NotifyOnSkillStartTraining() {
}

void NotifyOnSkillStartTraining::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnSkillStartTraining", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%sendOfTraining=" I64u, pfx, endOfTraining);
}

PyRepTuple *NotifyOnSkillStartTraining::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(endOfTraining);
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnSkillStartTraining::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(endOfTraining);
	res = tuple0;
	

	return(res);
}

bool NotifyOnSkillStartTraining::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnSkillStartTraining::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnSkillStartTraining: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillStartTraining failed: endOfTraining is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_2 = (PyRepInteger *) tuple0->items[1];
	endOfTraining = int64_2->value;

	delete packet;
	return(true);
}

NotifyOnSkillStartTraining *NotifyOnSkillStartTraining::Clone() const {
	NotifyOnSkillStartTraining *res = new NotifyOnSkillStartTraining;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnSkillStartTraining::CloneFrom(const NotifyOnSkillStartTraining *from) {
	itemID = from->itemID;
	endOfTraining = from->endOfTraining;
	
}


NotifyOnSkillTrainingStopped::NotifyOnSkillTrainingStopped() {
	itemID = 0;
	endOfTraining = 0;
}

NotifyOnSkillTrainingStopped::~NotifyOnSkillTrainingStopped() {
}

void NotifyOnSkillTrainingStopped::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotifyOnSkillTrainingStopped", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%sendOfTraining=" I64u, pfx, endOfTraining);
}

PyRepTuple *NotifyOnSkillTrainingStopped::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(endOfTraining);
	res = tuple0;
	

	return(res);
}

PyRepTuple *NotifyOnSkillTrainingStopped::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(endOfTraining);
	res = tuple0;
	

	return(res);
}

bool NotifyOnSkillTrainingStopped::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool NotifyOnSkillTrainingStopped::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillTrainingStopped failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillTrainingStopped failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillTrainingStopped failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode NotifyOnSkillTrainingStopped: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode NotifyOnSkillTrainingStopped failed: endOfTraining is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_2 = (PyRepInteger *) tuple0->items[1];
	endOfTraining = int64_2->value;

	delete packet;
	return(true);
}

NotifyOnSkillTrainingStopped *NotifyOnSkillTrainingStopped::Clone() const {
	NotifyOnSkillTrainingStopped *res = new NotifyOnSkillTrainingStopped;
	res->CloneFrom(this);
	return(res);
}

void NotifyOnSkillTrainingStopped::CloneFrom(const NotifyOnSkillTrainingStopped *from) {
	itemID = from->itemID;
	endOfTraining = from->endOfTraining;
	
}


CallSetLabel::CallSetLabel() {
	itemID = 0;
	itemName = "";
}

CallSetLabel::~CallSetLabel() {
}

void CallSetLabel::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallSetLabel", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%sitemName='%s'", pfx, itemName.c_str());
}

PyRepTuple *CallSetLabel::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(itemName);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallSetLabel::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepString(itemName);
	res = tuple0;
	

	return(res);
}

bool CallSetLabel::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallSetLabel::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallSetLabel failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallSetLabel failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallSetLabel failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallSetLabel: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode CallSetLabel failed: itemName is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	itemName = string_2->value;

	delete packet;
	return(true);
}

CallSetLabel *CallSetLabel::Clone() const {
	CallSetLabel *res = new CallSetLabel;
	res->CloneFrom(this);
	return(res);
}

void CallSetLabel::CloneFrom(const CallSetLabel *from) {
	itemID = from->itemID;
	itemName = from->itemName;
	
}


InvBroker_BindArgs::InvBroker_BindArgs() {
	entityID = 0;
	unknown1 = NULL;
}

InvBroker_BindArgs::~InvBroker_BindArgs() {
	delete unknown1;
}

void InvBroker_BindArgs::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInvBroker_BindArgs", pfx);
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sunknown1:", pfx);
	std::string unknown1_n(pfx);
	unknown1_n += "    ";
	if(unknown1 == NULL) {
		_log(l_type, "%sERROR: NULL REP!", unknown1_n.c_str());
	} else {
		unknown1->Dump(l_type, unknown1_n.c_str());
	}
}

PyRepTuple *InvBroker_BindArgs::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(entityID);
	if(unknown1 == NULL) {
		_log(NET__PACKET_ERROR, "Encode InvBroker_BindArgs: unknown1 is NULL! hacking in a PyRepNone");
		unknown1 = new PyRepNone();
	}
	tuple0->items[1] = unknown1->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *InvBroker_BindArgs::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(entityID);
	if(unknown1 == NULL) {
		_log(NET__PACKET_ERROR, "Encode InvBroker_BindArgs: unknown1 is NULL! hacking in a PyRepNone");
		unknown1 = new PyRepNone();
	}
	tuple0->items[1] = unknown1;
	unknown1 = NULL;
	res = tuple0;
	

	return(res);
}

bool InvBroker_BindArgs::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool InvBroker_BindArgs::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode InvBroker_BindArgs failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode InvBroker_BindArgs failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode InvBroker_BindArgs failed: entityID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode InvBroker_BindArgs: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_1->value;
	delete unknown1;
	unknown1 = tuple0->items[1];
	tuple0->items[1] = NULL;
	

	delete packet;
	return(true);
}

InvBroker_BindArgs *InvBroker_BindArgs::Clone() const {
	InvBroker_BindArgs *res = new InvBroker_BindArgs;
	res->CloneFrom(this);
	return(res);
}

void InvBroker_BindArgs::CloneFrom(const InvBroker_BindArgs *from) {
	entityID = from->entityID;
	delete unknown1;
	if(from->unknown1 == NULL) {
		unknown1 = NULL;
	} else {
		unknown1 = from->unknown1->Clone();
	}
	
}


Inventory_GetInventory::Inventory_GetInventory() {
	container = 0;
	argument = NULL;
}

Inventory_GetInventory::~Inventory_GetInventory() {
	delete argument;
}

void Inventory_GetInventory::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_GetInventory", pfx);
	_log(l_type, "%scontainer=%lu", pfx, container);
	_log(l_type, "%sargument:", pfx);
	std::string argument_n(pfx);
	argument_n += "    ";
	if(argument == NULL) {
		_log(l_type, "%sERROR: NULL REP!", argument_n.c_str());
	} else {
		argument->Dump(l_type, argument_n.c_str());
	}
}

PyRepTuple *Inventory_GetInventory::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(container);
	if(argument == NULL) {
		_log(NET__PACKET_ERROR, "Encode Inventory_GetInventory: argument is NULL! hacking in a PyRepNone");
		argument = new PyRepNone();
	}
	tuple0->items[1] = argument->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_GetInventory::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(container);
	if(argument == NULL) {
		_log(NET__PACKET_ERROR, "Encode Inventory_GetInventory: argument is NULL! hacking in a PyRepNone");
		argument = new PyRepNone();
	}
	tuple0->items[1] = argument;
	argument = NULL;
	res = tuple0;
	

	return(res);
}

bool Inventory_GetInventory::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_GetInventory::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_GetInventory failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Inventory_GetInventory failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_GetInventory failed: container is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_GetInventory: truncating 64 bit into into 32 bit int for field container");
	}
	container = int_1->value;
	delete argument;
	argument = tuple0->items[1];
	tuple0->items[1] = NULL;
	

	delete packet;
	return(true);
}

Inventory_GetInventory *Inventory_GetInventory::Clone() const {
	Inventory_GetInventory *res = new Inventory_GetInventory;
	res->CloneFrom(this);
	return(res);
}

void Inventory_GetInventory::CloneFrom(const Inventory_GetInventory *from) {
	container = from->container;
	delete argument;
	if(from->argument == NULL) {
		argument = NULL;
	} else {
		argument = from->argument->Clone();
	}
	
}


Inventory_CallAdd::Inventory_CallAdd() {
	itemID = 0;
	quantity = 0;
	flag = 0;
}

Inventory_CallAdd::~Inventory_CallAdd() {
}

void Inventory_CallAdd::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallAdd", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%squantity=%lu", pfx, quantity);
	_log(l_type, "%sflag=%lu", pfx, flag);
}

PyRepTuple *Inventory_CallAdd::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(quantity);
	tuple0->items[2] = new PyRepInteger(flag);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallAdd::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(quantity);
	tuple0->items[2] = new PyRepInteger(flag);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallAdd::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallAdd::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAdd: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: quantity is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAdd: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAdd failed: flag is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAdd: truncating 64 bit into into 32 bit int for field flag");
	}
	flag = int_3->value;

	delete packet;
	return(true);
}

Inventory_CallAdd *Inventory_CallAdd::Clone() const {
	Inventory_CallAdd *res = new Inventory_CallAdd;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallAdd::CloneFrom(const Inventory_CallAdd *from) {
	itemID = from->itemID;
	quantity = from->quantity;
	flag = from->flag;
	
}


Inventory_CallAddCargoContainer::Inventory_CallAddCargoContainer() {
	itemID = 0;
	quantity = 0;
}

Inventory_CallAddCargoContainer::~Inventory_CallAddCargoContainer() {
}

void Inventory_CallAddCargoContainer::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallAddCargoContainer", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%squantity=%lu", pfx, quantity);
}

PyRepTuple *Inventory_CallAddCargoContainer::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(quantity);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallAddCargoContainer::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(itemID);
	tuple0->items[1] = new PyRepInteger(quantity);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallAddCargoContainer::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallAddCargoContainer::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAddCargoContainer failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAddCargoContainer failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAddCargoContainer failed: itemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAddCargoContainer: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallAddCargoContainer failed: quantity is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallAddCargoContainer: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_2->value;

	delete packet;
	return(true);
}

Inventory_CallAddCargoContainer *Inventory_CallAddCargoContainer::Clone() const {
	Inventory_CallAddCargoContainer *res = new Inventory_CallAddCargoContainer;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallAddCargoContainer::CloneFrom(const Inventory_CallAddCargoContainer *from) {
	itemID = from->itemID;
	quantity = from->quantity;
	
}


Inventory_CallMultiAdd::Inventory_CallMultiAdd() {
	quantity = 0;
	/*  almost always 1 on a multiadd  */
	flag = 0;
}

Inventory_CallMultiAdd::~Inventory_CallMultiAdd() {
	/*  almost always 1 on a multiadd  */
}

void Inventory_CallMultiAdd::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallMultiAdd", pfx);
	_log(l_type, "%sitemIDs: Integer list with %d enetires", pfx, itemIDs.size());
	std::vector<uint32>::const_iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, itemIDs_index, *itemIDs_cur);
	}
	
	_log(l_type, "%squantity=%lu", pfx, quantity);
	/*  almost always 1 on a multiadd  */
	_log(l_type, "%sflag=%lu", pfx, flag);
}

PyRepTuple *Inventory_CallMultiAdd::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	if(quantity == 1) {
		tuple0->items[1] = new PyRepNone();
	} else {
		tuple0->items[1] = new PyRepInteger(quantity);
	}
	/*  almost always 1 on a multiadd  */
	tuple0->items[2] = new PyRepInteger(flag);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallMultiAdd::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	if(quantity == 1) {
		tuple0->items[1] = new PyRepNone();
	} else {
		tuple0->items[1] = new PyRepInteger(quantity);
	}
	/*  almost always 1 on a multiadd  */
	tuple0->items[2] = new PyRepInteger(flag);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallMultiAdd::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallMultiAdd::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: itemIDs is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	itemIDs.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = list_1->items.begin();
	itemIDs_end = list_1->items.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		if(!(*itemIDs_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: Element %d in list itemIDs is not an integer: %s", itemIDs_index, (*itemIDs_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*itemIDs_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiAdd: truncating 64 bit into into 32 bit int for item %d in field itemIDs", itemIDs_index);
		}
		itemIDs.push_back(t->value);
	}

	if(tuple0->items[1]->CheckType(PyRep::None)) {
		quantity = 1;
	} else {
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: quantity is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiAdd: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_2->value;
	}
	/*  almost always 1 on a multiadd  */
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiAdd failed: flag is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiAdd: truncating 64 bit into into 32 bit int for field flag");
	}
	flag = int_3->value;

	delete packet;
	return(true);
}

Inventory_CallMultiAdd *Inventory_CallMultiAdd::Clone() const {
	Inventory_CallMultiAdd *res = new Inventory_CallMultiAdd;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallMultiAdd::CloneFrom(const Inventory_CallMultiAdd *from) {
	itemIDs = from->itemIDs;
	quantity = from->quantity;
	/*  almost always 1 on a multiadd  */
	flag = from->flag;
	
}


Inventory_CallReplaceCharges::Inventory_CallReplaceCharges() {
	flag = 0;
	itemID = 0;
	quantity = 0;
}

Inventory_CallReplaceCharges::~Inventory_CallReplaceCharges() {
}

void Inventory_CallReplaceCharges::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallReplaceCharges", pfx);
	_log(l_type, "%sflag=%lu", pfx, flag);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%squantity=%lu", pfx, quantity);
}

PyRepTuple *Inventory_CallReplaceCharges::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(flag);
	tuple0->items[1] = new PyRepInteger(itemID);
	tuple0->items[2] = new PyRepInteger(quantity);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallReplaceCharges::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(flag);
	tuple0->items[1] = new PyRepInteger(itemID);
	tuple0->items[2] = new PyRepInteger(quantity);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallReplaceCharges::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallReplaceCharges::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: flag is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallReplaceCharges: truncating 64 bit into into 32 bit int for field flag");
	}
	flag = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: itemID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallReplaceCharges: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallReplaceCharges failed: quantity is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallReplaceCharges: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_3->value;

	delete packet;
	return(true);
}

Inventory_CallReplaceCharges *Inventory_CallReplaceCharges::Clone() const {
	Inventory_CallReplaceCharges *res = new Inventory_CallReplaceCharges;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallReplaceCharges::CloneFrom(const Inventory_CallReplaceCharges *from) {
	flag = from->flag;
	itemID = from->itemID;
	quantity = from->quantity;
	
}


Inventory_CallMultiMergeElement::Inventory_CallMultiMergeElement() {
	draggedItemID = 0;
	stationaryItemID = 0;
	draggedQty = 0;
}

Inventory_CallMultiMergeElement::~Inventory_CallMultiMergeElement() {
}

void Inventory_CallMultiMergeElement::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallMultiMergeElement", pfx);
	_log(l_type, "%sdraggedItemID=%lu", pfx, draggedItemID);
	_log(l_type, "%sstationaryItemID=%lu", pfx, stationaryItemID);
	_log(l_type, "%sdraggedQty=%lu", pfx, draggedQty);
}

PyRepTuple *Inventory_CallMultiMergeElement::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(draggedItemID);
	tuple0->items[1] = new PyRepInteger(stationaryItemID);
	tuple0->items[2] = new PyRepInteger(draggedQty);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallMultiMergeElement::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	tuple0->items[0] = new PyRepInteger(draggedItemID);
	tuple0->items[1] = new PyRepInteger(stationaryItemID);
	tuple0->items[2] = new PyRepInteger(draggedQty);
	res = tuple0;
	

	return(res);
}

bool Inventory_CallMultiMergeElement::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallMultiMergeElement::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: draggedItemID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiMergeElement: truncating 64 bit into into 32 bit int for field draggedItemID");
	}
	draggedItemID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: stationaryItemID is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiMergeElement: truncating 64 bit into into 32 bit int for field stationaryItemID");
	}
	stationaryItemID = int_2->value;
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMergeElement failed: draggedQty is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallMultiMergeElement: truncating 64 bit into into 32 bit int for field draggedQty");
	}
	draggedQty = int_3->value;

	delete packet;
	return(true);
}

Inventory_CallMultiMergeElement *Inventory_CallMultiMergeElement::Clone() const {
	Inventory_CallMultiMergeElement *res = new Inventory_CallMultiMergeElement;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallMultiMergeElement::CloneFrom(const Inventory_CallMultiMergeElement *from) {
	draggedItemID = from->draggedItemID;
	stationaryItemID = from->stationaryItemID;
	draggedQty = from->draggedQty;
	
}


Inventory_CallMultiMerge::Inventory_CallMultiMerge() {
}

Inventory_CallMultiMerge::~Inventory_CallMultiMerge() {
}

void Inventory_CallMultiMerge::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallMultiMerge", pfx);
	_log(l_type, "%sMMElements: ", pfx);
	std::string MMElements_n(pfx);
	MMElements_n += "    ";
	MMElements.Dump(l_type, MMElements_n.c_str());
}

PyRepTuple *Inventory_CallMultiMerge::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	tuple0->items[0] = MMElements.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallMultiMerge::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	list1->items = MMElements.items;
	MMElements.items.clear();
	tuple0->items[0] = list1;
	res = tuple0;
	

	return(res);
}

bool Inventory_CallMultiMerge::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallMultiMerge::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMerge failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMerge failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallMultiMerge failed: MMElements is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_MMElements = (PyRepList *) tuple0->items[0];	MMElements.items = list_MMElements->items;
	list_MMElements->items.clear();
	

	delete packet;
	return(true);
}

Inventory_CallMultiMerge *Inventory_CallMultiMerge::Clone() const {
	Inventory_CallMultiMerge *res = new Inventory_CallMultiMerge;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallMultiMerge::CloneFrom(const Inventory_CallMultiMerge *from) {
	MMElements.CloneFrom(&from->MMElements);
	
}


Inventory_QuantityLessThanMinimumPortionException::Inventory_QuantityLessThanMinimumPortionException() {
	/* object of type ccp_exceptions.UserError */
	exceptionType = "QuantityLessThanMinimumPortion";
	typeName = "";
	portionSize = 0;
	exceptTypeDict = "QuantityLessThanMinimumPortion";
	typeName_dict = "";
	portionSize_dict = 0;
}

Inventory_QuantityLessThanMinimumPortionException::~Inventory_QuantityLessThanMinimumPortionException() {
}

void Inventory_QuantityLessThanMinimumPortionException::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_QuantityLessThanMinimumPortionException", pfx);
	_log(l_type, "%sObject of type ccp_exceptions.UserError:", pfx);
	_log(l_type, "%sexceptionType='%s'", pfx, exceptionType.c_str());
	_log(l_type, "%stypeName='%s'", pfx, typeName.c_str());
	_log(l_type, "%sportionSize=%lu", pfx, portionSize);
	_log(l_type, "%sexceptTypeDict='%s'", pfx, exceptTypeDict.c_str());
	_log(l_type, "%stypeName_dict='%s'", pfx, typeName_dict.c_str());
	_log(l_type, "%sportionSize_dict=%lu", pfx, portionSize_dict);
}

PyRepObject *Inventory_QuantityLessThanMinimumPortionException::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	tuple2->items[0] = new PyRepString(exceptionType);
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	dict3_0 = new PyRepString(typeName);
	dict3->items[
		new PyRepString("typename")
	] = dict3_0;
	PyRep *dict3_1;
	dict3_1 = new PyRepInteger(portionSize);
	dict3->items[
		new PyRepString("portion")
	] = dict3_1;
	tuple2->items[1] = dict3;
	
	dict1_0 = tuple2;
	
	dict1->items[
		new PyRepString("args")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(exceptTypeDict);
	dict1->items[
		new PyRepString("msg")
	] = dict1_1;
	PyRep *dict1_2;
	PyRepDict *dict4 = new PyRepDict();
	PyRep *dict4_0;
	dict4_0 = new PyRepString(typeName_dict);
	dict4->items[
		new PyRepString("typename")
	] = dict4_0;
	PyRep *dict4_1;
	dict4_1 = new PyRepInteger(portionSize_dict);
	dict4->items[
		new PyRepString("portion")
	] = dict4_1;
	dict1_2 = dict4;
	
	dict1->items[
		new PyRepString("dict")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"ccp_exceptions.UserError",
			args0
		);
	

	return(res);
}

PyRepObject *Inventory_QuantityLessThanMinimumPortionException::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepTuple *tuple2 = new PyRepTuple(2);
	tuple2->items[0] = new PyRepString(exceptionType);
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	dict3_0 = new PyRepString(typeName);
	dict3->items[
		new PyRepString("typename")
	] = dict3_0;
	PyRep *dict3_1;
	dict3_1 = new PyRepInteger(portionSize);
	dict3->items[
		new PyRepString("portion")
	] = dict3_1;
	tuple2->items[1] = dict3;
	
	dict1_0 = tuple2;
	
	dict1->items[
		new PyRepString("args")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(exceptTypeDict);
	dict1->items[
		new PyRepString("msg")
	] = dict1_1;
	PyRep *dict1_2;
	PyRepDict *dict4 = new PyRepDict();
	PyRep *dict4_0;
	dict4_0 = new PyRepString(typeName_dict);
	dict4->items[
		new PyRepString("typename")
	] = dict4_0;
	PyRep *dict4_1;
	dict4_1 = new PyRepInteger(portionSize_dict);
	dict4->items[
		new PyRepString("portion")
	] = dict4_1;
	dict1_2 = dict4;
	
	dict1->items[
		new PyRepString("dict")
	] = dict1_2;
	args0 = dict1;
	
	res = new PyRepObject(
			"ccp_exceptions.UserError",
			args0
		);
	

	return(res);
}

bool Inventory_QuantityLessThanMinimumPortionException::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_QuantityLessThanMinimumPortionException::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "ccp_exceptions.UserError") {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: obj_0 is the wrong object type. Expected 'ccp_exceptions.UserError', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_args_tuple = false;
	bool dict1_exceptTypeDict = false;
	bool dict1_arg_dict = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "args") {
			dict1_args_tuple = true;
	if(!dict1_cur->second->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: tuple2 is the wrong type: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) dict1_cur->second;
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: exceptionType is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	exceptionType = string_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: dict4 is the wrong type: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	bool dict4_typeName = false;
	bool dict4_portionSize = false;
	PyRepDict *dict4 = (PyRepDict *) tuple2->items[1];
	
	PyRepDict::iterator dict4_cur, dict4_end;
	dict4_cur = dict4->items.begin();
	dict4_end = dict4->items.end();
	for(; dict4_cur != dict4_end; dict4_cur++) {
		PyRep *key__ = dict4_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: a key in dict4 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "typename") {
			dict4_typeName = true;
	if(!dict4_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: typeName is not a string: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) dict4_cur->second;
	typeName = string_5->value;
		} else
		if(key_string__->value == "portion") {
			dict4_portionSize = true;
	if(!dict4_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: portionSize is not an int: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) dict4_cur->second;
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_QuantityLessThanMinimumPortionException: truncating 64 bit into into 32 bit int for field portionSize");
	}
	portionSize = int_6->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Unknown key string '%s' in dict4", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict4_typeName) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Missing dict entry for 'typeName' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_portionSize) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Missing dict entry for 'portionSize' in dict4");
		delete packet;
		return(false);
	}
	
		} else
		if(key_string__->value == "msg") {
			dict1_exceptTypeDict = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: exceptTypeDict is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) dict1_cur->second;
	exceptTypeDict = string_7->value;
		} else
		if(key_string__->value == "dict") {
			dict1_arg_dict = true;
	if(!dict1_cur->second->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: dict8 is the wrong type: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	bool dict8_typeName_dict = false;
	bool dict8_portionSize_dict = false;
	PyRepDict *dict8 = (PyRepDict *) dict1_cur->second;
	
	PyRepDict::iterator dict8_cur, dict8_end;
	dict8_cur = dict8->items.begin();
	dict8_end = dict8->items.end();
	for(; dict8_cur != dict8_end; dict8_cur++) {
		PyRep *key__ = dict8_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: a key in dict8 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "typename") {
			dict8_typeName_dict = true;
	if(!dict8_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: typeName_dict is not a string: %s", dict8_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) dict8_cur->second;
	typeName_dict = string_9->value;
		} else
		if(key_string__->value == "portion") {
			dict8_portionSize_dict = true;
	if(!dict8_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: portionSize_dict is not an int: %s", dict8_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) dict8_cur->second;
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_QuantityLessThanMinimumPortionException: truncating 64 bit into into 32 bit int for field portionSize_dict");
	}
	portionSize_dict = int_10->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Unknown key string '%s' in dict8", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict8_typeName_dict) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Missing dict entry for 'typeName_dict' in dict8");
		delete packet;
		return(false);
	}
	
	if(!dict8_portionSize_dict) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Missing dict entry for 'portionSize_dict' in dict8");
		delete packet;
		return(false);
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_args_tuple) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Missing dict entry for 'args_tuple' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_exceptTypeDict) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Missing dict entry for 'exceptTypeDict' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_arg_dict) {
		_log(NET__PACKET_ERROR, "Decode Inventory_QuantityLessThanMinimumPortionException failed: Missing dict entry for 'arg_dict' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Inventory_QuantityLessThanMinimumPortionException *Inventory_QuantityLessThanMinimumPortionException::Clone() const {
	Inventory_QuantityLessThanMinimumPortionException *res = new Inventory_QuantityLessThanMinimumPortionException;
	res->CloneFrom(this);
	return(res);
}

void Inventory_QuantityLessThanMinimumPortionException::CloneFrom(const Inventory_QuantityLessThanMinimumPortionException *from) {
	/* object of type ccp_exceptions.UserError */
	exceptionType = from->exceptionType;
	typeName = from->typeName;
	portionSize = from->portionSize;
	exceptTypeDict = from->exceptTypeDict;
	typeName_dict = from->typeName_dict;
	portionSize_dict = from->portionSize_dict;
	
}


Inventory_CallStackAll::Inventory_CallStackAll() {
	locationFlag = 0;
}

Inventory_CallStackAll::~Inventory_CallStackAll() {
}

void Inventory_CallStackAll::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sInventory_CallStackAll", pfx);
	_log(l_type, "%slocationFlag=%lu", pfx, locationFlag);
}

PyRepTuple *Inventory_CallStackAll::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	if(locationFlag == 0) {
		tuple0->items[0] = new PyRepNone();
	} else {
		tuple0->items[0] = new PyRepInteger(locationFlag);
	}
	res = tuple0;
	

	return(res);
}

PyRepTuple *Inventory_CallStackAll::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	if(locationFlag == 0) {
		tuple0->items[0] = new PyRepNone();
	} else {
		tuple0->items[0] = new PyRepInteger(locationFlag);
	}
	res = tuple0;
	

	return(res);
}

bool Inventory_CallStackAll::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Inventory_CallStackAll::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallStackAll failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallStackAll failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(tuple0->items[0]->CheckType(PyRep::None)) {
		locationFlag = 0;
	} else {
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Inventory_CallStackAll failed: locationFlag is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Inventory_CallStackAll: truncating 64 bit into into 32 bit int for field locationFlag");
	}
	locationFlag = int_1->value;
	}

	delete packet;
	return(true);
}

Inventory_CallStackAll *Inventory_CallStackAll::Clone() const {
	Inventory_CallStackAll *res = new Inventory_CallStackAll;
	res->CloneFrom(this);
	return(res);
}

void Inventory_CallStackAll::CloneFrom(const Inventory_CallStackAll *from) {
	locationFlag = from->locationFlag;
	
}


OnModuleAttributeChange::OnModuleAttributeChange() {
	/*  0  */
	/*  0  */
	/*  0  */
	string0 = "OnModuleAttributeChange";
	/*  1  */
	ownerID = 0;
	/*  2  */
	itemKey = 0;
	/*  3  */
	attributeID = 0;
	/*  4  */
	time = 0;
	/*  5  */
	newValue = 0.0;
	/*  6  */
	/*  0  */
	newValue2 = 0.0;
	/*  1  */
	time2 = 0;
	/*  2  */
	real8 = 0.0;
	/*  3  */
	oldValue = 0.0;
}

OnModuleAttributeChange::~OnModuleAttributeChange() {
	/*  0  */
	/*  0  */
	/*  0  */
	/*  1  */
	/*  2  */
	/*  3  */
	/*  4  */
	/*  5  */
	/*  6  */
	/*  0  */
	/*  1  */
	/*  2  */
	/*  3  */
}

void OnModuleAttributeChange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnModuleAttributeChange", pfx);
	/*  0  */
	/*  0  */
	/*  0  */
	_log(l_type, "%sstring0='%s'", pfx, string0.c_str());
	/*  1  */
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	/*  2  */
	_log(l_type, "%sitemKey=%lu", pfx, itemKey);
	/*  3  */
	_log(l_type, "%sattributeID=%lu", pfx, attributeID);
	/*  4  */
	_log(l_type, "%stime=" I64u, pfx, time);
	/*  5  */
	_log(l_type, "%snewValue=%.13f", pfx, newValue);
	/*  6  */
	/*  0  */
	_log(l_type, "%snewValue2=%.13f", pfx, newValue2);
	/*  1  */
	_log(l_type, "%stime2=" I64u, pfx, time2);
	/*  2  */
	_log(l_type, "%sreal8=%.13f", pfx, real8);
	/*  3  */
	_log(l_type, "%soldValue=%.13f", pfx, oldValue);
}

PyRepTuple *OnModuleAttributeChange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(1, NULL);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(7);
	/*  0  */
	tuple2->items[0] = new PyRepString(string0);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(ownerID);
	/*  2  */
	tuple2->items[2] = new PyRepInteger(itemKey);
	/*  3  */
	tuple2->items[3] = new PyRepInteger(attributeID);
	/*  4  */
	tuple2->items[4] = new PyRepInteger(time);
	/*  5  */
	tuple2->items[5] = new PyRepReal(newValue);
	/*  6  */
	PyRepList *list3 = new PyRepList();
	list3->items.resize(4, NULL);
	/*  0  */
	list3->items[0] = new PyRepReal(newValue2);
	/*  1  */
	list3->items[1] = new PyRepInteger(time2);
	/*  2  */
	list3->items[2] = new PyRepReal(real8);
	/*  3  */
	list3->items[3] = new PyRepReal(oldValue);
	tuple2->items[6] = list3;
	
	list1->items[0] = tuple2;
	
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnModuleAttributeChange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(1, NULL);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(7);
	/*  0  */
	tuple2->items[0] = new PyRepString(string0);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(ownerID);
	/*  2  */
	tuple2->items[2] = new PyRepInteger(itemKey);
	/*  3  */
	tuple2->items[3] = new PyRepInteger(attributeID);
	/*  4  */
	tuple2->items[4] = new PyRepInteger(time);
	/*  5  */
	tuple2->items[5] = new PyRepReal(newValue);
	/*  6  */
	PyRepList *list3 = new PyRepList();
	list3->items.resize(4, NULL);
	/*  0  */
	list3->items[0] = new PyRepReal(newValue2);
	/*  1  */
	list3->items[1] = new PyRepInteger(time2);
	/*  2  */
	list3->items[2] = new PyRepReal(real8);
	/*  3  */
	list3->items[3] = new PyRepReal(oldValue);
	tuple2->items[6] = list3;
	
	list1->items[0] = tuple2;
	
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool OnModuleAttributeChange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnModuleAttributeChange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: list1 is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list1 = (PyRepList *) tuple0->items[0];
	if(list1->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: list1 is the wrong size: expected 1, but got %d", list1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!list1->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: tuple2 is the wrong type: %s", list1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) list1->items[0];
	if(tuple2->items.size() != 7) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: tuple2 is the wrong size: expected 7, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: string0 is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	string0 = string_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: ownerID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnModuleAttributeChange: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_4->value;
	/*  2  */
	if(!tuple2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: itemKey is not an int: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnModuleAttributeChange: truncating 64 bit into into 32 bit int for field itemKey");
	}
	itemKey = int_5->value;
	/*  3  */
	if(!tuple2->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: attributeID is not an int: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple2->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnModuleAttributeChange: truncating 64 bit into into 32 bit int for field attributeID");
	}
	attributeID = int_6->value;
	/*  4  */
	if(!tuple2->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: time is not an int: %s", tuple2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_7 = (PyRepInteger *) tuple2->items[4];
	time = int64_7->value;
	/*  5  */
	if(!tuple2->items[5]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: newValue is not a real: %s", tuple2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_8 = (PyRepReal *) tuple2->items[5];
	newValue = real_8->value;
	/*  6  */
	if(!tuple2->items[6]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: list9 is not a list: %s", tuple2->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list9 = (PyRepList *) tuple2->items[6];
	if(list9->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: list9 is the wrong size: expected 4, but got %d", list9->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!list9->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: newValue2 is not a real: %s", list9->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_10 = (PyRepReal *) list9->items[0];
	newValue2 = real_10->value;
	/*  1  */
	if(!list9->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: time2 is not an int: %s", list9->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_11 = (PyRepInteger *) list9->items[1];
	time2 = int64_11->value;
	/*  2  */
	if(!list9->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: real8 is not a real: %s", list9->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_12 = (PyRepReal *) list9->items[2];
	real8 = real_12->value;
	/*  3  */
	if(!list9->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnModuleAttributeChange failed: oldValue is not a real: %s", list9->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_13 = (PyRepReal *) list9->items[3];
	oldValue = real_13->value;

	delete packet;
	return(true);
}

OnModuleAttributeChange *OnModuleAttributeChange::Clone() const {
	OnModuleAttributeChange *res = new OnModuleAttributeChange;
	res->CloneFrom(this);
	return(res);
}

void OnModuleAttributeChange::CloneFrom(const OnModuleAttributeChange *from) {
	/*  0  */
	/*  0  */
	/*  0  */
	string0 = from->string0;
	/*  1  */
	ownerID = from->ownerID;
	/*  2  */
	itemKey = from->itemKey;
	/*  3  */
	attributeID = from->attributeID;
	/*  4  */
	time = from->time;
	/*  5  */
	newValue = from->newValue;
	/*  6  */
	/*  0  */
	newValue2 = from->newValue2;
	/*  1  */
	time2 = from->time2;
	/*  2  */
	real8 = from->real8;
	/*  3  */
	oldValue = from->oldValue;
	
}


Call_GetJournal::Call_GetJournal() {
	accountKey = 0;
	fromDate = 0;
	/*  may be None (but prolly wont be)  */
	refTypeID = 0;
	/*  may be None  */
	corpAccount = NULL;
	/*  soft bool  */
	refID = NULL;
	/*  may be None  */
	rev = 0;
}

Call_GetJournal::~Call_GetJournal() {
	/*  may be None (but prolly wont be)  */
	/*  may be None  */
	delete corpAccount;
	/*  soft bool  */
	delete refID;
	/*  may be None  */
}

void Call_GetJournal::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_GetJournal", pfx);
	_log(l_type, "%saccountKey=%lu", pfx, accountKey);
	_log(l_type, "%sfromDate=" I64u, pfx, fromDate);
	/*  may be None (but prolly wont be)  */
	_log(l_type, "%srefTypeID=%lu", pfx, refTypeID);
	/*  may be None  */
	_log(l_type, "%scorpAccount:", pfx);
	std::string corpAccount_n(pfx);
	corpAccount_n += "    ";
	if(corpAccount == NULL) {
		_log(l_type, "%sERROR: NULL REP!", corpAccount_n.c_str());
	} else {
		corpAccount->Dump(l_type, corpAccount_n.c_str());
	}
	/*  soft bool  */
	_log(l_type, "%srefID:", pfx);
	std::string refID_n(pfx);
	refID_n += "    ";
	if(refID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", refID_n.c_str());
	} else {
		refID->Dump(l_type, refID_n.c_str());
	}
	/*  may be None  */
	_log(l_type, "%srev=%lu", pfx, rev);
}

PyRepTuple *Call_GetJournal::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(6);
	tuple0->items[0] = new PyRepInteger(accountKey);
	if(fromDate == 0) {
		tuple0->items[1] = new PyRepNone();
	} else {
		tuple0->items[1] = new PyRepInteger(fromDate);
	}
	/*  may be None (but prolly wont be)  */
	if(refTypeID == 0) {
		tuple0->items[2] = new PyRepNone();
	} else {
		tuple0->items[2] = new PyRepInteger(refTypeID);
	}
	/*  may be None  */
	if(corpAccount == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_GetJournal: corpAccount is NULL! hacking in a PyRepNone");
		corpAccount = new PyRepNone();
	}
	tuple0->items[3] = corpAccount->Clone();
	/*  soft bool  */
	if(refID == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_GetJournal: refID is NULL! hacking in a PyRepNone");
		refID = new PyRepNone();
	}
	tuple0->items[4] = refID->Clone();
	/*  may be None  */
	tuple0->items[5] = new PyRepInteger(rev);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_GetJournal::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(6);
	tuple0->items[0] = new PyRepInteger(accountKey);
	if(fromDate == 0) {
		tuple0->items[1] = new PyRepNone();
	} else {
		tuple0->items[1] = new PyRepInteger(fromDate);
	}
	/*  may be None (but prolly wont be)  */
	if(refTypeID == 0) {
		tuple0->items[2] = new PyRepNone();
	} else {
		tuple0->items[2] = new PyRepInteger(refTypeID);
	}
	/*  may be None  */
	if(corpAccount == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_GetJournal: corpAccount is NULL! hacking in a PyRepNone");
		corpAccount = new PyRepNone();
	}
	tuple0->items[3] = corpAccount;
	corpAccount = NULL;
	/*  soft bool  */
	if(refID == NULL) {
		_log(NET__PACKET_ERROR, "Encode Call_GetJournal: refID is NULL! hacking in a PyRepNone");
		refID = new PyRepNone();
	}
	tuple0->items[4] = refID;
	refID = NULL;
	/*  may be None  */
	tuple0->items[5] = new PyRepInteger(rev);
	res = tuple0;
	

	return(res);
}

bool Call_GetJournal::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_GetJournal::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: tuple0 is the wrong size: expected 6, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: accountKey is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetJournal: truncating 64 bit into into 32 bit int for field accountKey");
	}
	accountKey = int_1->value;
	if(tuple0->items[1]->CheckType(PyRep::None)) {
		fromDate = 0;
	} else {
	if(!tuple0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: fromDate is not an int: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_2 = (PyRepInteger *) tuple0->items[1];
	fromDate = int64_2->value;
	}
	/*  may be None (but prolly wont be)  */
	if(tuple0->items[2]->CheckType(PyRep::None)) {
		refTypeID = 0;
	} else {
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: refTypeID is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetJournal: truncating 64 bit into into 32 bit int for field refTypeID");
	}
	refTypeID = int_3->value;
	}
	/*  may be None  */
	delete corpAccount;
	corpAccount = tuple0->items[3];
	tuple0->items[3] = NULL;
	
	/*  soft bool  */
	delete refID;
	refID = tuple0->items[4];
	tuple0->items[4] = NULL;
	
	/*  may be None  */
	if(!tuple0->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetJournal failed: rev is not an int: %s", tuple0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple0->items[5];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetJournal: truncating 64 bit into into 32 bit int for field rev");
	}
	rev = int_4->value;

	delete packet;
	return(true);
}

Call_GetJournal *Call_GetJournal::Clone() const {
	Call_GetJournal *res = new Call_GetJournal;
	res->CloneFrom(this);
	return(res);
}

void Call_GetJournal::CloneFrom(const Call_GetJournal *from) {
	accountKey = from->accountKey;
	fromDate = from->fromDate;
	/*  may be None (but prolly wont be)  */
	refTypeID = from->refTypeID;
	/*  may be None  */
	delete corpAccount;
	if(from->corpAccount == NULL) {
		corpAccount = NULL;
	} else {
		corpAccount = from->corpAccount->Clone();
	}
	/*  soft bool  */
	delete refID;
	if(from->refID == NULL) {
		refID = NULL;
	} else {
		refID = from->refID->Clone();
	}
	/*  may be None  */
	rev = from->rev;
	
}


Call_AssembleShip::Call_AssembleShip() {
}

Call_AssembleShip::~Call_AssembleShip() {
}

void Call_AssembleShip::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_AssembleShip", pfx);
	_log(l_type, "%sitems: Integer list with %d enetires", pfx, items.size());
	std::vector<uint32>::const_iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	int items_index;
	for(items_index = 0; items_cur != items_end; items_cur++, items_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, items_index, *items_cur);
	}
	
}

PyRepTuple *Call_AssembleShip::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		list1->items.push_back(
			new PyRepInteger(*items_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_AssembleShip::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		list1->items.push_back(
			new PyRepInteger(*items_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool Call_AssembleShip::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_AssembleShip::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_AssembleShip failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_AssembleShip failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_AssembleShip failed: items is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	items.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator items_cur, items_end;
	items_cur = list_1->items.begin();
	items_end = list_1->items.end();
	int items_index;
	for(items_index = 0; items_cur != items_end; items_cur++, items_index++) {
		if(!(*items_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_AssembleShip failed: Element %d in list items is not an integer: %s", items_index, (*items_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*items_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_AssembleShip: truncating 64 bit into into 32 bit int for item %d in field items", items_index);
		}
		items.push_back(t->value);
	}


	delete packet;
	return(true);
}

Call_AssembleShip *Call_AssembleShip::Clone() const {
	Call_AssembleShip *res = new Call_AssembleShip;
	res->CloneFrom(this);
	return(res);
}

void Call_AssembleShip::CloneFrom(const Call_AssembleShip *from) {
	items = from->items;
	
}


EntityEffectState::EntityEffectState() {
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	env_itemID = 0;
	env_charID = 0;
	env_shipID = 0;
	env_target = 0;
	/*  optional  */
	env_other = 0;
	/*  optional (not positive that this is an int)  */
	/*  not sure what data goes in here.  */
	env_effectID = 0;
	/*  End Environment  */
	startTime = 0;
	duration = 0;
	/*  saw 0x7 placeholder  */
	repeat = 0;
	/*  saw 0  */
	/*  randomSeed  */
}

EntityEffectState::~EntityEffectState() {
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	/*  optional  */
	/*  optional (not positive that this is an int)  */
	/*  not sure what data goes in here.  */
	/*  End Environment  */
	/*  saw 0x7 placeholder  */
	/*  saw 0  */
	/*  randomSeed  */
}

void EntityEffectState::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sEntityEffectState", pfx);
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	_log(l_type, "%senv_itemID=%lu", pfx, env_itemID);
	_log(l_type, "%senv_charID=%lu", pfx, env_charID);
	_log(l_type, "%senv_shipID=%lu", pfx, env_shipID);
	_log(l_type, "%senv_target=%lu", pfx, env_target);
	/*  optional  */
	_log(l_type, "%senv_other=%lu", pfx, env_other);
	/*  optional (not positive that this is an int)  */
	_log(l_type, "%senv_area: ", pfx);
	std::string env_area_n(pfx);
	env_area_n += "    ";
	env_area.Dump(l_type, env_area_n.c_str());
	/*  not sure what data goes in here.  */
	_log(l_type, "%senv_effectID=%lu", pfx, env_effectID);
	/*  End Environment  */
	_log(l_type, "%sstartTime=" I64u, pfx, startTime);
	_log(l_type, "%sduration=%lu", pfx, duration);
	/*  saw 0x7 placeholder  */
	_log(l_type, "%srepeat=%lu", pfx, repeat);
	/*  saw 0  */
	/*  randomSeed  */
}

PyRepList *EntityEffectState::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(11, NULL);
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	list0->items[0] = new PyRepInteger(env_itemID);
	list0->items[1] = new PyRepInteger(env_charID);
	list0->items[2] = new PyRepInteger(env_shipID);
	if(env_target == 0) {
		list0->items[3] = new PyRepNone();
	} else {
		list0->items[3] = new PyRepInteger(env_target);
	}
	/*  optional  */
	if(env_other == 0) {
		list0->items[4] = new PyRepNone();
	} else {
		list0->items[4] = new PyRepInteger(env_other);
	}
	/*  optional (not positive that this is an int)  */
	list0->items[5] = env_area.Clone();
	/*  not sure what data goes in here.  */
	list0->items[6] = new PyRepInteger(env_effectID);
	/*  End Environment  */
	list0->items[7] = new PyRepInteger(startTime);
	list0->items[8] = new PyRepInteger(duration);
	/*  saw 0x7 placeholder  */
	list0->items[9] = new PyRepInteger(repeat);
	/*  saw 0  */
	list0->items[10] = new PyRepNone();
	/*  randomSeed  */
	res = list0;
	

	return(res);
}

PyRepList *EntityEffectState::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(11, NULL);
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	list0->items[0] = new PyRepInteger(env_itemID);
	list0->items[1] = new PyRepInteger(env_charID);
	list0->items[2] = new PyRepInteger(env_shipID);
	if(env_target == 0) {
		list0->items[3] = new PyRepNone();
	} else {
		list0->items[3] = new PyRepInteger(env_target);
	}
	/*  optional  */
	if(env_other == 0) {
		list0->items[4] = new PyRepNone();
	} else {
		list0->items[4] = new PyRepInteger(env_other);
	}
	/*  optional (not positive that this is an int)  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = env_area.items;
	env_area.items.clear();
	list0->items[5] = list1;
	/*  not sure what data goes in here.  */
	list0->items[6] = new PyRepInteger(env_effectID);
	/*  End Environment  */
	list0->items[7] = new PyRepInteger(startTime);
	list0->items[8] = new PyRepInteger(duration);
	/*  saw 0x7 placeholder  */
	list0->items[9] = new PyRepInteger(repeat);
	/*  saw 0  */
	list0->items[10] = new PyRepNone();
	/*  randomSeed  */
	res = list0;
	

	return(res);
}

bool EntityEffectState::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool EntityEffectState::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 11) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: list0 is the wrong size: expected 11, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_itemID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_itemID");
	}
	env_itemID = int_1->value;
	if(!list0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_charID is not an int: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_charID");
	}
	env_charID = int_2->value;
	if(!list0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_shipID is not an int: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_shipID");
	}
	env_shipID = int_3->value;
	if(list0->items[3]->CheckType(PyRep::None)) {
		env_target = 0;
	} else {
	if(!list0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_target is not an int: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_target");
	}
	env_target = int_4->value;
	}
	/*  optional  */
	if(list0->items[4]->CheckType(PyRep::None)) {
		env_other = 0;
	} else {
	if(!list0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_other is not an int: %s", list0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) list0->items[4];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_other");
	}
	env_other = int_5->value;
	}
	/*  optional (not positive that this is an int)  */
	if(!list0->items[5]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_area is not a list: %s", list0->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_env_area = (PyRepList *) list0->items[5];	env_area.items = list_env_area->items;
	list_env_area->items.clear();
	
	/*  not sure what data goes in here.  */
	if(!list0->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: env_effectID is not an int: %s", list0->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) list0->items[6];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field env_effectID");
	}
	env_effectID = int_6->value;
	/*  End Environment  */
	if(!list0->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: startTime is not an int: %s", list0->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_7 = (PyRepInteger *) list0->items[7];
	startTime = int64_7->value;
	if(!list0->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: duration is not an int: %s", list0->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) list0->items[8];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field duration");
	}
	duration = int_8->value;
	/*  saw 0x7 placeholder  */
	if(!list0->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: repeat is not an int: %s", list0->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) list0->items[9];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityEffectState: truncating 64 bit into into 32 bit int for field repeat");
	}
	repeat = int_9->value;
	/*  saw 0  */
	if(!list0->items[10]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode EntityEffectState failed: expecting a None but got a %s", list0->items[10]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  randomSeed  */

	delete packet;
	return(true);
}

EntityEffectState *EntityEffectState::Clone() const {
	EntityEffectState *res = new EntityEffectState;
	res->CloneFrom(this);
	return(res);
}

void EntityEffectState::CloneFrom(const EntityEffectState *from) {
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	env_itemID = from->env_itemID;
	env_charID = from->env_charID;
	env_shipID = from->env_shipID;
	env_target = from->env_target;
	/*  optional  */
	env_other = from->env_other;
	/*  optional (not positive that this is an int)  */
	env_area.CloneFrom(&from->env_area);
	/*  not sure what data goes in here.  */
	env_effectID = from->env_effectID;
	/*  End Environment  */
	startTime = from->startTime;
	duration = from->duration;
	/*  saw 0x7 placeholder  */
	repeat = from->repeat;
	/*  saw 0  */
	/*  randomSeed  */
	
}


Rsp_CommonGetInfo_Entry::Rsp_CommonGetInfo_Entry() {
	itemID = 0;
	/*  this is an EntityRowObject  */
	invItem = NULL;
	/*  this maps effectType to EntityEffectState  */
	/*  maps attribute ID to it's value, which may be int or real  */
	time = 0;
}

Rsp_CommonGetInfo_Entry::~Rsp_CommonGetInfo_Entry() {
	/*  this is an EntityRowObject  */
	delete invItem;
	/*  this maps effectType to EntityEffectState  */
	std::map<uint32, PyRep *>::iterator activeEffects_cur, activeEffects_end;
	//free any existing elements first
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		delete activeEffects_cur->second;
	}
	
	/*  maps attribute ID to it's value, which may be int or real  */
	std::map<uint32, PyRep *>::iterator attributes_cur, attributes_end;
	//free any existing elements first
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		delete attributes_cur->second;
	}
	
}

void Rsp_CommonGetInfo_Entry::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_CommonGetInfo_Entry", pfx);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	/*  this is an EntityRowObject  */
	_log(l_type, "%sinvItem:", pfx);
	std::string invItem_n(pfx);
	invItem_n += "    ";
	if(invItem == NULL) {
		_log(l_type, "%sERROR: NULL REP!", invItem_n.c_str());
	} else {
		invItem->Dump(l_type, invItem_n.c_str());
	}
	/*  this maps effectType to EntityEffectState  */
	_log(l_type, "%sactiveEffects: Dictionaty with %d enetires", pfx, activeEffects.size());
	std::map<uint32, PyRep *>::const_iterator activeEffects_cur, activeEffects_end;
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, activeEffects_cur->first);
		std::string n(pfx);
		n += "        ";
		activeEffects_cur->second->Dump(stdout, n.c_str());
	}
	
	/*  maps attribute ID to it's value, which may be int or real  */
	_log(l_type, "%sattributes: Dictionaty with %d enetires", pfx, attributes.size());
	std::map<uint32, PyRep *>::const_iterator attributes_cur, attributes_end;
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, attributes_cur->first);
		std::string n(pfx);
		n += "        ";
		attributes_cur->second->Dump(stdout, n.c_str());
	}
	
	_log(l_type, "%stime=" I64u, pfx, time);
}

PyRepList *Rsp_CommonGetInfo_Entry::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(5, NULL);
	list0->items[0] = new PyRepInteger(itemID);
	/*  this is an EntityRowObject  */
	if(invItem == NULL) {
		_log(NET__PACKET_ERROR, "Encode Rsp_CommonGetInfo_Entry: invItem is NULL! hacking in a PyRepNone");
		invItem = new PyRepNone();
	}
	list0->items[1] = invItem->Clone();
	/*  this maps effectType to EntityEffectState  */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator activeEffects_cur, activeEffects_end;
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		dict1->items[
			new PyRepInteger(activeEffects_cur->first)
		] = activeEffects_cur->second->Clone();
	}
	list0->items[2] = dict1;
	
	/*  maps attribute ID to it's value, which may be int or real  */
	
	PyRepDict *dict2 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator attributes_cur, attributes_end;
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		dict2->items[
			new PyRepInteger(attributes_cur->first)
		] = attributes_cur->second->Clone();
	}
	list0->items[3] = dict2;
	
	list0->items[4] = new PyRepInteger(time);
	res = list0;
	

	return(res);
}

PyRepList *Rsp_CommonGetInfo_Entry::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(5, NULL);
	list0->items[0] = new PyRepInteger(itemID);
	/*  this is an EntityRowObject  */
	if(invItem == NULL) {
		_log(NET__PACKET_ERROR, "Encode Rsp_CommonGetInfo_Entry: invItem is NULL! hacking in a PyRepNone");
		invItem = new PyRepNone();
	}
	list0->items[1] = invItem;
	invItem = NULL;
	/*  this maps effectType to EntityEffectState  */
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator activeEffects_cur, activeEffects_end;
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		dict1->items[
			new PyRepInteger(activeEffects_cur->first)
		] = activeEffects_cur->second;
	}
	activeEffects.clear();
	list0->items[2] = dict1;
	
	/*  maps attribute ID to it's value, which may be int or real  */
	
	PyRepDict *dict2 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator attributes_cur, attributes_end;
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		dict2->items[
			new PyRepInteger(attributes_cur->first)
		] = attributes_cur->second;
	}
	attributes.clear();
	list0->items[3] = dict2;
	
	list0->items[4] = new PyRepInteger(time);
	res = list0;
	

	return(res);
}

bool Rsp_CommonGetInfo_Entry::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_CommonGetInfo_Entry::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: list0 is the wrong size: expected 5, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: itemID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_CommonGetInfo_Entry: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_1->value;
	/*  this is an EntityRowObject  */
	delete invItem;
	invItem = list0->items[1];
	list0->items[1] = NULL;
	
	/*  this maps effectType to EntityEffectState  */
	if(!list0->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: activeEffects is not a dict: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	activeEffects.clear();
	PyRepDict *dict_2 = (PyRepDict *) list0->items[2];
	PyRepDict::iterator activeEffects_cur, activeEffects_end;
	activeEffects_cur = dict_2->items.begin();
	activeEffects_end = dict_2->items.end();
	int activeEffects_index;
	for(activeEffects_index = 0; activeEffects_cur != activeEffects_end; activeEffects_cur++, activeEffects_index++) {
		if(!activeEffects_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: Key %d in dict activeEffects is not an integer: %s", activeEffects_index, activeEffects_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) activeEffects_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Rsp_CommonGetInfo_Entry: truncating 64 bit into into 32 bit int in key of entry %d in field activeEffects", activeEffects_index);
		}
		activeEffects[k->value] = activeEffects_cur->second->Clone();
	}
	
	/*  maps attribute ID to it's value, which may be int or real  */
	if(!list0->items[3]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: attributes is not a dict: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	attributes.clear();
	PyRepDict *dict_3 = (PyRepDict *) list0->items[3];
	PyRepDict::iterator attributes_cur, attributes_end;
	attributes_cur = dict_3->items.begin();
	attributes_end = dict_3->items.end();
	int attributes_index;
	for(attributes_index = 0; attributes_cur != attributes_end; attributes_cur++, attributes_index++) {
		if(!attributes_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: Key %d in dict attributes is not an integer: %s", attributes_index, attributes_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) attributes_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Rsp_CommonGetInfo_Entry: truncating 64 bit into into 32 bit int in key of entry %d in field attributes", attributes_index);
		}
		attributes[k->value] = attributes_cur->second->Clone();
	}
	
	if(!list0->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo_Entry failed: time is not an int: %s", list0->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) list0->items[4];
	time = int64_4->value;

	delete packet;
	return(true);
}

Rsp_CommonGetInfo_Entry *Rsp_CommonGetInfo_Entry::Clone() const {
	Rsp_CommonGetInfo_Entry *res = new Rsp_CommonGetInfo_Entry;
	res->CloneFrom(this);
	return(res);
}

void Rsp_CommonGetInfo_Entry::CloneFrom(const Rsp_CommonGetInfo_Entry *from) {
	itemID = from->itemID;
	/*  this is an EntityRowObject  */
	delete invItem;
	if(from->invItem == NULL) {
		invItem = NULL;
	} else {
		invItem = from->invItem->Clone();
	}
	/*  this maps effectType to EntityEffectState  */
	std::map<uint32, PyRep *>::const_iterator activeEffects_cur, activeEffects_end;
	//free any existing elements first
	activeEffects_cur = activeEffects.begin();
	activeEffects_end = activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		delete activeEffects_cur->second;
	}
	activeEffects.clear();
	//now we can copy in the new ones...
	activeEffects_cur = from->activeEffects.begin();
	activeEffects_end = from->activeEffects.end();
	for(; activeEffects_cur != activeEffects_end; activeEffects_cur++) {
		activeEffects[activeEffects_cur->first] = activeEffects_cur->second->Clone();
	}
	
	/*  maps attribute ID to it's value, which may be int or real  */
	std::map<uint32, PyRep *>::const_iterator attributes_cur, attributes_end;
	//free any existing elements first
	attributes_cur = attributes.begin();
	attributes_end = attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		delete attributes_cur->second;
	}
	attributes.clear();
	//now we can copy in the new ones...
	attributes_cur = from->attributes.begin();
	attributes_end = from->attributes.end();
	for(; attributes_cur != attributes_end; attributes_cur++) {
		attributes[attributes_cur->first] = attributes_cur->second->Clone();
	}
	
	time = from->time;
	
}


Rsp_ItemGetInfo::Rsp_ItemGetInfo() {
	/* object of type util.Row */
	head_itemID = "itemID";
	head_invItem = "invItem";
	head_activeEffects = "activeEffects";
	head_attributes = "attributes";
	head_time = "time";
}

Rsp_ItemGetInfo::~Rsp_ItemGetInfo() {
}

void Rsp_ItemGetInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_ItemGetInfo", pfx);
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%shead_itemID='%s'", pfx, head_itemID.c_str());
	_log(l_type, "%shead_invItem='%s'", pfx, head_invItem.c_str());
	_log(l_type, "%shead_activeEffects='%s'", pfx, head_activeEffects.c_str());
	_log(l_type, "%shead_attributes='%s'", pfx, head_attributes.c_str());
	_log(l_type, "%shead_time='%s'", pfx, head_time.c_str());
	_log(l_type, "%sentry:", pfx);
	std::string entry_n(pfx);
	entry_n += "    ";
	entry.Dump(l_type, entry_n.c_str());
}

PyRepObject *Rsp_ItemGetInfo::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_invItem);
	list2->items[2] = new PyRepString(head_activeEffects);
	list2->items[3] = new PyRepString(head_attributes);
	list2->items[4] = new PyRepString(head_time);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
		dict1_1 = entry.Encode();
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

PyRepObject *Rsp_ItemGetInfo::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_invItem);
	list2->items[2] = new PyRepString(head_activeEffects);
	list2->items[3] = new PyRepString(head_attributes);
	list2->items[4] = new PyRepString(head_time);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
		dict1_1 = entry.FastEncode();
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

bool Rsp_ItemGetInfo::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_ItemGetInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: obj_0 is the wrong object type. Expected 'util.Row', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_entry = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: list2 is the wrong size: expected 5, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_itemID is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	head_itemID = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_invItem is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	head_invItem = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_activeEffects is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	head_activeEffects = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_attributes is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	head_attributes = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: head_time is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	head_time = string_7->value;
		} else
		if(key_string__->value == "line") {
			dict1_entry = true;
	PyRep *rep_8 = dict1_cur->second;
	dict1_cur->second = NULL;
	if(!entry.Decode(&rep_8)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: unable to decode element entry");
		delete packet;
		return(false);
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_entry) {
		_log(NET__PACKET_ERROR, "Decode Rsp_ItemGetInfo failed: Missing dict entry for 'entry' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_ItemGetInfo *Rsp_ItemGetInfo::Clone() const {
	Rsp_ItemGetInfo *res = new Rsp_ItemGetInfo;
	res->CloneFrom(this);
	return(res);
}

void Rsp_ItemGetInfo::CloneFrom(const Rsp_ItemGetInfo *from) {
	/* object of type util.Row */
	head_itemID = from->head_itemID;
	head_invItem = from->head_invItem;
	head_activeEffects = from->head_activeEffects;
	head_attributes = from->head_attributes;
	head_time = from->head_time;
	entry.CloneFrom(&from->entry);
	
}


Rsp_CommonGetInfo::Rsp_CommonGetInfo() {
	/* object of type util.IndexRowset */
	head_itemID = "itemID";
	head_invItem = "invItem";
	head_activeEffects = "activeEffects";
	head_attributes = "attributes";
	head_time = "time";
	rowclass = "util.Row";
	idName = "itemID";
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
}

Rsp_CommonGetInfo::~Rsp_CommonGetInfo() {
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	std::map<uint32, PyRep *>::iterator items_cur, items_end;
	//free any existing elements first
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		delete items_cur->second;
	}
	
}

void Rsp_CommonGetInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_CommonGetInfo", pfx);
	_log(l_type, "%sObject of type util.IndexRowset:", pfx);
	_log(l_type, "%shead_itemID='%s'", pfx, head_itemID.c_str());
	_log(l_type, "%shead_invItem='%s'", pfx, head_invItem.c_str());
	_log(l_type, "%shead_activeEffects='%s'", pfx, head_activeEffects.c_str());
	_log(l_type, "%shead_attributes='%s'", pfx, head_attributes.c_str());
	_log(l_type, "%shead_time='%s'", pfx, head_time.c_str());
	_log(l_type, "%srowclass='%s'", pfx, rowclass.c_str());
	_log(l_type, "%sidName='%s'", pfx, idName.c_str());
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	_log(l_type, "%sitems: Dictionaty with %d enetires", pfx, items.size());
	std::map<uint32, PyRep *>::const_iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, items_cur->first);
		std::string n(pfx);
		n += "        ";
		items_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepObject *Rsp_CommonGetInfo::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_invItem);
	list2->items[2] = new PyRepString(head_activeEffects);
	list2->items[3] = new PyRepString(head_attributes);
	list2->items[4] = new PyRepString(head_time);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepString(idName);
	dict1->items[
		new PyRepString("idName")
	] = dict1_2;
	PyRep *dict1_3;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	
	PyRepDict *dict3 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		dict3->items[
			new PyRepInteger(items_cur->first)
		] = items_cur->second->Clone();
	}
	dict1_3 = dict3;
	
	dict1->items[
		new PyRepString("items")
	] = dict1_3;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.IndexRowset",
			args0
		);
	

	return(res);
}

PyRepObject *Rsp_CommonGetInfo::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(5, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_invItem);
	list2->items[2] = new PyRepString(head_activeEffects);
	list2->items[3] = new PyRepString(head_attributes);
	list2->items[4] = new PyRepString(head_time);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepString(rowclass, true);
	dict1->items[
		new PyRepString("RowClass")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepString(idName);
	dict1->items[
		new PyRepString("idName")
	] = dict1_2;
	PyRep *dict1_3;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	
	PyRepDict *dict3 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator items_cur, items_end;
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		dict3->items[
			new PyRepInteger(items_cur->first)
		] = items_cur->second;
	}
	items.clear();
	dict1_3 = dict3;
	
	dict1->items[
		new PyRepString("items")
	] = dict1_3;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.IndexRowset",
			args0
		);
	

	return(res);
}

bool Rsp_CommonGetInfo::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_CommonGetInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.IndexRowset") {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: obj_0 is the wrong object type. Expected 'util.IndexRowset', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_rowclass = false;
	bool dict1_idName = false;
	bool dict1_items = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 5) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: list2 is the wrong size: expected 5, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_itemID is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	head_itemID = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_invItem is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	head_invItem = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_activeEffects is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	head_activeEffects = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_attributes is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	head_attributes = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: head_time is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	head_time = string_7->value;
		} else
		if(key_string__->value == "RowClass") {
			dict1_rowclass = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: rowclass is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) dict1_cur->second;
	rowclass = string_8->value;
	if(string_8->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo: String type mismatch on rowclass: expected %d got %d. Continuing anyhow.", true, string_8->is_type_1);
	}
		} else
		if(key_string__->value == "idName") {
			dict1_idName = true;
	if(!dict1_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: idName is not a string: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) dict1_cur->second;
	idName = string_9->value;
		} else
		if(key_string__->value == "items") {
			dict1_items = true;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	if(!dict1_cur->second->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: items is not a dict: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	items.clear();
	PyRepDict *dict_10 = (PyRepDict *) dict1_cur->second;
	PyRepDict::iterator items_cur, items_end;
	items_cur = dict_10->items.begin();
	items_end = dict_10->items.end();
	int items_index;
	for(items_index = 0; items_cur != items_end; items_cur++, items_index++) {
		if(!items_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Key %d in dict items is not an integer: %s", items_index, items_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) items_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Rsp_CommonGetInfo: truncating 64 bit into into 32 bit int in key of entry %d in field items", items_index);
		}
		items[k->value] = items_cur->second->Clone();
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_rowclass) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Missing dict entry for 'rowclass' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_idName) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Missing dict entry for 'idName' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_items) {
		_log(NET__PACKET_ERROR, "Decode Rsp_CommonGetInfo failed: Missing dict entry for 'items' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_CommonGetInfo *Rsp_CommonGetInfo::Clone() const {
	Rsp_CommonGetInfo *res = new Rsp_CommonGetInfo;
	res->CloneFrom(this);
	return(res);
}

void Rsp_CommonGetInfo::CloneFrom(const Rsp_CommonGetInfo *from) {
	/* object of type util.IndexRowset */
	head_itemID = from->head_itemID;
	head_invItem = from->head_invItem;
	head_activeEffects = from->head_activeEffects;
	head_attributes = from->head_attributes;
	head_time = from->head_time;
	rowclass = from->rowclass;
	idName = from->idName;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	std::map<uint32, PyRep *>::const_iterator items_cur, items_end;
	//free any existing elements first
	items_cur = items.begin();
	items_end = items.end();
	for(; items_cur != items_end; items_cur++) {
		delete items_cur->second;
	}
	items.clear();
	//now we can copy in the new ones...
	items_cur = from->items.begin();
	items_end = from->items.end();
	for(; items_cur != items_end; items_cur++) {
		items[items_cur->first] = items_cur->second->Clone();
	}
	
	
}


EntityRowObject::EntityRowObject() {
	/* object of type util.Row */
	head_itemID = "itemID";
	head_typeID = "typeID";
	head_ownerID = "ownerID";
	head_locationID = "locationID";
	head_flag = "flag";
	head_contraband = "contraband";
	head_singleton = "singleton";
	head_quantity = "quantity";
	head_groupID = "groupID";
	head_categoryID = "categoryID";
	head_customInfo = "customInfo";
	itemID = 0;
	typeID = 0;
	ownerID = 0;
	locationID = 0;
	flag = 0;
	contraband = 0;
	singleton = 0;
	quantity = 0;
	groupID = 0;
	categoryID = 0;
	customInfo = "";
}

EntityRowObject::~EntityRowObject() {
}

void EntityRowObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sEntityRowObject", pfx);
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%shead_itemID='%s'", pfx, head_itemID.c_str());
	_log(l_type, "%shead_typeID='%s'", pfx, head_typeID.c_str());
	_log(l_type, "%shead_ownerID='%s'", pfx, head_ownerID.c_str());
	_log(l_type, "%shead_locationID='%s'", pfx, head_locationID.c_str());
	_log(l_type, "%shead_flag='%s'", pfx, head_flag.c_str());
	_log(l_type, "%shead_contraband='%s'", pfx, head_contraband.c_str());
	_log(l_type, "%shead_singleton='%s'", pfx, head_singleton.c_str());
	_log(l_type, "%shead_quantity='%s'", pfx, head_quantity.c_str());
	_log(l_type, "%shead_groupID='%s'", pfx, head_groupID.c_str());
	_log(l_type, "%shead_categoryID='%s'", pfx, head_categoryID.c_str());
	_log(l_type, "%shead_customInfo='%s'", pfx, head_customInfo.c_str());
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%stypeID=%lu", pfx, typeID);
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	_log(l_type, "%slocationID=%lu", pfx, locationID);
	_log(l_type, "%sflag=%lu", pfx, flag);
	_log(l_type, "%scontraband=%lu", pfx, contraband);
	_log(l_type, "%ssingleton=%lu", pfx, singleton);
	_log(l_type, "%squantity=%lu", pfx, quantity);
	_log(l_type, "%sgroupID=%lu", pfx, groupID);
	_log(l_type, "%scategoryID=%lu", pfx, categoryID);
	_log(l_type, "%scustomInfo='%s'", pfx, customInfo.c_str());
}

PyRepObject *EntityRowObject::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(11, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_typeID);
	list2->items[2] = new PyRepString(head_ownerID);
	list2->items[3] = new PyRepString(head_locationID);
	list2->items[4] = new PyRepString(head_flag);
	list2->items[5] = new PyRepString(head_contraband);
	list2->items[6] = new PyRepString(head_singleton);
	list2->items[7] = new PyRepString(head_quantity);
	list2->items[8] = new PyRepString(head_groupID);
	list2->items[9] = new PyRepString(head_categoryID);
	list2->items[10] = new PyRepString(head_customInfo);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(11, NULL);
	list3->items[0] = new PyRepInteger(itemID);
	list3->items[1] = new PyRepInteger(typeID);
	list3->items[2] = new PyRepInteger(ownerID);
	list3->items[3] = new PyRepInteger(locationID);
	list3->items[4] = new PyRepInteger(flag);
	list3->items[5] = new PyRepInteger(contraband);
	list3->items[6] = new PyRepInteger(singleton);
	list3->items[7] = new PyRepInteger(quantity);
	list3->items[8] = new PyRepInteger(groupID);
	list3->items[9] = new PyRepInteger(categoryID);
	if(customInfo == "") {
		list3->items[10] = new PyRepNone();
	} else {
		list3->items[10] = new PyRepString(customInfo);
	}
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

PyRepObject *EntityRowObject::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(11, NULL);
	list2->items[0] = new PyRepString(head_itemID);
	list2->items[1] = new PyRepString(head_typeID);
	list2->items[2] = new PyRepString(head_ownerID);
	list2->items[3] = new PyRepString(head_locationID);
	list2->items[4] = new PyRepString(head_flag);
	list2->items[5] = new PyRepString(head_contraband);
	list2->items[6] = new PyRepString(head_singleton);
	list2->items[7] = new PyRepString(head_quantity);
	list2->items[8] = new PyRepString(head_groupID);
	list2->items[9] = new PyRepString(head_categoryID);
	list2->items[10] = new PyRepString(head_customInfo);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(11, NULL);
	list3->items[0] = new PyRepInteger(itemID);
	list3->items[1] = new PyRepInteger(typeID);
	list3->items[2] = new PyRepInteger(ownerID);
	list3->items[3] = new PyRepInteger(locationID);
	list3->items[4] = new PyRepInteger(flag);
	list3->items[5] = new PyRepInteger(contraband);
	list3->items[6] = new PyRepInteger(singleton);
	list3->items[7] = new PyRepInteger(quantity);
	list3->items[8] = new PyRepInteger(groupID);
	list3->items[9] = new PyRepInteger(categoryID);
	if(customInfo == "") {
		list3->items[10] = new PyRepNone();
	} else {
		list3->items[10] = new PyRepString(customInfo);
	}
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

bool EntityRowObject::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool EntityRowObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: obj_0 is the wrong object type. Expected 'util.Row', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_line = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 11) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: list2 is the wrong size: expected 11, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_itemID is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	head_itemID = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_typeID is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	head_typeID = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_ownerID is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	head_ownerID = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_locationID is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	head_locationID = string_6->value;
	if(!list2->items[4]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_flag is not a string: %s", list2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) list2->items[4];
	head_flag = string_7->value;
	if(!list2->items[5]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_contraband is not a string: %s", list2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_8 = (PyRepString *) list2->items[5];
	head_contraband = string_8->value;
	if(!list2->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_singleton is not a string: %s", list2->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) list2->items[6];
	head_singleton = string_9->value;
	if(!list2->items[7]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_quantity is not a string: %s", list2->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_10 = (PyRepString *) list2->items[7];
	head_quantity = string_10->value;
	if(!list2->items[8]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_groupID is not a string: %s", list2->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_11 = (PyRepString *) list2->items[8];
	head_groupID = string_11->value;
	if(!list2->items[9]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_categoryID is not a string: %s", list2->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_12 = (PyRepString *) list2->items[9];
	head_categoryID = string_12->value;
	if(!list2->items[10]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: head_customInfo is not a string: %s", list2->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_13 = (PyRepString *) list2->items[10];
	head_customInfo = string_13->value;
		} else
		if(key_string__->value == "line") {
			dict1_line = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: list14 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list14 = (PyRepList *) dict1_cur->second;
	if(list14->items.size() != 11) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: list14 is the wrong size: expected 11, but got %d", list14->items.size());
		delete packet;
		return(false);
	}

	if(!list14->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: itemID is not an int: %s", list14->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_15 = (PyRepInteger *) list14->items[0];
	if(int_15->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_15->value;
	if(!list14->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: typeID is not an int: %s", list14->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_16 = (PyRepInteger *) list14->items[1];
	if(int_16->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field typeID");
	}
	typeID = int_16->value;
	if(!list14->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: ownerID is not an int: %s", list14->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_17 = (PyRepInteger *) list14->items[2];
	if(int_17->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_17->value;
	if(!list14->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: locationID is not an int: %s", list14->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_18 = (PyRepInteger *) list14->items[3];
	if(int_18->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field locationID");
	}
	locationID = int_18->value;
	if(!list14->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: flag is not an int: %s", list14->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_19 = (PyRepInteger *) list14->items[4];
	if(int_19->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field flag");
	}
	flag = int_19->value;
	if(!list14->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: contraband is not an int: %s", list14->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_20 = (PyRepInteger *) list14->items[5];
	if(int_20->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field contraband");
	}
	contraband = int_20->value;
	if(!list14->items[6]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: singleton is not an int: %s", list14->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_21 = (PyRepInteger *) list14->items[6];
	if(int_21->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field singleton");
	}
	singleton = int_21->value;
	if(!list14->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: quantity is not an int: %s", list14->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_22 = (PyRepInteger *) list14->items[7];
	if(int_22->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field quantity");
	}
	quantity = int_22->value;
	if(!list14->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: groupID is not an int: %s", list14->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_23 = (PyRepInteger *) list14->items[8];
	if(int_23->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field groupID");
	}
	groupID = int_23->value;
	if(!list14->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: categoryID is not an int: %s", list14->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_24 = (PyRepInteger *) list14->items[9];
	if(int_24->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode EntityRowObject: truncating 64 bit into into 32 bit int for field categoryID");
	}
	categoryID = int_24->value;
	if(list14->items[10]->CheckType(PyRep::None)) {
		customInfo = "";
	} else {
	if(!list14->items[10]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: customInfo is not a string: %s", list14->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_25 = (PyRepString *) list14->items[10];
	customInfo = string_25->value;
	}
		} else
		{
			_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_line) {
		_log(NET__PACKET_ERROR, "Decode EntityRowObject failed: Missing dict entry for 'line' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

EntityRowObject *EntityRowObject::Clone() const {
	EntityRowObject *res = new EntityRowObject;
	res->CloneFrom(this);
	return(res);
}

void EntityRowObject::CloneFrom(const EntityRowObject *from) {
	/* object of type util.Row */
	head_itemID = from->head_itemID;
	head_typeID = from->head_typeID;
	head_ownerID = from->head_ownerID;
	head_locationID = from->head_locationID;
	head_flag = from->head_flag;
	head_contraband = from->head_contraband;
	head_singleton = from->head_singleton;
	head_quantity = from->head_quantity;
	head_groupID = from->head_groupID;
	head_categoryID = from->head_categoryID;
	head_customInfo = from->head_customInfo;
	itemID = from->itemID;
	typeID = from->typeID;
	ownerID = from->ownerID;
	locationID = from->locationID;
	flag = from->flag;
	contraband = from->contraband;
	singleton = from->singleton;
	quantity = from->quantity;
	groupID = from->groupID;
	categoryID = from->categoryID;
	customInfo = from->customInfo;
	
}


Call_GetOptionsForItemTypes::Call_GetOptionsForItemTypes() {
}

Call_GetOptionsForItemTypes::~Call_GetOptionsForItemTypes() {
	std::map<uint32, PyRep *>::iterator typeIDs_cur, typeIDs_end;
	//free any existing elements first
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		delete typeIDs_cur->second;
	}
	
}

void Call_GetOptionsForItemTypes::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_GetOptionsForItemTypes", pfx);
	_log(l_type, "%stypeIDs: Dictionaty with %d enetires", pfx, typeIDs.size());
	std::map<uint32, PyRep *>::const_iterator typeIDs_cur, typeIDs_end;
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, typeIDs_cur->first);
		std::string n(pfx);
		n += "        ";
		typeIDs_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *Call_GetOptionsForItemTypes::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator typeIDs_cur, typeIDs_end;
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		dict1->items[
			new PyRepInteger(typeIDs_cur->first)
		] = typeIDs_cur->second->Clone();
	}
	tuple0->items[0] = dict1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_GetOptionsForItemTypes::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepDict *dict1 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator typeIDs_cur, typeIDs_end;
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		dict1->items[
			new PyRepInteger(typeIDs_cur->first)
		] = typeIDs_cur->second;
	}
	typeIDs.clear();
	tuple0->items[0] = dict1;
	
	res = tuple0;
	

	return(res);
}

bool Call_GetOptionsForItemTypes::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_GetOptionsForItemTypes::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes failed: typeIDs is not a dict: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	typeIDs.clear();
	PyRepDict *dict_1 = (PyRepDict *) tuple0->items[0];
	PyRepDict::iterator typeIDs_cur, typeIDs_end;
	typeIDs_cur = dict_1->items.begin();
	typeIDs_end = dict_1->items.end();
	int typeIDs_index;
	for(typeIDs_index = 0; typeIDs_cur != typeIDs_end; typeIDs_cur++, typeIDs_index++) {
		if(!typeIDs_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_GetOptionsForItemTypes failed: Key %d in dict typeIDs is not an integer: %s", typeIDs_index, typeIDs_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) typeIDs_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_GetOptionsForItemTypes: truncating 64 bit into into 32 bit int in key of entry %d in field typeIDs", typeIDs_index);
		}
		typeIDs[k->value] = typeIDs_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

Call_GetOptionsForItemTypes *Call_GetOptionsForItemTypes::Clone() const {
	Call_GetOptionsForItemTypes *res = new Call_GetOptionsForItemTypes;
	res->CloneFrom(this);
	return(res);
}

void Call_GetOptionsForItemTypes::CloneFrom(const Call_GetOptionsForItemTypes *from) {
	std::map<uint32, PyRep *>::const_iterator typeIDs_cur, typeIDs_end;
	//free any existing elements first
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		delete typeIDs_cur->second;
	}
	typeIDs.clear();
	//now we can copy in the new ones...
	typeIDs_cur = from->typeIDs.begin();
	typeIDs_end = from->typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		typeIDs[typeIDs_cur->first] = typeIDs_cur->second->Clone();
	}
	
	
}


Rsp_GetOptionsForItemTypes::Rsp_GetOptionsForItemTypes() {
}

Rsp_GetOptionsForItemTypes::~Rsp_GetOptionsForItemTypes() {
	std::map<uint32, PyRep *>::iterator typeIDs_cur, typeIDs_end;
	//free any existing elements first
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		delete typeIDs_cur->second;
	}
	
}

void Rsp_GetOptionsForItemTypes::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetOptionsForItemTypes", pfx);
	_log(l_type, "%stypeIDs: Dictionaty with %d enetires", pfx, typeIDs.size());
	std::map<uint32, PyRep *>::const_iterator typeIDs_cur, typeIDs_end;
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, typeIDs_cur->first);
		std::string n(pfx);
		n += "        ";
		typeIDs_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepDict *Rsp_GetOptionsForItemTypes::Encode() {
	PyRepDict *res = NULL;
	
	PyRepDict *dict0 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator typeIDs_cur, typeIDs_end;
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		dict0->items[
			new PyRepInteger(typeIDs_cur->first)
		] = typeIDs_cur->second->Clone();
	}
	res = dict0;
	

	return(res);
}

PyRepDict *Rsp_GetOptionsForItemTypes::FastEncode() {
	PyRepDict *res = NULL;
	
	PyRepDict *dict0 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator typeIDs_cur, typeIDs_end;
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		dict0->items[
			new PyRepInteger(typeIDs_cur->first)
		] = typeIDs_cur->second;
	}
	typeIDs.clear();
	res = dict0;
	

	return(res);
}

bool Rsp_GetOptionsForItemTypes::Decode(PyRepDict **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetOptionsForItemTypes::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes failed: typeIDs is not a dict: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	typeIDs.clear();
	PyRepDict *dict_0 = (PyRepDict *) packet;
	PyRepDict::iterator typeIDs_cur, typeIDs_end;
	typeIDs_cur = dict_0->items.begin();
	typeIDs_end = dict_0->items.end();
	int typeIDs_index;
	for(typeIDs_index = 0; typeIDs_cur != typeIDs_end; typeIDs_cur++, typeIDs_index++) {
		if(!typeIDs_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes failed: Key %d in dict typeIDs is not an integer: %s", typeIDs_index, typeIDs_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) typeIDs_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Rsp_GetOptionsForItemTypes: truncating 64 bit into into 32 bit int in key of entry %d in field typeIDs", typeIDs_index);
		}
		typeIDs[k->value] = typeIDs_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

Rsp_GetOptionsForItemTypes *Rsp_GetOptionsForItemTypes::Clone() const {
	Rsp_GetOptionsForItemTypes *res = new Rsp_GetOptionsForItemTypes;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetOptionsForItemTypes::CloneFrom(const Rsp_GetOptionsForItemTypes *from) {
	std::map<uint32, PyRep *>::const_iterator typeIDs_cur, typeIDs_end;
	//free any existing elements first
	typeIDs_cur = typeIDs.begin();
	typeIDs_end = typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		delete typeIDs_cur->second;
	}
	typeIDs.clear();
	//now we can copy in the new ones...
	typeIDs_cur = from->typeIDs.begin();
	typeIDs_end = from->typeIDs.end();
	for(; typeIDs_cur != typeIDs_end; typeIDs_cur++) {
		typeIDs[typeIDs_cur->first] = typeIDs_cur->second->Clone();
	}
	
	
}


Rsp_GetOptionsForItemTypes_Arg::Rsp_GetOptionsForItemTypes_Arg() {
	/* object of type util.KeyVal */
	isRecyclable = false;
	isRefinable = false;
}

Rsp_GetOptionsForItemTypes_Arg::~Rsp_GetOptionsForItemTypes_Arg() {
}

void Rsp_GetOptionsForItemTypes_Arg::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetOptionsForItemTypes_Arg", pfx);
	_log(l_type, "%sObject of type util.KeyVal:", pfx);
	_log(l_type, "%sisRecyclable=%s", pfx, isRecyclable?"true":"false");
	_log(l_type, "%sisRefinable=%s", pfx, isRefinable?"true":"false");
}

PyRepObject *Rsp_GetOptionsForItemTypes_Arg::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepBoolean(isRecyclable);
	dict1->items[
		new PyRepString("isRecyclable")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepBoolean(isRefinable);
	dict1->items[
		new PyRepString("isRefinable")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.KeyVal",
			args0
		);
	

	return(res);
}

PyRepObject *Rsp_GetOptionsForItemTypes_Arg::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepBoolean(isRecyclable);
	dict1->items[
		new PyRepString("isRecyclable")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepBoolean(isRefinable);
	dict1->items[
		new PyRepString("isRefinable")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.KeyVal",
			args0
		);
	

	return(res);
}

bool Rsp_GetOptionsForItemTypes_Arg::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetOptionsForItemTypes_Arg::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes_Arg failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.KeyVal") {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes_Arg failed: obj_0 is the wrong object type. Expected 'util.KeyVal', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes_Arg failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_isRecyclable = false;
	bool dict1_isRefinable = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes_Arg failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "isRecyclable") {
			dict1_isRecyclable = true;
	if(!dict1_cur->second->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes_Arg failed: isRecyclable is not a boolean: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_2 = (PyRepBoolean *) dict1_cur->second;
	isRecyclable = bool_2->value;
		} else
		if(key_string__->value == "isRefinable") {
			dict1_isRefinable = true;
	if(!dict1_cur->second->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes_Arg failed: isRefinable is not a boolean: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_3 = (PyRepBoolean *) dict1_cur->second;
	isRefinable = bool_3->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes_Arg failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_isRecyclable) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes_Arg failed: Missing dict entry for 'isRecyclable' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_isRefinable) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetOptionsForItemTypes_Arg failed: Missing dict entry for 'isRefinable' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_GetOptionsForItemTypes_Arg *Rsp_GetOptionsForItemTypes_Arg::Clone() const {
	Rsp_GetOptionsForItemTypes_Arg *res = new Rsp_GetOptionsForItemTypes_Arg;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetOptionsForItemTypes_Arg::CloneFrom(const Rsp_GetOptionsForItemTypes_Arg *from) {
	/* object of type util.KeyVal */
	isRecyclable = from->isRecyclable;
	isRefinable = from->isRefinable;
	
}


Rsp_GetReprocessingInfo::Rsp_GetReprocessingInfo() {
	tax = 0.0;
	reputation = 0.0;
	yield = 0.0;
	combinedyield = 0.0;
}

Rsp_GetReprocessingInfo::~Rsp_GetReprocessingInfo() {
}

void Rsp_GetReprocessingInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetReprocessingInfo", pfx);
	_log(l_type, "%stax=%.13f", pfx, tax);
	_log(l_type, "%sreputation=%.13f", pfx, reputation);
	_log(l_type, "%syield=%.13f", pfx, yield);
	_log(l_type, "%scombinedyield=%.13f", pfx, combinedyield);
}

PyRepDict *Rsp_GetReprocessingInfo::Encode() {
	PyRepDict *res = NULL;
	PyRepDict *dict0 = new PyRepDict();
	PyRep *dict0_0;
	PyRepList *list1 = new PyRepList();
	list1->items.resize(2, NULL);
	list1->items[0] = new PyRepReal(tax);
	list1->items[1] = new PyRepReal(reputation);
	dict0_0 = list1;
	
	dict0->items[
		new PyRepString("wetake")
	] = dict0_0;
	PyRep *dict0_1;
	dict0_1 = new PyRepReal(yield);
	dict0->items[
		new PyRepString("yield")
	] = dict0_1;
	PyRep *dict0_2;
	dict0_2 = new PyRepReal(combinedyield);
	dict0->items[
		new PyRepString("combinedyield")
	] = dict0_2;
	res = dict0;
	

	return(res);
}

PyRepDict *Rsp_GetReprocessingInfo::FastEncode() {
	PyRepDict *res = NULL;
	PyRepDict *dict0 = new PyRepDict();
	PyRep *dict0_0;
	PyRepList *list1 = new PyRepList();
	list1->items.resize(2, NULL);
	list1->items[0] = new PyRepReal(tax);
	list1->items[1] = new PyRepReal(reputation);
	dict0_0 = list1;
	
	dict0->items[
		new PyRepString("wetake")
	] = dict0_0;
	PyRep *dict0_1;
	dict0_1 = new PyRepReal(yield);
	dict0->items[
		new PyRepString("yield")
	] = dict0_1;
	PyRep *dict0_2;
	dict0_2 = new PyRepReal(combinedyield);
	dict0->items[
		new PyRepString("combinedyield")
	] = dict0_2;
	res = dict0;
	

	return(res);
}

bool Rsp_GetReprocessingInfo::Decode(PyRepDict **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetReprocessingInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: dict0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	bool dict0_wetake = false;
	bool dict0_yield = false;
	bool dict0_combinedyield = false;
	PyRepDict *dict0 = (PyRepDict *) packet;
	
	PyRepDict::iterator dict0_cur, dict0_end;
	dict0_cur = dict0->items.begin();
	dict0_end = dict0->items.end();
	for(; dict0_cur != dict0_end; dict0_cur++) {
		PyRep *key__ = dict0_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: a key in dict0 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "wetake") {
			dict0_wetake = true;
	if(!dict0_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: list1 is not a list: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list1 = (PyRepList *) dict0_cur->second;
	if(list1->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: list1 is the wrong size: expected 2, but got %d", list1->items.size());
		delete packet;
		return(false);
	}

	if(!list1->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: tax is not a real: %s", list1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_2 = (PyRepReal *) list1->items[0];
	tax = real_2->value;
	if(!list1->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: reputation is not a real: %s", list1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_3 = (PyRepReal *) list1->items[1];
	reputation = real_3->value;
		} else
		if(key_string__->value == "yield") {
			dict0_yield = true;
	if(!dict0_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: yield is not a real: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) dict0_cur->second;
	yield = real_4->value;
		} else
		if(key_string__->value == "combinedyield") {
			dict0_combinedyield = true;
	if(!dict0_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: combinedyield is not a real: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) dict0_cur->second;
	combinedyield = real_5->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: Unknown key string '%s' in dict0", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict0_wetake) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: Missing dict entry for 'wetake' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_yield) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: Missing dict entry for 'yield' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_combinedyield) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetReprocessingInfo failed: Missing dict entry for 'combinedyield' in dict0");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_GetReprocessingInfo *Rsp_GetReprocessingInfo::Clone() const {
	Rsp_GetReprocessingInfo *res = new Rsp_GetReprocessingInfo;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetReprocessingInfo::CloneFrom(const Rsp_GetReprocessingInfo *from) {
	tax = from->tax;
	reputation = from->reputation;
	yield = from->yield;
	combinedyield = from->combinedyield;
	
}

	/*  this is ugly, but we dont really have a better way to deal with it right now.  */
	/*  Don't change headerX !  */

Rsp_GetQuote::Rsp_GetQuote() {
	/* object of type util.Row */
	header1 = "quantityToProcess";
	header2 = "leftOvers";
	header3 = "playerStanding";
	header4 = "recoverables";
	quantityToProcess = 0;
	leftOvers = 0;
	playerStanding = 0.0;
	/* object of type util.Rowset */
	header5 = "typeID";
	header6 = "unrecoverable";
	header7 = "station";
	header8 = "client";
	RowClass = "util.Row";
}

Rsp_GetQuote::~Rsp_GetQuote() {
}

void Rsp_GetQuote::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetQuote", pfx);
	_log(l_type, "%sObject of type util.Row:", pfx);
	_log(l_type, "%sheader1='%s'", pfx, header1.c_str());
	_log(l_type, "%sheader2='%s'", pfx, header2.c_str());
	_log(l_type, "%sheader3='%s'", pfx, header3.c_str());
	_log(l_type, "%sheader4='%s'", pfx, header4.c_str());
	_log(l_type, "%squantityToProcess=%lu", pfx, quantityToProcess);
	_log(l_type, "%sleftOvers=%lu", pfx, leftOvers);
	_log(l_type, "%splayerStanding=%.13f", pfx, playerStanding);
	_log(l_type, "%sObject of type util.Rowset:", pfx);
	_log(l_type, "%sheader5='%s'", pfx, header5.c_str());
	_log(l_type, "%sheader6='%s'", pfx, header6.c_str());
	_log(l_type, "%sheader7='%s'", pfx, header7.c_str());
	_log(l_type, "%sheader8='%s'", pfx, header8.c_str());
	_log(l_type, "%sRowClass='%s'", pfx, RowClass.c_str());
	_log(l_type, "%slines: ", pfx);
	std::string lines_n(pfx);
	lines_n += "    ";
	lines.Dump(l_type, lines_n.c_str());
}

PyRepObject *Rsp_GetQuote::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(4, NULL);
	list2->items[0] = new PyRepString(header1);
	list2->items[1] = new PyRepString(header2);
	list2->items[2] = new PyRepString(header3);
	list2->items[3] = new PyRepString(header4);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(4, NULL);
	list3->items[0] = new PyRepInteger(quantityToProcess);
	list3->items[1] = new PyRepInteger(leftOvers);
	list3->items[2] = new PyRepReal(playerStanding);
	PyRep *args4;
	PyRepDict *dict5 = new PyRepDict();
	PyRep *dict5_0;
	PyRepList *list6 = new PyRepList();
	list6->items.resize(4, NULL);
	list6->items[0] = new PyRepString(header5);
	list6->items[1] = new PyRepString(header6);
	list6->items[2] = new PyRepString(header7);
	list6->items[3] = new PyRepString(header8);
	dict5_0 = list6;
	
	dict5->items[
		new PyRepString("header")
	] = dict5_0;
	PyRep *dict5_1;
	dict5_1 = new PyRepString(RowClass, true);
	dict5->items[
		new PyRepString("RowClass")
	] = dict5_1;
	PyRep *dict5_2;
	dict5_2 = lines.Clone();
	dict5->items[
		new PyRepString("lines")
	] = dict5_2;
	args4 = dict5;
	
	list3->items[3] = new PyRepObject(
			"util.Rowset",
			args4
		);
	
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

PyRepObject *Rsp_GetQuote::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepList *list2 = new PyRepList();
	list2->items.resize(4, NULL);
	list2->items[0] = new PyRepString(header1);
	list2->items[1] = new PyRepString(header2);
	list2->items[2] = new PyRepString(header3);
	list2->items[3] = new PyRepString(header4);
	dict1_0 = list2;
	
	dict1->items[
		new PyRepString("header")
	] = dict1_0;
	PyRep *dict1_1;
	PyRepList *list3 = new PyRepList();
	list3->items.resize(4, NULL);
	list3->items[0] = new PyRepInteger(quantityToProcess);
	list3->items[1] = new PyRepInteger(leftOvers);
	list3->items[2] = new PyRepReal(playerStanding);
	PyRep *args4;
	PyRepDict *dict5 = new PyRepDict();
	PyRep *dict5_0;
	PyRepList *list6 = new PyRepList();
	list6->items.resize(4, NULL);
	list6->items[0] = new PyRepString(header5);
	list6->items[1] = new PyRepString(header6);
	list6->items[2] = new PyRepString(header7);
	list6->items[3] = new PyRepString(header8);
	dict5_0 = list6;
	
	dict5->items[
		new PyRepString("header")
	] = dict5_0;
	PyRep *dict5_1;
	dict5_1 = new PyRepString(RowClass, true);
	dict5->items[
		new PyRepString("RowClass")
	] = dict5_1;
	PyRep *dict5_2;
	
	PyRepList *list7 = new PyRepList();
	list7->items = lines.items;
	lines.items.clear();
	dict5_2 = list7;
	dict5->items[
		new PyRepString("lines")
	] = dict5_2;
	args4 = dict5;
	
	list3->items[3] = new PyRepObject(
			"util.Rowset",
			args4
		);
	
	dict1_1 = list3;
	
	dict1->items[
		new PyRepString("line")
	] = dict1_1;
	args0 = dict1;
	
	res = new PyRepObject(
			"util.Row",
			args0
		);
	

	return(res);
}

bool Rsp_GetQuote::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetQuote::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.Row") {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: obj_0 is the wrong object type. Expected 'util.Row', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_header = false;
	bool dict1_line = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict1_header = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: list2 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list2 = (PyRepList *) dict1_cur->second;
	if(list2->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: list2 is the wrong size: expected 4, but got %d", list2->items.size());
		delete packet;
		return(false);
	}

	if(!list2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header1 is not a string: %s", list2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) list2->items[0];
	header1 = string_3->value;
	if(!list2->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header2 is not a string: %s", list2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) list2->items[1];
	header2 = string_4->value;
	if(!list2->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header3 is not a string: %s", list2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) list2->items[2];
	header3 = string_5->value;
	if(!list2->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header4 is not a string: %s", list2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) list2->items[3];
	header4 = string_6->value;
		} else
		if(key_string__->value == "line") {
			dict1_line = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: list7 is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list7 = (PyRepList *) dict1_cur->second;
	if(list7->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: list7 is the wrong size: expected 4, but got %d", list7->items.size());
		delete packet;
		return(false);
	}

	if(!list7->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: quantityToProcess is not an int: %s", list7->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) list7->items[0];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote: truncating 64 bit into into 32 bit int for field quantityToProcess");
	}
	quantityToProcess = int_8->value;
	if(!list7->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: leftOvers is not an int: %s", list7->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) list7->items[1];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote: truncating 64 bit into into 32 bit int for field leftOvers");
	}
	leftOvers = int_9->value;
	if(!list7->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: playerStanding is not a real: %s", list7->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_10 = (PyRepReal *) list7->items[2];
	playerStanding = real_10->value;
	if(!list7->items[3]->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: obj_11 is the wrong type: %s", list7->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_11 = (PyRepObject *) list7->items[3];
	
	if(obj_11->type != "util.Rowset") {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: obj_11 is the wrong object type. Expected 'util.Rowset', got '%s'", obj_11->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_11->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: dict12 is the wrong type: %s", obj_11->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict12_header = false;
	bool dict12_RowClass = false;
	bool dict12_lines = false;
	PyRepDict *dict12 = (PyRepDict *) obj_11->arguments;
	
	PyRepDict::iterator dict12_cur, dict12_end;
	dict12_cur = dict12->items.begin();
	dict12_end = dict12->items.end();
	for(; dict12_cur != dict12_end; dict12_cur++) {
		PyRep *key__ = dict12_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: a key in dict12 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "header") {
			dict12_header = true;
	if(!dict12_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: list13 is not a list: %s", dict12_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list13 = (PyRepList *) dict12_cur->second;
	if(list13->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: list13 is the wrong size: expected 4, but got %d", list13->items.size());
		delete packet;
		return(false);
	}

	if(!list13->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header5 is not a string: %s", list13->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_14 = (PyRepString *) list13->items[0];
	header5 = string_14->value;
	if(!list13->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header6 is not a string: %s", list13->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_15 = (PyRepString *) list13->items[1];
	header6 = string_15->value;
	if(!list13->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header7 is not a string: %s", list13->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_16 = (PyRepString *) list13->items[2];
	header7 = string_16->value;
	if(!list13->items[3]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: header8 is not a string: %s", list13->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_17 = (PyRepString *) list13->items[3];
	header8 = string_17->value;
		} else
		if(key_string__->value == "RowClass") {
			dict12_RowClass = true;
	if(!dict12_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: RowClass is not a string: %s", dict12_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_18 = (PyRepString *) dict12_cur->second;
	RowClass = string_18->value;
	if(string_18->is_type_1 != true) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote: String type mismatch on RowClass: expected %d got %d. Continuing anyhow.", true, string_18->is_type_1);
	}
		} else
		if(key_string__->value == "lines") {
			dict12_lines = true;
	if(!dict12_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: lines is not a list: %s", dict12_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_lines = (PyRepList *) dict12_cur->second;	lines.items = list_lines->items;
	list_lines->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Unknown key string '%s' in dict12", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict12_header) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'header' in dict12");
		delete packet;
		return(false);
	}
	
	if(!dict12_RowClass) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'RowClass' in dict12");
		delete packet;
		return(false);
	}
	
	if(!dict12_lines) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'lines' in dict12");
		delete packet;
		return(false);
	}
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_header) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'header' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_line) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote failed: Missing dict entry for 'line' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_GetQuote *Rsp_GetQuote::Clone() const {
	Rsp_GetQuote *res = new Rsp_GetQuote;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetQuote::CloneFrom(const Rsp_GetQuote *from) {
	/* object of type util.Row */
	header1 = from->header1;
	header2 = from->header2;
	header3 = from->header3;
	header4 = from->header4;
	quantityToProcess = from->quantityToProcess;
	leftOvers = from->leftOvers;
	playerStanding = from->playerStanding;
	/* object of type util.Rowset */
	header5 = from->header5;
	header6 = from->header6;
	header7 = from->header7;
	header8 = from->header8;
	RowClass = from->RowClass;
	lines.CloneFrom(&from->lines);
	
}


Rsp_GetQuotes::Rsp_GetQuotes() {
}

Rsp_GetQuotes::~Rsp_GetQuotes() {
	std::map<uint32, PyRep *>::iterator quotes_cur, quotes_end;
	//free any existing elements first
	quotes_cur = quotes.begin();
	quotes_end = quotes.end();
	for(; quotes_cur != quotes_end; quotes_cur++) {
		delete quotes_cur->second;
	}
	
}

void Rsp_GetQuotes::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetQuotes", pfx);
	_log(l_type, "%squotes: Dictionaty with %d enetires", pfx, quotes.size());
	std::map<uint32, PyRep *>::const_iterator quotes_cur, quotes_end;
	quotes_cur = quotes.begin();
	quotes_end = quotes.end();
	for(; quotes_cur != quotes_end; quotes_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, quotes_cur->first);
		std::string n(pfx);
		n += "        ";
		quotes_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepDict *Rsp_GetQuotes::Encode() {
	PyRepDict *res = NULL;
	
	PyRepDict *dict0 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator quotes_cur, quotes_end;
	quotes_cur = quotes.begin();
	quotes_end = quotes.end();
	for(; quotes_cur != quotes_end; quotes_cur++) {
		dict0->items[
			new PyRepInteger(quotes_cur->first)
		] = quotes_cur->second->Clone();
	}
	res = dict0;
	

	return(res);
}

PyRepDict *Rsp_GetQuotes::FastEncode() {
	PyRepDict *res = NULL;
	
	PyRepDict *dict0 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator quotes_cur, quotes_end;
	quotes_cur = quotes.begin();
	quotes_end = quotes.end();
	for(; quotes_cur != quotes_end; quotes_cur++) {
		dict0->items[
			new PyRepInteger(quotes_cur->first)
		] = quotes_cur->second;
	}
	quotes.clear();
	res = dict0;
	

	return(res);
}

bool Rsp_GetQuotes::Decode(PyRepDict **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetQuotes::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuotes failed: quotes is not a dict: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	quotes.clear();
	PyRepDict *dict_0 = (PyRepDict *) packet;
	PyRepDict::iterator quotes_cur, quotes_end;
	quotes_cur = dict_0->items.begin();
	quotes_end = dict_0->items.end();
	int quotes_index;
	for(quotes_index = 0; quotes_cur != quotes_end; quotes_cur++, quotes_index++) {
		if(!quotes_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetQuotes failed: Key %d in dict quotes is not an integer: %s", quotes_index, quotes_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) quotes_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Rsp_GetQuotes: truncating 64 bit into into 32 bit int in key of entry %d in field quotes", quotes_index);
		}
		quotes[k->value] = quotes_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

Rsp_GetQuotes *Rsp_GetQuotes::Clone() const {
	Rsp_GetQuotes *res = new Rsp_GetQuotes;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetQuotes::CloneFrom(const Rsp_GetQuotes *from) {
	std::map<uint32, PyRep *>::const_iterator quotes_cur, quotes_end;
	//free any existing elements first
	quotes_cur = quotes.begin();
	quotes_end = quotes.end();
	for(; quotes_cur != quotes_end; quotes_cur++) {
		delete quotes_cur->second;
	}
	quotes.clear();
	//now we can copy in the new ones...
	quotes_cur = from->quotes.begin();
	quotes_end = from->quotes.end();
	for(; quotes_cur != quotes_end; quotes_cur++) {
		quotes[quotes_cur->first] = quotes_cur->second->Clone();
	}
	
	
}


Rsp_GetQuote_Recoverables_Line::Rsp_GetQuote_Recoverables_Line() {
	typeID = 0;
	unrecoverable = 0;
	station = 0;
	client = 0;
}

Rsp_GetQuote_Recoverables_Line::~Rsp_GetQuote_Recoverables_Line() {
}

void Rsp_GetQuote_Recoverables_Line::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetQuote_Recoverables_Line", pfx);
	_log(l_type, "%stypeID=%lu", pfx, typeID);
	_log(l_type, "%sunrecoverable=%lu", pfx, unrecoverable);
	_log(l_type, "%sstation=%lu", pfx, station);
	_log(l_type, "%sclient=%lu", pfx, client);
}

PyRepList *Rsp_GetQuote_Recoverables_Line::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(4, NULL);
	list0->items[0] = new PyRepInteger(typeID);
	list0->items[1] = new PyRepInteger(unrecoverable);
	list0->items[2] = new PyRepInteger(station);
	list0->items[3] = new PyRepInteger(client);
	res = list0;
	

	return(res);
}

PyRepList *Rsp_GetQuote_Recoverables_Line::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(4, NULL);
	list0->items[0] = new PyRepInteger(typeID);
	list0->items[1] = new PyRepInteger(unrecoverable);
	list0->items[2] = new PyRepInteger(station);
	list0->items[3] = new PyRepInteger(client);
	res = list0;
	

	return(res);
}

bool Rsp_GetQuote_Recoverables_Line::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetQuote_Recoverables_Line::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Recoverables_Line failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Recoverables_Line failed: list0 is the wrong size: expected 4, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Recoverables_Line failed: typeID is not an int: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) list0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote_Recoverables_Line: truncating 64 bit into into 32 bit int for field typeID");
	}
	typeID = int_1->value;
	if(!list0->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Recoverables_Line failed: unrecoverable is not an int: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) list0->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote_Recoverables_Line: truncating 64 bit into into 32 bit int for field unrecoverable");
	}
	unrecoverable = int_2->value;
	if(!list0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Recoverables_Line failed: station is not an int: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) list0->items[2];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote_Recoverables_Line: truncating 64 bit into into 32 bit int for field station");
	}
	station = int_3->value;
	if(!list0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetQuote_Recoverables_Line failed: client is not an int: %s", list0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) list0->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetQuote_Recoverables_Line: truncating 64 bit into into 32 bit int for field client");
	}
	client = int_4->value;

	delete packet;
	return(true);
}

Rsp_GetQuote_Recoverables_Line *Rsp_GetQuote_Recoverables_Line::Clone() const {
	Rsp_GetQuote_Recoverables_Line *res = new Rsp_GetQuote_Recoverables_Line;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetQuote_Recoverables_Line::CloneFrom(const Rsp_GetQuote_Recoverables_Line *from) {
	typeID = from->typeID;
	unrecoverable = from->unrecoverable;
	station = from->station;
	client = from->client;
	
}


Call_Reprocess::Call_Reprocess() {
}

Call_Reprocess::~Call_Reprocess() {
}

void Call_Reprocess::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_Reprocess", pfx);
	_log(l_type, "%sitemIDs: Integer list with %d enetires", pfx, itemIDs.size());
	std::vector<uint32>::const_iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, itemIDs_index, *itemIDs_cur);
	}
	
}

PyRepTuple *Call_Reprocess::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_Reprocess::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool Call_Reprocess::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_Reprocess::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_Reprocess failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_Reprocess failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_Reprocess failed: itemIDs is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	itemIDs.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = list_1->items.begin();
	itemIDs_end = list_1->items.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		if(!(*itemIDs_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_Reprocess failed: Element %d in list itemIDs is not an integer: %s", itemIDs_index, (*itemIDs_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*itemIDs_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_Reprocess: truncating 64 bit into into 32 bit int for item %d in field itemIDs", itemIDs_index);
		}
		itemIDs.push_back(t->value);
	}


	delete packet;
	return(true);
}

Call_Reprocess *Call_Reprocess::Clone() const {
	Call_Reprocess *res = new Call_Reprocess;
	res->CloneFrom(this);
	return(res);
}

void Call_Reprocess::CloneFrom(const Call_Reprocess *from) {
	itemIDs = from->itemIDs;
	
}


Call_GetQuotes::Call_GetQuotes() {
}

Call_GetQuotes::~Call_GetQuotes() {
}

void Call_GetQuotes::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_GetQuotes", pfx);
	_log(l_type, "%sitemIDs: Integer list with %d enetires", pfx, itemIDs.size());
	std::vector<uint32>::const_iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, itemIDs_index, *itemIDs_cur);
	}
	
}

PyRepTuple *Call_GetQuotes::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_GetQuotes::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	
	PyRepList *list1 = new PyRepList();
	std::vector<uint32>::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = itemIDs.begin();
	itemIDs_end = itemIDs.end();
	for(; itemIDs_cur != itemIDs_end; itemIDs_cur++) {
		list1->items.push_back(
			new PyRepInteger(*itemIDs_cur)
		);
	}
	tuple0->items[0] = list1;
	
	res = tuple0;
	

	return(res);
}

bool Call_GetQuotes::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_GetQuotes::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetQuotes failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Call_GetQuotes failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetQuotes failed: itemIDs is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	itemIDs.clear();
	PyRepList *list_1 = (PyRepList *) tuple0->items[0];
	PyRepList::iterator itemIDs_cur, itemIDs_end;
	itemIDs_cur = list_1->items.begin();
	itemIDs_end = list_1->items.end();
	int itemIDs_index;
	for(itemIDs_index = 0; itemIDs_cur != itemIDs_end; itemIDs_cur++, itemIDs_index++) {
		if(!(*itemIDs_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode Call_GetQuotes failed: Element %d in list itemIDs is not an integer: %s", itemIDs_index, (*itemIDs_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*itemIDs_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode Call_GetQuotes: truncating 64 bit into into 32 bit int for item %d in field itemIDs", itemIDs_index);
		}
		itemIDs.push_back(t->value);
	}


	delete packet;
	return(true);
}

Call_GetQuotes *Call_GetQuotes::Clone() const {
	Call_GetQuotes *res = new Call_GetQuotes;
	res->CloneFrom(this);
	return(res);
}

void Call_GetQuotes::CloneFrom(const Call_GetQuotes *from) {
	itemIDs = from->itemIDs;
	
}


Rsp_GetBlueprintAttributes::Rsp_GetBlueprintAttributes() {
	blueprintID = 0;
	productTypeID = 0;
	copy = false;
	productivityLevel = 0;
	materialLevel = 0;
	wastageFactor = 0.0;
	manufacturingTime = 0;
	maxProductionLimit = 0;
	licensedProductionRunsRemaining = 0;
	researchMaterialTime = 0;
	researchTechTime = 0;
	researchProductivityTime = 0;
	researchCopyTime = 0;
}

Rsp_GetBlueprintAttributes::~Rsp_GetBlueprintAttributes() {
}

void Rsp_GetBlueprintAttributes::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRsp_GetBlueprintAttributes", pfx);
	_log(l_type, "%sblueprintID=%lu", pfx, blueprintID);
	_log(l_type, "%sproductTypeID=%lu", pfx, productTypeID);
	_log(l_type, "%scopy=%s", pfx, copy?"true":"false");
	_log(l_type, "%sproductivityLevel=%lu", pfx, productivityLevel);
	_log(l_type, "%smaterialLevel=%lu", pfx, materialLevel);
	_log(l_type, "%swastageFactor=%.13f", pfx, wastageFactor);
	_log(l_type, "%smanufacturingTime=%lu", pfx, manufacturingTime);
	_log(l_type, "%smaxProductionLimit=%lu", pfx, maxProductionLimit);
	_log(l_type, "%slicensedProductionRunsRemaining=%lu", pfx, licensedProductionRunsRemaining);
	_log(l_type, "%sresearchMaterialTime=%lu", pfx, researchMaterialTime);
	_log(l_type, "%sresearchTechTime=%lu", pfx, researchTechTime);
	_log(l_type, "%sresearchProductivityTime=%lu", pfx, researchProductivityTime);
	_log(l_type, "%sresearchCopyTime=%lu", pfx, researchCopyTime);
}

PyRepDict *Rsp_GetBlueprintAttributes::Encode() {
	PyRepDict *res = NULL;
	PyRepDict *dict0 = new PyRepDict();
	PyRep *dict0_0;
	dict0_0 = new PyRepInteger(blueprintID);
	dict0->items[
		new PyRepString("blueprintID")
	] = dict0_0;
	PyRep *dict0_1;
	dict0_1 = new PyRepInteger(productTypeID);
	dict0->items[
		new PyRepString("productTypeID")
	] = dict0_1;
	PyRep *dict0_2;
	dict0_2 = new PyRepBoolean(copy);
	dict0->items[
		new PyRepString("copy")
	] = dict0_2;
	PyRep *dict0_3;
	dict0_3 = new PyRepInteger(productivityLevel);
	dict0->items[
		new PyRepString("productivityLevel")
	] = dict0_3;
	PyRep *dict0_4;
	dict0_4 = new PyRepInteger(materialLevel);
	dict0->items[
		new PyRepString("materialLevel")
	] = dict0_4;
	PyRep *dict0_5;
	dict0_5 = new PyRepReal(wastageFactor);
	dict0->items[
		new PyRepString("wastageFactor")
	] = dict0_5;
	PyRep *dict0_6;
	dict0_6 = new PyRepInteger(manufacturingTime);
	dict0->items[
		new PyRepString("manufacturingTime")
	] = dict0_6;
	PyRep *dict0_7;
	dict0_7 = new PyRepInteger(maxProductionLimit);
	dict0->items[
		new PyRepString("maxProductionLimit")
	] = dict0_7;
	PyRep *dict0_8;
	dict0_8 = new PyRepInteger(licensedProductionRunsRemaining);
	dict0->items[
		new PyRepString("licensedProductionRunsRemaining")
	] = dict0_8;
	PyRep *dict0_9;
	dict0_9 = new PyRepInteger(researchMaterialTime);
	dict0->items[
		new PyRepString("researchMaterialTime")
	] = dict0_9;
	PyRep *dict0_10;
	dict0_10 = new PyRepInteger(researchTechTime);
	dict0->items[
		new PyRepString("researchTechTime")
	] = dict0_10;
	PyRep *dict0_11;
	dict0_11 = new PyRepInteger(researchProductivityTime);
	dict0->items[
		new PyRepString("researchProductivityTime")
	] = dict0_11;
	PyRep *dict0_12;
	dict0_12 = new PyRepInteger(researchCopyTime);
	dict0->items[
		new PyRepString("researchCopyTime")
	] = dict0_12;
	res = dict0;
	

	return(res);
}

PyRepDict *Rsp_GetBlueprintAttributes::FastEncode() {
	PyRepDict *res = NULL;
	PyRepDict *dict0 = new PyRepDict();
	PyRep *dict0_0;
	dict0_0 = new PyRepInteger(blueprintID);
	dict0->items[
		new PyRepString("blueprintID")
	] = dict0_0;
	PyRep *dict0_1;
	dict0_1 = new PyRepInteger(productTypeID);
	dict0->items[
		new PyRepString("productTypeID")
	] = dict0_1;
	PyRep *dict0_2;
	dict0_2 = new PyRepBoolean(copy);
	dict0->items[
		new PyRepString("copy")
	] = dict0_2;
	PyRep *dict0_3;
	dict0_3 = new PyRepInteger(productivityLevel);
	dict0->items[
		new PyRepString("productivityLevel")
	] = dict0_3;
	PyRep *dict0_4;
	dict0_4 = new PyRepInteger(materialLevel);
	dict0->items[
		new PyRepString("materialLevel")
	] = dict0_4;
	PyRep *dict0_5;
	dict0_5 = new PyRepReal(wastageFactor);
	dict0->items[
		new PyRepString("wastageFactor")
	] = dict0_5;
	PyRep *dict0_6;
	dict0_6 = new PyRepInteger(manufacturingTime);
	dict0->items[
		new PyRepString("manufacturingTime")
	] = dict0_6;
	PyRep *dict0_7;
	dict0_7 = new PyRepInteger(maxProductionLimit);
	dict0->items[
		new PyRepString("maxProductionLimit")
	] = dict0_7;
	PyRep *dict0_8;
	dict0_8 = new PyRepInteger(licensedProductionRunsRemaining);
	dict0->items[
		new PyRepString("licensedProductionRunsRemaining")
	] = dict0_8;
	PyRep *dict0_9;
	dict0_9 = new PyRepInteger(researchMaterialTime);
	dict0->items[
		new PyRepString("researchMaterialTime")
	] = dict0_9;
	PyRep *dict0_10;
	dict0_10 = new PyRepInteger(researchTechTime);
	dict0->items[
		new PyRepString("researchTechTime")
	] = dict0_10;
	PyRep *dict0_11;
	dict0_11 = new PyRepInteger(researchProductivityTime);
	dict0->items[
		new PyRepString("researchProductivityTime")
	] = dict0_11;
	PyRep *dict0_12;
	dict0_12 = new PyRepInteger(researchCopyTime);
	dict0->items[
		new PyRepString("researchCopyTime")
	] = dict0_12;
	res = dict0;
	

	return(res);
}

bool Rsp_GetBlueprintAttributes::Decode(PyRepDict **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Rsp_GetBlueprintAttributes::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: dict0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	bool dict0_blueprintID = false;
	bool dict0_productTypeID = false;
	bool dict0_copy = false;
	bool dict0_productivityLevel = false;
	bool dict0_materialLevel = false;
	bool dict0_wastageFactor = false;
	bool dict0_manufacturingTime = false;
	bool dict0_maxProductionLimit = false;
	bool dict0_licensedProductionRunsRemaining = false;
	bool dict0_researchMaterialTime = false;
	bool dict0_researchTechTime = false;
	bool dict0_researchProductivityTime = false;
	bool dict0_researchCopyTime = false;
	PyRepDict *dict0 = (PyRepDict *) packet;
	
	PyRepDict::iterator dict0_cur, dict0_end;
	dict0_cur = dict0->items.begin();
	dict0_end = dict0->items.end();
	for(; dict0_cur != dict0_end; dict0_cur++) {
		PyRep *key__ = dict0_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: a key in dict0 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "blueprintID") {
			dict0_blueprintID = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: blueprintID is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) dict0_cur->second;
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field blueprintID");
	}
	blueprintID = int_1->value;
		} else
		if(key_string__->value == "productTypeID") {
			dict0_productTypeID = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: productTypeID is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) dict0_cur->second;
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field productTypeID");
	}
	productTypeID = int_2->value;
		} else
		if(key_string__->value == "copy") {
			dict0_copy = true;
	if(!dict0_cur->second->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: copy is not a boolean: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_3 = (PyRepBoolean *) dict0_cur->second;
	copy = bool_3->value;
		} else
		if(key_string__->value == "productivityLevel") {
			dict0_productivityLevel = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: productivityLevel is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) dict0_cur->second;
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field productivityLevel");
	}
	productivityLevel = int_4->value;
		} else
		if(key_string__->value == "materialLevel") {
			dict0_materialLevel = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: materialLevel is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) dict0_cur->second;
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field materialLevel");
	}
	materialLevel = int_5->value;
		} else
		if(key_string__->value == "wastageFactor") {
			dict0_wastageFactor = true;
	if(!dict0_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: wastageFactor is not a real: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) dict0_cur->second;
	wastageFactor = real_6->value;
		} else
		if(key_string__->value == "manufacturingTime") {
			dict0_manufacturingTime = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: manufacturingTime is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) dict0_cur->second;
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field manufacturingTime");
	}
	manufacturingTime = int_7->value;
		} else
		if(key_string__->value == "maxProductionLimit") {
			dict0_maxProductionLimit = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: maxProductionLimit is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) dict0_cur->second;
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field maxProductionLimit");
	}
	maxProductionLimit = int_8->value;
		} else
		if(key_string__->value == "licensedProductionRunsRemaining") {
			dict0_licensedProductionRunsRemaining = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: licensedProductionRunsRemaining is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) dict0_cur->second;
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field licensedProductionRunsRemaining");
	}
	licensedProductionRunsRemaining = int_9->value;
		} else
		if(key_string__->value == "researchMaterialTime") {
			dict0_researchMaterialTime = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: researchMaterialTime is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) dict0_cur->second;
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field researchMaterialTime");
	}
	researchMaterialTime = int_10->value;
		} else
		if(key_string__->value == "researchTechTime") {
			dict0_researchTechTime = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: researchTechTime is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_11 = (PyRepInteger *) dict0_cur->second;
	if(int_11->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field researchTechTime");
	}
	researchTechTime = int_11->value;
		} else
		if(key_string__->value == "researchProductivityTime") {
			dict0_researchProductivityTime = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: researchProductivityTime is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_12 = (PyRepInteger *) dict0_cur->second;
	if(int_12->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field researchProductivityTime");
	}
	researchProductivityTime = int_12->value;
		} else
		if(key_string__->value == "researchCopyTime") {
			dict0_researchCopyTime = true;
	if(!dict0_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: researchCopyTime is not an int: %s", dict0_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_13 = (PyRepInteger *) dict0_cur->second;
	if(int_13->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Rsp_GetBlueprintAttributes: truncating 64 bit into into 32 bit int for field researchCopyTime");
	}
	researchCopyTime = int_13->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Unknown key string '%s' in dict0", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict0_blueprintID) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'blueprintID' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_productTypeID) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'productTypeID' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_copy) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'copy' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_productivityLevel) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'productivityLevel' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_materialLevel) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'materialLevel' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_wastageFactor) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'wastageFactor' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_manufacturingTime) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'manufacturingTime' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_maxProductionLimit) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'maxProductionLimit' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_licensedProductionRunsRemaining) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'licensedProductionRunsRemaining' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_researchMaterialTime) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'researchMaterialTime' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_researchTechTime) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'researchTechTime' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_researchProductivityTime) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'researchProductivityTime' in dict0");
		delete packet;
		return(false);
	}
	
	if(!dict0_researchCopyTime) {
		_log(NET__PACKET_ERROR, "Decode Rsp_GetBlueprintAttributes failed: Missing dict entry for 'researchCopyTime' in dict0");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

Rsp_GetBlueprintAttributes *Rsp_GetBlueprintAttributes::Clone() const {
	Rsp_GetBlueprintAttributes *res = new Rsp_GetBlueprintAttributes;
	res->CloneFrom(this);
	return(res);
}

void Rsp_GetBlueprintAttributes::CloneFrom(const Rsp_GetBlueprintAttributes *from) {
	blueprintID = from->blueprintID;
	productTypeID = from->productTypeID;
	copy = from->copy;
	productivityLevel = from->productivityLevel;
	materialLevel = from->materialLevel;
	wastageFactor = from->wastageFactor;
	manufacturingTime = from->manufacturingTime;
	maxProductionLimit = from->maxProductionLimit;
	licensedProductionRunsRemaining = from->licensedProductionRunsRemaining;
	researchMaterialTime = from->researchMaterialTime;
	researchTechTime = from->researchTechTime;
	researchProductivityTime = from->researchProductivityTime;
	researchCopyTime = from->researchCopyTime;
	
}



