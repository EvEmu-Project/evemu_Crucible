/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "Tutorial.h"
#include "../common/PyRep.h"




Call_GetTutorialInfo::Call_GetTutorialInfo() {
	tutorialID = 0;
	languageID = "";
}

Call_GetTutorialInfo::~Call_GetTutorialInfo() {
}

void Call_GetTutorialInfo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCall_GetTutorialInfo", pfx);
	_log(l_type, "%stutorialID=%lu", pfx, tutorialID);
	_log(l_type, "%slanguageID='%s'", pfx, languageID.c_str());
}

PyRepTuple *Call_GetTutorialInfo::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(tutorialID);
	tuple0->items[1] = new PyRepString(languageID);
	res = tuple0;
	

	return(res);
}

PyRepTuple *Call_GetTutorialInfo::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	tuple0->items[0] = new PyRepInteger(tutorialID);
	tuple0->items[1] = new PyRepString(languageID);
	res = tuple0;
	

	return(res);
}

bool Call_GetTutorialInfo::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Call_GetTutorialInfo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetTutorialInfo failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode Call_GetTutorialInfo failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetTutorialInfo failed: tutorialID is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode Call_GetTutorialInfo: truncating 64 bit into into 32 bit int for field tutorialID");
	}
	tutorialID = int_1->value;
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode Call_GetTutorialInfo failed: languageID is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	languageID = string_2->value;

	delete packet;
	return(true);
}

Call_GetTutorialInfo *Call_GetTutorialInfo::Clone() const {
	Call_GetTutorialInfo *res = new Call_GetTutorialInfo;
	res->CloneFrom(this);
	return(res);
}

void Call_GetTutorialInfo::CloneFrom(const Call_GetTutorialInfo *from) {
	tutorialID = from->tutorialID;
	languageID = from->languageID;
	
}



