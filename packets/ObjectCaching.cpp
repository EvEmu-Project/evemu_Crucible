/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "../packets/ObjectCaching.h"
#include "../common/PyRep.h"




objectCaching_CachedObject_data::objectCaching_CachedObject_data() {
	/* object of type objectCaching.CachedObject */
	/*  0  */
	/*  0  */
	timestamp = 0;
	/*  1  */
	version = 0;
	/*  1  */
	/*  2  */
	/*  2  */
	nodeID = 0;
	/*  3  */
	shared = 0;
	/*  4  */
	data = NULL;
	/*  5  */
	compressed = 0;
	/*  6  */
	/*  either a string or a tuple  */
	objectID = NULL;
}

objectCaching_CachedObject_data::~objectCaching_CachedObject_data() {
	/*  0  */
	/*  0  */
	/*  1  */
	/*  1  */
	/*  2  */
	/*  2  */
	/*  3  */
	/*  4  */
	delete data;
	/*  5  */
	/*  6  */
	/*  either a string or a tuple  */
	delete objectID;
}

void objectCaching_CachedObject_data::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sobjectCaching_CachedObject_data", pfx);
	_log(l_type, "%sObject of type objectCaching.CachedObject:", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	/*  1  */
	_log(l_type, "%sversion=%lu", pfx, version);
	/*  1  */
	/*  2  */
	/*  2  */
	_log(l_type, "%snodeID=%lu", pfx, nodeID);
	/*  3  */
	_log(l_type, "%sshared=%lu", pfx, shared);
	/*  4  */
	_log(l_type, "%sdata: ", pfx);
	std::string data_n(pfx);
	data_n += "    ";
	data->Dump(l_type, data_n.c_str());
	/*  5  */
	_log(l_type, "%scompressed=%lu", pfx, compressed);
	/*  6  */
	/*  either a string or a tuple  */
	_log(l_type, "%sobjectID:", pfx);
	std::string objectID_n(pfx);
	objectID_n += "    ";
	if(objectID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", objectID_n.c_str());
	} else {
		objectID->Dump(l_type, objectID_n.c_str());
	}
}

PyRepObject *objectCaching_CachedObject_data::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(7);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepInteger(timestamp);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(version);
	tuple1->items[0] = tuple2;
	
	/*  1  */
	tuple1->items[1] = new PyRepNone();
	/*  2  */
	/*  2  */
	tuple1->items[2] = new PyRepInteger(nodeID);
	/*  3  */
	tuple1->items[3] = new PyRepInteger(shared);
	/*  4  */
	if(data == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedObject_data: data is NULL! hacking in an empty buffer.");
		data = new PyRepBuffer(0);
	}
	tuple1->items[4] = data->Clone();
	/*  5  */
	tuple1->items[5] = new PyRepInteger(compressed);
	/*  6  */
	/*  either a string or a tuple  */
	if(objectID == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedObject_data: objectID is NULL! hacking in a PyRepNone");
		objectID = new PyRepNone();
	}
	tuple1->items[6] = objectID->Clone();
	args0 = tuple1;
	
	res = new PyRepObject(
			"objectCaching.CachedObject",
			args0
		);
	

	return(res);
}

PyRepObject *objectCaching_CachedObject_data::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(7);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepInteger(timestamp);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(version);
	tuple1->items[0] = tuple2;
	
	/*  1  */
	tuple1->items[1] = new PyRepNone();
	/*  2  */
	/*  2  */
	tuple1->items[2] = new PyRepInteger(nodeID);
	/*  3  */
	tuple1->items[3] = new PyRepInteger(shared);
	/*  4  */
	if(data == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedObject_data: data is NULL! hacking in an empty buffer.");
		data = new PyRepBuffer(0);
	}
	tuple1->items[4] = data;
	data = NULL;
	/*  5  */
	tuple1->items[5] = new PyRepInteger(compressed);
	/*  6  */
	/*  either a string or a tuple  */
	if(objectID == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedObject_data: objectID is NULL! hacking in a PyRepNone");
		objectID = new PyRepNone();
	}
	tuple1->items[6] = objectID;
	objectID = NULL;
	args0 = tuple1;
	
	res = new PyRepObject(
			"objectCaching.CachedObject",
			args0
		);
	

	return(res);
}

bool objectCaching_CachedObject_data::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool objectCaching_CachedObject_data::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "objectCaching.CachedObject") {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: obj_0 is the wrong object type. Expected 'objectCaching.CachedObject', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: tuple1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) obj_0->arguments;
	if(tuple1->items.size() != 7) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: tuple1 is the wrong size: expected 7, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: tuple2 is the wrong type: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple1->items[0];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: timestamp is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_3 = (PyRepInteger *) tuple2->items[0];
	timestamp = int64_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: version is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_data: truncating 64 bit into into 32 bit int for field version");
	}
	version = int_4->value;
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: expecting a None but got a %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  2  */
	/*  2  */
	if(!tuple1->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: nodeID is not an int: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple1->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_data: truncating 64 bit into into 32 bit int for field nodeID");
	}
	nodeID = int_5->value;
	/*  3  */
	if(!tuple1->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: shared is not an int: %s", tuple1->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple1->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_data: truncating 64 bit into into 32 bit int for field shared");
	}
	shared = int_6->value;
	/*  4  */
	if(tuple1->items[4]->CheckType(PyRep::Buffer)) {
		data = (PyRepBuffer *) tuple1->items[4];
		tuple1->items[4] = NULL;
	} else if(tuple1->items[4]->CheckType(PyRep::String)) {
		PyRepString *__sss = (PyRepString *) tuple1->items[4];
		tuple1->items[4] = NULL;
		data = new PyRepBuffer((const byte *) __sss->value.c_str(), __sss->value.length());
		delete __sss;
	} else {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: data is not a buffer: %s", tuple1->items[4]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  5  */
	if(!tuple1->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_data failed: compressed is not an int: %s", tuple1->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple1->items[5];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_data: truncating 64 bit into into 32 bit int for field compressed");
	}
	compressed = int_7->value;
	/*  6  */
	/*  either a string or a tuple  */
	delete objectID;
	objectID = tuple1->items[6];
	tuple1->items[6] = NULL;
	

	delete packet;
	return(true);
}

objectCaching_CachedObject_data *objectCaching_CachedObject_data::Clone() const {
	objectCaching_CachedObject_data *res = new objectCaching_CachedObject_data;
	res->CloneFrom(this);
	return(res);
}

void objectCaching_CachedObject_data::CloneFrom(const objectCaching_CachedObject_data *from) {
	/* object of type objectCaching.CachedObject */
	/*  0  */
	/*  0  */
	timestamp = from->timestamp;
	/*  1  */
	version = from->version;
	/*  1  */
	/*  2  */
	/*  2  */
	nodeID = from->nodeID;
	/*  3  */
	shared = from->shared;
	/*  4  */
	delete data;
	if(from->data == NULL) {
		data = NULL;
	} else {
		data = from->data->TypedClone();
	}
	/*  5  */
	compressed = from->compressed;
	/*  6  */
	/*  either a string or a tuple  */
	delete objectID;
	if(from->objectID == NULL) {
		objectID = NULL;
	} else {
		objectID = from->objectID->Clone();
	}
	
}


objectCaching_CachedObject_spec::objectCaching_CachedObject_spec() {
	/* object of type util.CachedObject */
	/*  0  */
	objectID = NULL;
	/*  1  */
	nodeID = 0;
	/*  2  */
	/*  0  */
	timestamp = 0;
	/*  1  */
	version = 0;
}

objectCaching_CachedObject_spec::~objectCaching_CachedObject_spec() {
	/*  0  */
	delete objectID;
	/*  1  */
	/*  2  */
	/*  0  */
	/*  1  */
}

void objectCaching_CachedObject_spec::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sobjectCaching_CachedObject_spec", pfx);
	_log(l_type, "%sObject of type util.CachedObject:", pfx);
	/*  0  */
	_log(l_type, "%sobjectID:", pfx);
	std::string objectID_n(pfx);
	objectID_n += "    ";
	if(objectID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", objectID_n.c_str());
	} else {
		objectID->Dump(l_type, objectID_n.c_str());
	}
	/*  1  */
	_log(l_type, "%snodeID=%lu", pfx, nodeID);
	/*  2  */
	/*  0  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	/*  1  */
	_log(l_type, "%sversion=%lu", pfx, version);
}

PyRepObject *objectCaching_CachedObject_spec::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	if(objectID == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedObject_spec: objectID is NULL! hacking in a PyRepNone");
		objectID = new PyRepNone();
	}
	tuple1->items[0] = objectID->Clone();
	/*  1  */
	tuple1->items[1] = new PyRepInteger(nodeID);
	/*  2  */
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepInteger(timestamp);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(version);
	tuple1->items[2] = tuple2;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"util.CachedObject",
			args0
		);
	

	return(res);
}

PyRepObject *objectCaching_CachedObject_spec::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	if(objectID == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedObject_spec: objectID is NULL! hacking in a PyRepNone");
		objectID = new PyRepNone();
	}
	tuple1->items[0] = objectID;
	objectID = NULL;
	/*  1  */
	tuple1->items[1] = new PyRepInteger(nodeID);
	/*  2  */
	PyRepTuple *tuple2 = new PyRepTuple(2);
	/*  0  */
	tuple2->items[0] = new PyRepInteger(timestamp);
	/*  1  */
	tuple2->items[1] = new PyRepInteger(version);
	tuple1->items[2] = tuple2;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"util.CachedObject",
			args0
		);
	

	return(res);
}

bool objectCaching_CachedObject_spec::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool objectCaching_CachedObject_spec::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "util.CachedObject") {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: obj_0 is the wrong object type. Expected 'util.CachedObject', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: tuple1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) obj_0->arguments;
	if(tuple1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: tuple1 is the wrong size: expected 3, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	delete objectID;
	objectID = tuple1->items[0];
	tuple1->items[0] = NULL;
	
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: nodeID is not an int: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) tuple1->items[1];
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_spec: truncating 64 bit into into 32 bit int for field nodeID");
	}
	nodeID = int_2->value;
	/*  2  */
	if(!tuple1->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: tuple3 is the wrong type: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple3 = (PyRepTuple *) tuple1->items[2];
	if(tuple3->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: tuple3 is the wrong size: expected 2, but got %d", tuple3->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple3->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: timestamp is not an int: %s", tuple3->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple3->items[0];
	timestamp = int64_4->value;
	/*  1  */
	if(!tuple3->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedObject_spec failed: version is not an int: %s", tuple3->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple3->items[1];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedObject_spec: truncating 64 bit into into 32 bit int for field version");
	}
	version = int_5->value;

	delete packet;
	return(true);
}

objectCaching_CachedObject_spec *objectCaching_CachedObject_spec::Clone() const {
	objectCaching_CachedObject_spec *res = new objectCaching_CachedObject_spec;
	res->CloneFrom(this);
	return(res);
}

void objectCaching_CachedObject_spec::CloneFrom(const objectCaching_CachedObject_spec *from) {
	/* object of type util.CachedObject */
	/*  0  */
	delete objectID;
	if(from->objectID == NULL) {
		objectID = NULL;
	} else {
		objectID = from->objectID->Clone();
	}
	/*  1  */
	nodeID = from->nodeID;
	/*  2  */
	/*  0  */
	timestamp = from->timestamp;
	/*  1  */
	version = from->version;
	
}


objectCaching_CachedMethodCallResult::objectCaching_CachedMethodCallResult() {
	/* object of type objectCaching.CachedMethodCallResult */
	/*  0: details  */
	/*  sessionInfo: if this field is present, then it contains a string which
               is the string of a key in the session. The value of that element in the
               current session is used as part of the key for the cache item.
           */
	sessionInfo = "";
	/*  these fields are one of:
            (always, never, (set of times))
             */
	/*  0: clientWhen: expiry in the client  */
	clientWhen = "";
	/*  1: proxyWhen: expiry on the proxy, may be None  */
	proxyWhen = "";
	/*  2: serverWhen: expiry on the server, may be None  */
	serverWhen = "";
	/*  1: result  */
	call_return = NULL;
	/*  2: version  */
	/*  0  */
	timeStamp = 0;
	/*  1: binascii.crc_hqx(call_return, (macho.version + 170472))  */
	version = 0;
}

objectCaching_CachedMethodCallResult::~objectCaching_CachedMethodCallResult() {
	/*  0: details  */
	/*  sessionInfo: if this field is present, then it contains a string which
               is the string of a key in the session. The value of that element in the
               current session is used as part of the key for the cache item.
           */
	/*  these fields are one of:
            (always, never, (set of times))
             */
	/*  0: clientWhen: expiry in the client  */
	/*  1: proxyWhen: expiry on the proxy, may be None  */
	/*  2: serverWhen: expiry on the server, may be None  */
	/*  1: result  */
	delete call_return;
	/*  2: version  */
	/*  0  */
	/*  1: binascii.crc_hqx(call_return, (macho.version + 170472))  */
}

void objectCaching_CachedMethodCallResult::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sobjectCaching_CachedMethodCallResult", pfx);
	_log(l_type, "%sObject of type objectCaching.CachedMethodCallResult:", pfx);
	/*  0: details  */
	/*  sessionInfo: if this field is present, then it contains a string which
               is the string of a key in the session. The value of that element in the
               current session is used as part of the key for the cache item.
           */
	_log(l_type, "%ssessionInfo='%s'", pfx, sessionInfo.c_str());
	/*  these fields are one of:
            (always, never, (set of times))
             */
	/*  0: clientWhen: expiry in the client  */
	_log(l_type, "%sclientWhen='%s'", pfx, clientWhen.c_str());
	/*  1: proxyWhen: expiry on the proxy, may be None  */
	_log(l_type, "%sproxyWhen='%s'", pfx, proxyWhen.c_str());
	/*  2: serverWhen: expiry on the server, may be None  */
	_log(l_type, "%sserverWhen='%s'", pfx, serverWhen.c_str());
	/*  1: result  */
	_log(l_type, "%scall_return:", pfx);
	std::string call_return_n(pfx);
	call_return_n += "    ";
	if(call_return == NULL) {
		_log(l_type, "%sERROR: NULL REP!", call_return_n.c_str());
	} else {
		call_return->Dump(l_type, call_return_n.c_str());
	}
	/*  2: version  */
	/*  0  */
	_log(l_type, "%stimeStamp=" I64u, pfx, timeStamp);
	/*  1: binascii.crc_hqx(call_return, (macho.version + 170472))  */
	_log(l_type, "%sversion=%lu", pfx, version);
}

PyRepObject *objectCaching_CachedMethodCallResult::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0: details  */
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	/*  sessionInfo: if this field is present, then it contains a string which
               is the string of a key in the session. The value of that element in the
               current session is used as part of the key for the cache item.
           */
	dict2_0 = new PyRepString(sessionInfo);
	dict2->items[
		new PyRepString("sessionInfo")
	] = dict2_0;
	PyRep *dict2_1;
	/*  these fields are one of:
            (always, never, (set of times))
             */
	PyRepTuple *tuple3 = new PyRepTuple(3);
	/*  0: clientWhen: expiry in the client  */
	tuple3->items[0] = new PyRepString(clientWhen);
	/*  1: proxyWhen: expiry on the proxy, may be None  */
	tuple3->items[1] = new PyRepString(proxyWhen);
	/*  2: serverWhen: expiry on the server, may be None  */
	tuple3->items[2] = new PyRepString(serverWhen);
	dict2_1 = tuple3;
	
	dict2->items[
		new PyRepString("versionCheck")
	] = dict2_1;
	tuple1->items[0] = dict2;
	
	/*  1: result  */
	if(call_return == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedMethodCallResult: call_return is NULL! hacking in a PyRepNone");
		call_return = new PyRepNone();
	}
	tuple1->items[1] = call_return->Clone();
	/*  2: version  */
	PyRepList *list4 = new PyRepList();
	list4->items.resize(2, NULL);
	/*  0  */
	list4->items[0] = new PyRepInteger(timeStamp);
	/*  1: binascii.crc_hqx(call_return, (macho.version + 170472))  */
	list4->items[1] = new PyRepInteger(version);
	tuple1->items[2] = list4;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"objectCaching.CachedMethodCallResult",
			args0
		);
	

	return(res);
}

PyRepObject *objectCaching_CachedMethodCallResult::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0: details  */
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	/*  sessionInfo: if this field is present, then it contains a string which
               is the string of a key in the session. The value of that element in the
               current session is used as part of the key for the cache item.
           */
	dict2_0 = new PyRepString(sessionInfo);
	dict2->items[
		new PyRepString("sessionInfo")
	] = dict2_0;
	PyRep *dict2_1;
	/*  these fields are one of:
            (always, never, (set of times))
             */
	PyRepTuple *tuple3 = new PyRepTuple(3);
	/*  0: clientWhen: expiry in the client  */
	tuple3->items[0] = new PyRepString(clientWhen);
	/*  1: proxyWhen: expiry on the proxy, may be None  */
	tuple3->items[1] = new PyRepString(proxyWhen);
	/*  2: serverWhen: expiry on the server, may be None  */
	tuple3->items[2] = new PyRepString(serverWhen);
	dict2_1 = tuple3;
	
	dict2->items[
		new PyRepString("versionCheck")
	] = dict2_1;
	tuple1->items[0] = dict2;
	
	/*  1: result  */
	if(call_return == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedMethodCallResult: call_return is NULL! hacking in a PyRepNone");
		call_return = new PyRepNone();
	}
	tuple1->items[1] = call_return;
	call_return = NULL;
	/*  2: version  */
	PyRepList *list4 = new PyRepList();
	list4->items.resize(2, NULL);
	/*  0  */
	list4->items[0] = new PyRepInteger(timeStamp);
	/*  1: binascii.crc_hqx(call_return, (macho.version + 170472))  */
	list4->items[1] = new PyRepInteger(version);
	tuple1->items[2] = list4;
	
	args0 = tuple1;
	
	res = new PyRepObject(
			"objectCaching.CachedMethodCallResult",
			args0
		);
	

	return(res);
}

bool objectCaching_CachedMethodCallResult::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool objectCaching_CachedMethodCallResult::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "objectCaching.CachedMethodCallResult") {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: obj_0 is the wrong object type. Expected 'objectCaching.CachedMethodCallResult', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: tuple1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) obj_0->arguments;
	if(tuple1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: tuple1 is the wrong size: expected 3, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0: details  */
	if(!tuple1->items[0]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: dict2 is the wrong type: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	bool dict2_sessionInfo = false;
	bool dict2_hack_for_XML_validation = false;
	PyRepDict *dict2 = (PyRepDict *) tuple1->items[0];
	
	PyRepDict::iterator dict2_cur, dict2_end;
	dict2_cur = dict2->items.begin();
	dict2_end = dict2->items.end();
	for(; dict2_cur != dict2_end; dict2_cur++) {
		PyRep *key__ = dict2_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: a key in dict2 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "sessionInfo") {
			dict2_sessionInfo = true;
	/*  sessionInfo: if this field is present, then it contains a string which
               is the string of a key in the session. The value of that element in the
               current session is used as part of the key for the cache item.
           */
	if(!dict2_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: sessionInfo is not a string: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) dict2_cur->second;
	sessionInfo = string_3->value;
		} else
		if(key_string__->value == "versionCheck") {
			dict2_hack_for_XML_validation = true;
	/*  these fields are one of:
            (always, never, (set of times))
             */
	if(!dict2_cur->second->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: tuple4 is the wrong type: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple4 = (PyRepTuple *) dict2_cur->second;
	if(tuple4->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: tuple4 is the wrong size: expected 3, but got %d", tuple4->items.size());
		delete packet;
		return(false);
	}

	/*  0: clientWhen: expiry in the client  */
	if(!tuple4->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: clientWhen is not a string: %s", tuple4->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) tuple4->items[0];
	clientWhen = string_5->value;
	/*  1: proxyWhen: expiry on the proxy, may be None  */
	if(!tuple4->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: proxyWhen is not a string: %s", tuple4->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) tuple4->items[1];
	proxyWhen = string_6->value;
	/*  2: serverWhen: expiry on the server, may be None  */
	if(!tuple4->items[2]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: serverWhen is not a string: %s", tuple4->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_7 = (PyRepString *) tuple4->items[2];
	serverWhen = string_7->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: Unknown key string '%s' in dict2", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict2_sessionInfo) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: Missing dict entry for 'sessionInfo' in dict2");
		delete packet;
		return(false);
	}
	
	if(!dict2_hack_for_XML_validation) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: Missing dict entry for 'hack_for_XML_validation' in dict2");
		delete packet;
		return(false);
	}
	
	/*  1: result  */
	delete call_return;
	call_return = tuple1->items[1];
	tuple1->items[1] = NULL;
	
	/*  2: version  */
	if(!tuple1->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: list8 is not a list: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list8 = (PyRepList *) tuple1->items[2];
	if(list8->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: list8 is the wrong size: expected 2, but got %d", list8->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!list8->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: timeStamp is not an int: %s", list8->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_9 = (PyRepInteger *) list8->items[0];
	timeStamp = int64_9->value;
	/*  1: binascii.crc_hqx(call_return, (macho.version + 170472))  */
	if(!list8->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult failed: version is not an int: %s", list8->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) list8->items[1];
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode objectCaching_CachedMethodCallResult: truncating 64 bit into into 32 bit int for field version");
	}
	version = int_10->value;

	delete packet;
	return(true);
}

objectCaching_CachedMethodCallResult *objectCaching_CachedMethodCallResult::Clone() const {
	objectCaching_CachedMethodCallResult *res = new objectCaching_CachedMethodCallResult;
	res->CloneFrom(this);
	return(res);
}

void objectCaching_CachedMethodCallResult::CloneFrom(const objectCaching_CachedMethodCallResult *from) {
	/* object of type objectCaching.CachedMethodCallResult */
	/*  0: details  */
	/*  sessionInfo: if this field is present, then it contains a string which
               is the string of a key in the session. The value of that element in the
               current session is used as part of the key for the cache item.
           */
	sessionInfo = from->sessionInfo;
	/*  these fields are one of:
            (always, never, (set of times))
             */
	/*  0: clientWhen: expiry in the client  */
	clientWhen = from->clientWhen;
	/*  1: proxyWhen: expiry on the proxy, may be None  */
	proxyWhen = from->proxyWhen;
	/*  2: serverWhen: expiry on the server, may be None  */
	serverWhen = from->serverWhen;
	/*  1: result  */
	delete call_return;
	if(from->call_return == NULL) {
		call_return = NULL;
	} else {
		call_return = from->call_return->Clone();
	}
	/*  2: version  */
	/*  0  */
	timeStamp = from->timeStamp;
	/*  1: binascii.crc_hqx(call_return, (macho.version + 170472))  */
	version = from->version;
	
}


objectCaching_CachedMethodCallResult_object::objectCaching_CachedMethodCallResult_object() {
	/* object of type objectCaching.CachedMethodCallResult */
	/*  0: details  */
	/*  almost all simple objects on live use never... 
                a few use run, we default to run to be more flexible.  */
	versionCheck = "run";
	/*  1: result, in this case it is always a util.CachedObject hint  */
	/*  <element type="objectCaching_CachedObject_spec" name="object" />  */
	object = NULL;
	/*  2: version, never present on a cached object cached method  */
}

objectCaching_CachedMethodCallResult_object::~objectCaching_CachedMethodCallResult_object() {
	/*  0: details  */
	/*  almost all simple objects on live use never... 
                a few use run, we default to run to be more flexible.  */
	/*  1: result, in this case it is always a util.CachedObject hint  */
	/*  <element type="objectCaching_CachedObject_spec" name="object" />  */
	delete object;
	/*  2: version, never present on a cached object cached method  */
}

void objectCaching_CachedMethodCallResult_object::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sobjectCaching_CachedMethodCallResult_object", pfx);
	_log(l_type, "%sObject of type objectCaching.CachedMethodCallResult:", pfx);
	/*  0: details  */
	/*  almost all simple objects on live use never... 
                a few use run, we default to run to be more flexible.  */
	_log(l_type, "%sversionCheck='%s'", pfx, versionCheck.c_str());
	/*  1: result, in this case it is always a util.CachedObject hint  */
	/*  <element type="objectCaching_CachedObject_spec" name="object" />  */
	_log(l_type, "%sobject:", pfx);
	std::string object_n(pfx);
	object_n += "    ";
	if(object == NULL) {
		_log(l_type, "%sERROR: NULL REP!", object_n.c_str());
	} else {
		object->Dump(l_type, object_n.c_str());
	}
	/*  2: version, never present on a cached object cached method  */
}

PyRepObject *objectCaching_CachedMethodCallResult_object::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0: details  */
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	/*  almost all simple objects on live use never... 
                a few use run, we default to run to be more flexible.  */
	dict2_0 = new PyRepString(versionCheck);
	dict2->items[
		new PyRepString("versionCheck")
	] = dict2_0;
	tuple1->items[0] = dict2;
	
	/*  1: result, in this case it is always a util.CachedObject hint  */
	/*  <element type="objectCaching_CachedObject_spec" name="object" />  */
	if(object == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedMethodCallResult_object: object is NULL! hacking in a PyRepNone");
		object = new PyRepNone();
	}
	tuple1->items[1] = object->Clone();
	/*  2: version, never present on a cached object cached method  */
	tuple1->items[2] = new PyRepNone();
	args0 = tuple1;
	
	res = new PyRepObject(
			"objectCaching.CachedMethodCallResult",
			args0
		);
	

	return(res);
}

PyRepObject *objectCaching_CachedMethodCallResult_object::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0: details  */
	PyRepDict *dict2 = new PyRepDict();
	PyRep *dict2_0;
	/*  almost all simple objects on live use never... 
                a few use run, we default to run to be more flexible.  */
	dict2_0 = new PyRepString(versionCheck);
	dict2->items[
		new PyRepString("versionCheck")
	] = dict2_0;
	tuple1->items[0] = dict2;
	
	/*  1: result, in this case it is always a util.CachedObject hint  */
	/*  <element type="objectCaching_CachedObject_spec" name="object" />  */
	if(object == NULL) {
		_log(NET__PACKET_ERROR, "Encode objectCaching_CachedMethodCallResult_object: object is NULL! hacking in a PyRepNone");
		object = new PyRepNone();
	}
	tuple1->items[1] = object;
	object = NULL;
	/*  2: version, never present on a cached object cached method  */
	tuple1->items[2] = new PyRepNone();
	args0 = tuple1;
	
	res = new PyRepObject(
			"objectCaching.CachedMethodCallResult",
			args0
		);
	

	return(res);
}

bool objectCaching_CachedMethodCallResult_object::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool objectCaching_CachedMethodCallResult_object::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "objectCaching.CachedMethodCallResult") {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: obj_0 is the wrong object type. Expected 'objectCaching.CachedMethodCallResult', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: tuple1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) obj_0->arguments;
	if(tuple1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: tuple1 is the wrong size: expected 3, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0: details  */
	if(!tuple1->items[0]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: dict2 is the wrong type: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	bool dict2_versionCheck = false;
	PyRepDict *dict2 = (PyRepDict *) tuple1->items[0];
	
	PyRepDict::iterator dict2_cur, dict2_end;
	dict2_cur = dict2->items.begin();
	dict2_end = dict2->items.end();
	for(; dict2_cur != dict2_end; dict2_cur++) {
		PyRep *key__ = dict2_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: a key in dict2 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "versionCheck") {
			dict2_versionCheck = true;
	/*  almost all simple objects on live use never... 
                a few use run, we default to run to be more flexible.  */
	if(!dict2_cur->second->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: versionCheck is not a string: %s", dict2_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) dict2_cur->second;
	versionCheck = string_3->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: Unknown key string '%s' in dict2", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict2_versionCheck) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: Missing dict entry for 'versionCheck' in dict2");
		delete packet;
		return(false);
	}
	
	/*  1: result, in this case it is always a util.CachedObject hint  */
	/*  <element type="objectCaching_CachedObject_spec" name="object" />  */
	delete object;
	object = tuple1->items[1];
	tuple1->items[1] = NULL;
	
	/*  2: version, never present on a cached object cached method  */
	if(!tuple1->items[2]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CachedMethodCallResult_object failed: expecting a None but got a %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

objectCaching_CachedMethodCallResult_object *objectCaching_CachedMethodCallResult_object::Clone() const {
	objectCaching_CachedMethodCallResult_object *res = new objectCaching_CachedMethodCallResult_object;
	res->CloneFrom(this);
	return(res);
}

void objectCaching_CachedMethodCallResult_object::CloneFrom(const objectCaching_CachedMethodCallResult_object *from) {
	/* object of type objectCaching.CachedMethodCallResult */
	/*  0: details  */
	/*  almost all simple objects on live use never... 
                a few use run, we default to run to be more flexible.  */
	versionCheck = from->versionCheck;
	/*  1: result, in this case it is always a util.CachedObject hint  */
	/*  <element type="objectCaching_CachedObject_spec" name="object" />  */
	delete object;
	if(from->object == NULL) {
		object = NULL;
	} else {
		object = from->object->Clone();
	}
	/*  2: version, never present on a cached object cached method  */
	
}

	/*  A representation of a simple cached method call objectID, with no arguments  */

SimpleMethodCallID::SimpleMethodCallID() {
	/*  0  */
	type = "Method Call";
	/*  1  */
	where = "server";
	/*  2  */
	/*  0  */
	service = "";
	/*  1  */
	method = "";
}

SimpleMethodCallID::~SimpleMethodCallID() {
	/*  0  */
	/*  1  */
	/*  2  */
	/*  0  */
	/*  1  */
}

void SimpleMethodCallID::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sSimpleMethodCallID", pfx);
	/*  0  */
	_log(l_type, "%stype='%s'", pfx, type.c_str());
	/*  1  */
	_log(l_type, "%swhere='%s'", pfx, where.c_str());
	/*  2  */
	/*  0  */
	_log(l_type, "%sservice='%s'", pfx, service.c_str());
	/*  1  */
	_log(l_type, "%smethod='%s'", pfx, method.c_str());
}

PyRepTuple *SimpleMethodCallID::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	tuple0->items[0] = new PyRepString(type);
	/*  1  */
	tuple0->items[1] = new PyRepString(where);
	/*  2  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepString(service);
	/*  1  */
	tuple1->items[1] = new PyRepString(method);
	tuple0->items[2] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *SimpleMethodCallID::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	tuple0->items[0] = new PyRepString(type);
	/*  1  */
	tuple0->items[1] = new PyRepString(where);
	/*  2  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepString(service);
	/*  1  */
	tuple1->items[1] = new PyRepString(method);
	tuple0->items[2] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool SimpleMethodCallID::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool SimpleMethodCallID::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode SimpleMethodCallID failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode SimpleMethodCallID failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode SimpleMethodCallID failed: type is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	type = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode SimpleMethodCallID failed: where is not a string: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_2 = (PyRepString *) tuple0->items[1];
	where = string_2->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode SimpleMethodCallID failed: tuple3 is the wrong type: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple3 = (PyRepTuple *) tuple0->items[2];
	if(tuple3->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode SimpleMethodCallID failed: tuple3 is the wrong size: expected 2, but got %d", tuple3->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple3->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode SimpleMethodCallID failed: service is not a string: %s", tuple3->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) tuple3->items[0];
	service = string_4->value;
	/*  1  */
	if(!tuple3->items[1]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode SimpleMethodCallID failed: method is not a string: %s", tuple3->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_5 = (PyRepString *) tuple3->items[1];
	method = string_5->value;

	delete packet;
	return(true);
}

SimpleMethodCallID *SimpleMethodCallID::Clone() const {
	SimpleMethodCallID *res = new SimpleMethodCallID;
	res->CloneFrom(this);
	return(res);
}

void SimpleMethodCallID::CloneFrom(const SimpleMethodCallID *from) {
	/*  0  */
	type = from->type;
	/*  1  */
	where = from->where;
	/*  2  */
	/*  0  */
	service = from->service;
	/*  1  */
	method = from->method;
	
}


CallGetCachableObject::CallGetCachableObject() {
	/*  0  */
	shared = 0;
	/*  1  */
	/*  either a string or a tuple  */
	objectID = NULL;
	/*  2  */
	/*  0  */
	timestamp = 0;
	/*  1  */
	version = 0;
	/*  3  */
	nodeID = 0;
}

CallGetCachableObject::~CallGetCachableObject() {
	/*  0  */
	/*  1  */
	/*  either a string or a tuple  */
	delete objectID;
	/*  2  */
	/*  0  */
	/*  1  */
	/*  3  */
}

void CallGetCachableObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sCallGetCachableObject", pfx);
	/*  0  */
	_log(l_type, "%sshared=%lu", pfx, shared);
	/*  1  */
	/*  either a string or a tuple  */
	_log(l_type, "%sobjectID:", pfx);
	std::string objectID_n(pfx);
	objectID_n += "    ";
	if(objectID == NULL) {
		_log(l_type, "%sERROR: NULL REP!", objectID_n.c_str());
	} else {
		objectID->Dump(l_type, objectID_n.c_str());
	}
	/*  2  */
	/*  0  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	/*  1  */
	_log(l_type, "%sversion=%lu", pfx, version);
	/*  3  */
	_log(l_type, "%snodeID=%lu", pfx, nodeID);
}

PyRepTuple *CallGetCachableObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(4);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(shared);
	/*  1  */
	/*  either a string or a tuple  */
	if(objectID == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallGetCachableObject: objectID is NULL! hacking in a PyRepNone");
		objectID = new PyRepNone();
	}
	tuple0->items[1] = objectID->Clone();
	/*  2  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(timestamp);
	/*  1  */
	tuple1->items[1] = new PyRepInteger(version);
	tuple0->items[2] = tuple1;
	
	/*  3  */
	tuple0->items[3] = new PyRepInteger(nodeID);
	res = tuple0;
	

	return(res);
}

PyRepTuple *CallGetCachableObject::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(4);
	/*  0  */
	tuple0->items[0] = new PyRepInteger(shared);
	/*  1  */
	/*  either a string or a tuple  */
	if(objectID == NULL) {
		_log(NET__PACKET_ERROR, "Encode CallGetCachableObject: objectID is NULL! hacking in a PyRepNone");
		objectID = new PyRepNone();
	}
	tuple0->items[1] = objectID;
	objectID = NULL;
	/*  2  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(timestamp);
	/*  1  */
	tuple1->items[1] = new PyRepInteger(version);
	tuple0->items[2] = tuple1;
	
	/*  3  */
	tuple0->items[3] = new PyRepInteger(nodeID);
	res = tuple0;
	

	return(res);
}

bool CallGetCachableObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool CallGetCachableObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: tuple0 is the wrong size: expected 4, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: shared is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCachableObject: truncating 64 bit into into 32 bit int for field shared");
	}
	shared = int_1->value;
	/*  1  */
	/*  either a string or a tuple  */
	delete objectID;
	objectID = tuple0->items[1];
	tuple0->items[1] = NULL;
	
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: tuple2 is the wrong type: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[2];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: timestamp is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_3 = (PyRepInteger *) tuple2->items[0];
	timestamp = int64_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: version is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCachableObject: truncating 64 bit into into 32 bit int for field version");
	}
	version = int_4->value;
	/*  3  */
	if(!tuple0->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode CallGetCachableObject failed: nodeID is not an int: %s", tuple0->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple0->items[3];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode CallGetCachableObject: truncating 64 bit into into 32 bit int for field nodeID");
	}
	nodeID = int_5->value;

	delete packet;
	return(true);
}

CallGetCachableObject *CallGetCachableObject::Clone() const {
	CallGetCachableObject *res = new CallGetCachableObject;
	res->CloneFrom(this);
	return(res);
}

void CallGetCachableObject::CloneFrom(const CallGetCachableObject *from) {
	/*  0  */
	shared = from->shared;
	/*  1  */
	/*  either a string or a tuple  */
	delete objectID;
	if(from->objectID == NULL) {
		objectID = NULL;
	} else {
		objectID = from->objectID->Clone();
	}
	/*  2  */
	/*  0  */
	timestamp = from->timestamp;
	/*  1  */
	version = from->version;
	/*  3  */
	nodeID = from->nodeID;
	
}


RspGetCachableObject::RspGetCachableObject() {
	/*  0  */
}

RspGetCachableObject::~RspGetCachableObject() {
	/*  0  */
}

void RspGetCachableObject::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sRspGetCachableObject", pfx);
	/*  0  */
	_log(l_type, "%sobject:", pfx);
	std::string object_n(pfx);
	object_n += "    ";
	object.Dump(l_type, object_n.c_str());
}

PyRepTuple *RspGetCachableObject::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = object.Encode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

PyRepTuple *RspGetCachableObject::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0  */
	PyRep *ss_1;
		ss_1 = object.FastEncode();
	tuple0->items[0] = new PyRepSubStream(ss_1);
	res = tuple0;
	

	return(res);
}

bool RspGetCachableObject::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool RspGetCachableObject::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::SubStream)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: ss_1 is not a substream: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}	
	PyRepSubStream *ss_1 = (PyRepSubStream *) tuple0->items[0];
	//make sure its decoded
	ss_1->DecodeData();
	if(ss_1->decoded == NULL) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: Unable to decode ss_1");
		delete packet;
		return(false);
	}
	
	PyRep *rep_2 = ss_1->decoded;
	ss_1->decoded = NULL;
	if(!object.Decode(&rep_2)) {
		_log(NET__PACKET_ERROR, "Decode RspGetCachableObject failed: unable to decode element object");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

RspGetCachableObject *RspGetCachableObject::Clone() const {
	RspGetCachableObject *res = new RspGetCachableObject;
	res->CloneFrom(this);
	return(res);
}

void RspGetCachableObject::CloneFrom(const RspGetCachableObject *from) {
	/*  0  */
	object.CloneFrom(&from->object);
	
}


objectCaching_CacheOK::objectCaching_CacheOK() {
	/* object of type objectCaching.CacheOK */
	exception_string = "CacheOK";
}

objectCaching_CacheOK::~objectCaching_CacheOK() {
}

void objectCaching_CacheOK::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sobjectCaching_CacheOK", pfx);
	_log(l_type, "%sObject of type objectCaching.CacheOK:", pfx);
	_log(l_type, "%sexception_string='%s'", pfx, exception_string.c_str());
}

PyRepObject *objectCaching_CacheOK::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepTuple *tuple2 = new PyRepTuple(1);
	tuple2->items[0] = new PyRepString(exception_string);
	dict1_0 = tuple2;
	
	dict1->items[
		new PyRepString("args")
	] = dict1_0;
	args0 = dict1;
	
	res = new PyRepObject(
			"objectCaching.CacheOK",
			args0
		);
	

	return(res);
}

PyRepObject *objectCaching_CacheOK::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	PyRepTuple *tuple2 = new PyRepTuple(1);
	tuple2->items[0] = new PyRepString(exception_string);
	dict1_0 = tuple2;
	
	dict1->items[
		new PyRepString("args")
	] = dict1_0;
	args0 = dict1;
	
	res = new PyRepObject(
			"objectCaching.CacheOK",
			args0
		);
	

	return(res);
}

bool objectCaching_CacheOK::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool objectCaching_CacheOK::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CacheOK failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "objectCaching.CacheOK") {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CacheOK failed: obj_0 is the wrong object type. Expected 'objectCaching.CacheOK', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CacheOK failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_args_tuple = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode objectCaching_CacheOK failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "args") {
			dict1_args_tuple = true;
	if(!dict1_cur->second->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CacheOK failed: tuple2 is the wrong type: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) dict1_cur->second;
	if(tuple2->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CacheOK failed: tuple2 is the wrong size: expected 1, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CacheOK failed: exception_string is not a string: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_3 = (PyRepString *) tuple2->items[0];
	exception_string = string_3->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode objectCaching_CacheOK failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_args_tuple) {
		_log(NET__PACKET_ERROR, "Decode objectCaching_CacheOK failed: Missing dict entry for 'args_tuple' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

objectCaching_CacheOK *objectCaching_CacheOK::Clone() const {
	objectCaching_CacheOK *res = new objectCaching_CacheOK;
	res->CloneFrom(this);
	return(res);
}

void objectCaching_CacheOK::CloneFrom(const objectCaching_CacheOK *from) {
	/* object of type objectCaching.CacheOK */
	exception_string = from->exception_string;
	
}



