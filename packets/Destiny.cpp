/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/


#include <string>
#include "../packets/Destiny.h"
#include "../common/PyRep.h"




Notify_DoDestinyUpdates::Notify_DoDestinyUpdates() {
	/*  0: list of DoDestinyUpdateMain  */
}

Notify_DoDestinyUpdates::~Notify_DoDestinyUpdates() {
	/*  0: list of DoDestinyUpdateMain  */
}

void Notify_DoDestinyUpdates::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sNotify_DoDestinyUpdates", pfx);
	/*  0: list of DoDestinyUpdateMain  */
	_log(l_type, "%supdates: ", pfx);
	std::string updates_n(pfx);
	updates_n += "    ";
	updates.Dump(l_type, updates_n.c_str());
}

PyRepTuple *Notify_DoDestinyUpdates::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0: list of DoDestinyUpdateMain  */
	tuple0->items[0] = updates.Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *Notify_DoDestinyUpdates::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(1);
	/*  0: list of DoDestinyUpdateMain  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = updates.items;
	updates.items.clear();
	tuple0->items[0] = list1;
	res = tuple0;
	

	return(res);
}

bool Notify_DoDestinyUpdates::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool Notify_DoDestinyUpdates::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode Notify_DoDestinyUpdates failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode Notify_DoDestinyUpdates failed: tuple0 is the wrong size: expected 1, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: list of DoDestinyUpdateMain  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode Notify_DoDestinyUpdates failed: updates is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_updates = (PyRepList *) tuple0->items[0];	updates.items = list_updates->items;
	list_updates->items.clear();
	

	delete packet;
	return(true);
}

Notify_DoDestinyUpdates *Notify_DoDestinyUpdates::Clone() const {
	Notify_DoDestinyUpdates *res = new Notify_DoDestinyUpdates;
	res->CloneFrom(this);
	return(res);
}

void Notify_DoDestinyUpdates::CloneFrom(const Notify_DoDestinyUpdates *from) {
	/*  0: list of DoDestinyUpdateMain  */
	updates.CloneFrom(&from->updates);
	
}


DoDestinyUpdateMain::DoDestinyUpdateMain() {
	/*  0: list of DoDestinyAction  */
	/*  1  */
	waitForBubble = false;
	/*  2: this is a list of dogma events, like used in OnMultiEvent  */
}

DoDestinyUpdateMain::~DoDestinyUpdateMain() {
	/*  0: list of DoDestinyAction  */
	/*  1  */
	/*  2: this is a list of dogma events, like used in OnMultiEvent  */
}

void DoDestinyUpdateMain::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestinyUpdateMain", pfx);
	/*  0: list of DoDestinyAction  */
	_log(l_type, "%supdates: ", pfx);
	std::string updates_n(pfx);
	updates_n += "    ";
	updates.Dump(l_type, updates_n.c_str());
	/*  1  */
	_log(l_type, "%swaitForBubble=%s", pfx, waitForBubble?"true":"false");
	/*  2: this is a list of dogma events, like used in OnMultiEvent  */
	_log(l_type, "%sevents: ", pfx);
	std::string events_n(pfx);
	events_n += "    ";
	events.Dump(l_type, events_n.c_str());
}

PyRepTuple *DoDestinyUpdateMain::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0: list of DoDestinyAction  */
	tuple0->items[0] = updates.Clone();
	/*  1  */
	tuple0->items[1] = new PyRepBoolean(waitForBubble);
	/*  2: this is a list of dogma events, like used in OnMultiEvent  */
	if(events.empty()) {
		tuple0->items[2] = new PyRepNone();
	} else {
	tuple0->items[2] = events.Clone();
	}
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestinyUpdateMain::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0: list of DoDestinyAction  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = updates.items;
	updates.items.clear();
	tuple0->items[0] = list1;
	/*  1  */
	tuple0->items[1] = new PyRepBoolean(waitForBubble);
	/*  2: this is a list of dogma events, like used in OnMultiEvent  */
	if(events.empty()) {
		tuple0->items[2] = new PyRepNone();
	} else {
	
	PyRepList *list2 = new PyRepList();
	list2->items = events.items;
	events.items.clear();
	tuple0->items[2] = list2;
	}
	res = tuple0;
	

	return(res);
}

bool DoDestinyUpdateMain::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestinyUpdateMain::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyUpdateMain failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyUpdateMain failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: list of DoDestinyAction  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyUpdateMain failed: updates is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_updates = (PyRepList *) tuple0->items[0];	updates.items = list_updates->items;
	list_updates->items.clear();
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyUpdateMain failed: waitForBubble is not a boolean: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_1 = (PyRepBoolean *) tuple0->items[1];
	waitForBubble = bool_1->value;
	/*  2: this is a list of dogma events, like used in OnMultiEvent  */
	if(tuple0->items[2]->CheckType(PyRep::None)) {
		events.clear();
	} else {
	if(!tuple0->items[2]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyUpdateMain failed: events is not a list: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_events = (PyRepList *) tuple0->items[2];	events.items = list_events->items;
	list_events->items.clear();
	
	}

	delete packet;
	return(true);
}

DoDestinyUpdateMain *DoDestinyUpdateMain::Clone() const {
	DoDestinyUpdateMain *res = new DoDestinyUpdateMain;
	res->CloneFrom(this);
	return(res);
}

void DoDestinyUpdateMain::CloneFrom(const DoDestinyUpdateMain *from) {
	/*  0: list of DoDestinyAction  */
	updates.CloneFrom(&from->updates);
	/*  1  */
	waitForBubble = from->waitForBubble;
	/*  2: this is a list of dogma events, like used in OnMultiEvent  */
	events.CloneFrom(&from->events);
	
}

	/*  same call as above, completely omitting the events arg.  */

DoDestinyUpdateMain_2::DoDestinyUpdateMain_2() {
	/*  0: list of DoDestinyAction  */
	/*  1  */
	waitForBubble = false;
}

DoDestinyUpdateMain_2::~DoDestinyUpdateMain_2() {
	/*  0: list of DoDestinyAction  */
	/*  1  */
}

void DoDestinyUpdateMain_2::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestinyUpdateMain_2", pfx);
	/*  0: list of DoDestinyAction  */
	_log(l_type, "%supdates: ", pfx);
	std::string updates_n(pfx);
	updates_n += "    ";
	updates.Dump(l_type, updates_n.c_str());
	/*  1  */
	_log(l_type, "%swaitForBubble=%s", pfx, waitForBubble?"true":"false");
}

PyRepTuple *DoDestinyUpdateMain_2::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: list of DoDestinyAction  */
	tuple0->items[0] = updates.Clone();
	/*  1  */
	tuple0->items[1] = new PyRepBoolean(waitForBubble);
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestinyUpdateMain_2::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: list of DoDestinyAction  */
	
	PyRepList *list1 = new PyRepList();
	list1->items = updates.items;
	updates.items.clear();
	tuple0->items[0] = list1;
	/*  1  */
	tuple0->items[1] = new PyRepBoolean(waitForBubble);
	res = tuple0;
	

	return(res);
}

bool DoDestinyUpdateMain_2::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestinyUpdateMain_2::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyUpdateMain_2 failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyUpdateMain_2 failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: list of DoDestinyAction  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyUpdateMain_2 failed: updates is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_updates = (PyRepList *) tuple0->items[0];	updates.items = list_updates->items;
	list_updates->items.clear();
	
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyUpdateMain_2 failed: waitForBubble is not a boolean: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_1 = (PyRepBoolean *) tuple0->items[1];
	waitForBubble = bool_1->value;

	delete packet;
	return(true);
}

DoDestinyUpdateMain_2 *DoDestinyUpdateMain_2::Clone() const {
	DoDestinyUpdateMain_2 *res = new DoDestinyUpdateMain_2;
	res->CloneFrom(this);
	return(res);
}

void DoDestinyUpdateMain_2::CloneFrom(const DoDestinyUpdateMain_2 *from) {
	/*  0: list of DoDestinyAction  */
	updates.CloneFrom(&from->updates);
	/*  1  */
	waitForBubble = from->waitForBubble;
	
}


DoDestinyAction::DoDestinyAction() {
	/*  stamp  */
	update_id = 0;
	/*  event  */
	update = NULL;
}

DoDestinyAction::~DoDestinyAction() {
	/*  stamp  */
	/*  event  */
	delete update;
}

void DoDestinyAction::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestinyAction", pfx);
	/*  stamp  */
	_log(l_type, "%supdate_id=%lu", pfx, update_id);
	/*  event  */
	_log(l_type, "%supdate:", pfx);
	std::string update_n(pfx);
	update_n += "    ";
	if(update == NULL) {
		_log(l_type, "%sERROR: NULL REP!", update_n.c_str());
	} else {
		update->Dump(l_type, update_n.c_str());
	}
}

PyRepTuple *DoDestinyAction::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  stamp  */
	tuple0->items[0] = new PyRepInteger(update_id);
	/*  event  */
	if(update == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestinyAction: update is NULL! hacking in a PyRepNone");
		update = new PyRepNone();
	}
	tuple0->items[1] = update->Clone();
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestinyAction::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  stamp  */
	tuple0->items[0] = new PyRepInteger(update_id);
	/*  event  */
	if(update == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestinyAction: update is NULL! hacking in a PyRepNone");
		update = new PyRepNone();
	}
	tuple0->items[1] = update;
	update = NULL;
	res = tuple0;
	

	return(res);
}

bool DoDestinyAction::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestinyAction::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyAction failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyAction failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  stamp  */
	if(!tuple0->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyAction failed: update_id is not an int: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_1 = (PyRepInteger *) tuple0->items[0];
	if(int_1->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestinyAction: truncating 64 bit into into 32 bit int for field update_id");
	}
	update_id = int_1->value;
	/*  event  */
	delete update;
	update = tuple0->items[1];
	tuple0->items[1] = NULL;
	

	delete packet;
	return(true);
}

DoDestinyAction *DoDestinyAction::Clone() const {
	DoDestinyAction *res = new DoDestinyAction;
	res->CloneFrom(this);
	return(res);
}

void DoDestinyAction::CloneFrom(const DoDestinyAction *from) {
	/*  stamp  */
	update_id = from->update_id;
	/*  event  */
	delete update;
	if(from->update == NULL) {
		update = NULL;
	} else {
		update = from->update->Clone();
	}
	
}


DoDestiny_SlimItem::DoDestiny_SlimItem() {
	/* object of type foo.SlimItem */
	bounty = 0;
	ownerID = 0;
	charID = 0;
	/* 		  <InlineList>
		    <InlineTuple>
			  <int name="integer10" />
			  <int name="integer11" />
		    </InlineTuple>
		    <InlineTuple>
			  <int name="integer12" />
			  <int name="integer13" />
		    </InlineTuple>

		  </InlineList>
 */
	securityStatus = 0.0;
	itemID = 0;
	typeID = 0;
	allianceID = 0;
	corpID = 0;
}

DoDestiny_SlimItem::~DoDestiny_SlimItem() {
	/* 		  <InlineList>
		    <InlineTuple>
			  <int name="integer10" />
			  <int name="integer11" />
		    </InlineTuple>
		    <InlineTuple>
			  <int name="integer12" />
			  <int name="integer13" />
		    </InlineTuple>

		  </InlineList>
 */
}

void DoDestiny_SlimItem::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SlimItem", pfx);
	_log(l_type, "%sObject of type foo.SlimItem:", pfx);
	_log(l_type, "%sbounty=%lu", pfx, bounty);
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	_log(l_type, "%scharID=%lu", pfx, charID);
	_log(l_type, "%smodules: Integer list with %d enetires", pfx, modules.size());
	std::vector<uint32>::const_iterator modules_cur, modules_end;
	modules_cur = modules.begin();
	modules_end = modules.end();
	int modules_index;
	for(modules_index = 0; modules_cur != modules_end; modules_cur++, modules_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, modules_index, *modules_cur);
	}
	
	/* 		  <InlineList>
		    <InlineTuple>
			  <int name="integer10" />
			  <int name="integer11" />
		    </InlineTuple>
		    <InlineTuple>
			  <int name="integer12" />
			  <int name="integer13" />
		    </InlineTuple>

		  </InlineList>
 */
	_log(l_type, "%ssecurityStatus=%.13f", pfx, securityStatus);
	_log(l_type, "%sitemID=%lu", pfx, itemID);
	_log(l_type, "%stypeID=%lu", pfx, typeID);
	_log(l_type, "%sallianceID=%lu", pfx, allianceID);
	_log(l_type, "%scorpID=%lu", pfx, corpID);
}

PyRepObject *DoDestiny_SlimItem::Encode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepInteger(bounty);
	dict1->items[
		new PyRepString("bounty")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepInteger(ownerID);
	dict1->items[
		new PyRepString("ownerID")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepInteger(charID);
	dict1->items[
		new PyRepString("charID")
	] = dict1_2;
	PyRep *dict1_3;
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator modules_cur, modules_end;
	modules_cur = modules.begin();
	modules_end = modules.end();
	for(; modules_cur != modules_end; modules_cur++) {
		list2->items.push_back(
			new PyRepInteger(*modules_cur)
		);
	}
	dict1_3 = list2;
	
	/* 		  <InlineList>
		    <InlineTuple>
			  <int name="integer10" />
			  <int name="integer11" />
		    </InlineTuple>
		    <InlineTuple>
			  <int name="integer12" />
			  <int name="integer13" />
		    </InlineTuple>

		  </InlineList>
 */
	dict1->items[
		new PyRepString("modules")
	] = dict1_3;
	PyRep *dict1_4;
	dict1_4 = new PyRepReal(securityStatus);
	dict1->items[
		new PyRepString("securityStatus")
	] = dict1_4;
	PyRep *dict1_5;
	dict1_5 = new PyRepInteger(itemID);
	dict1->items[
		new PyRepString("itemID")
	] = dict1_5;
	PyRep *dict1_6;
	dict1_6 = new PyRepInteger(typeID);
	dict1->items[
		new PyRepString("typeID")
	] = dict1_6;
	PyRep *dict1_7;
	dict1_7 = new PyRepInteger(allianceID);
	dict1->items[
		new PyRepString("allianceID")
	] = dict1_7;
	PyRep *dict1_8;
	dict1_8 = new PyRepInteger(corpID);
	dict1->items[
		new PyRepString("corpID")
	] = dict1_8;
	args0 = dict1;
	
	res = new PyRepObject(
			"foo.SlimItem",
			args0
		);
	

	return(res);
}

PyRepObject *DoDestiny_SlimItem::FastEncode() {
	PyRepObject *res = NULL;
	PyRep *args0;
	PyRepDict *dict1 = new PyRepDict();
	PyRep *dict1_0;
	dict1_0 = new PyRepInteger(bounty);
	dict1->items[
		new PyRepString("bounty")
	] = dict1_0;
	PyRep *dict1_1;
	dict1_1 = new PyRepInteger(ownerID);
	dict1->items[
		new PyRepString("ownerID")
	] = dict1_1;
	PyRep *dict1_2;
	dict1_2 = new PyRepInteger(charID);
	dict1->items[
		new PyRepString("charID")
	] = dict1_2;
	PyRep *dict1_3;
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator modules_cur, modules_end;
	modules_cur = modules.begin();
	modules_end = modules.end();
	for(; modules_cur != modules_end; modules_cur++) {
		list2->items.push_back(
			new PyRepInteger(*modules_cur)
		);
	}
	dict1_3 = list2;
	
	/* 		  <InlineList>
		    <InlineTuple>
			  <int name="integer10" />
			  <int name="integer11" />
		    </InlineTuple>
		    <InlineTuple>
			  <int name="integer12" />
			  <int name="integer13" />
		    </InlineTuple>

		  </InlineList>
 */
	dict1->items[
		new PyRepString("modules")
	] = dict1_3;
	PyRep *dict1_4;
	dict1_4 = new PyRepReal(securityStatus);
	dict1->items[
		new PyRepString("securityStatus")
	] = dict1_4;
	PyRep *dict1_5;
	dict1_5 = new PyRepInteger(itemID);
	dict1->items[
		new PyRepString("itemID")
	] = dict1_5;
	PyRep *dict1_6;
	dict1_6 = new PyRepInteger(typeID);
	dict1->items[
		new PyRepString("typeID")
	] = dict1_6;
	PyRep *dict1_7;
	dict1_7 = new PyRepInteger(allianceID);
	dict1->items[
		new PyRepString("allianceID")
	] = dict1_7;
	PyRep *dict1_8;
	dict1_8 = new PyRepInteger(corpID);
	dict1->items[
		new PyRepString("corpID")
	] = dict1_8;
	args0 = dict1;
	
	res = new PyRepObject(
			"foo.SlimItem",
			args0
		);
	

	return(res);
}

bool DoDestiny_SlimItem::Decode(PyRepObject **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SlimItem::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: obj_0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_0 = (PyRepObject *) packet;
	
	if(obj_0->type != "foo.SlimItem") {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: obj_0 is the wrong object type. Expected 'foo.SlimItem', got '%s'", obj_0->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_0->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: dict1 is the wrong type: %s", obj_0->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict1_bounty = false;
	bool dict1_ownerID = false;
	bool dict1_charID = false;
	bool dict1_modules = false;
	bool dict1_securityStatus = false;
	bool dict1_itemID = false;
	bool dict1_typeID = false;
	bool dict1_allianceID = false;
	bool dict1_corpID = false;
	PyRepDict *dict1 = (PyRepDict *) obj_0->arguments;
	
	PyRepDict::iterator dict1_cur, dict1_end;
	dict1_cur = dict1->items.begin();
	dict1_end = dict1->items.end();
	for(; dict1_cur != dict1_end; dict1_cur++) {
		PyRep *key__ = dict1_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: a key in dict1 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "bounty") {
			dict1_bounty = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: bounty is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_2 = (PyRepInteger *) dict1_cur->second;
	if(int_2->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SlimItem: truncating 64 bit into into 32 bit int for field bounty");
	}
	bounty = int_2->value;
		} else
		if(key_string__->value == "ownerID") {
			dict1_ownerID = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: ownerID is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) dict1_cur->second;
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SlimItem: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_3->value;
		} else
		if(key_string__->value == "charID") {
			dict1_charID = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: charID is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) dict1_cur->second;
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SlimItem: truncating 64 bit into into 32 bit int for field charID");
	}
	charID = int_4->value;
		} else
		if(key_string__->value == "modules") {
			dict1_modules = true;
	if(!dict1_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: modules is not a list: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	modules.clear();
	PyRepList *list_5 = (PyRepList *) dict1_cur->second;
	PyRepList::iterator modules_cur, modules_end;
	modules_cur = list_5->items.begin();
	modules_end = list_5->items.end();
	int modules_index;
	for(modules_index = 0; modules_cur != modules_end; modules_cur++, modules_index++) {
		if(!(*modules_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Element %d in list modules is not an integer: %s", modules_index, (*modules_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*modules_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode DoDestiny_SlimItem: truncating 64 bit into into 32 bit int for item %d in field modules", modules_index);
		}
		modules.push_back(t->value);
	}

	/* 		  <InlineList>
		    <InlineTuple>
			  <int name="integer10" />
			  <int name="integer11" />
		    </InlineTuple>
		    <InlineTuple>
			  <int name="integer12" />
			  <int name="integer13" />
		    </InlineTuple>

		  </InlineList>
 */
		} else
		if(key_string__->value == "securityStatus") {
			dict1_securityStatus = true;
	if(!dict1_cur->second->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: securityStatus is not a real: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) dict1_cur->second;
	securityStatus = real_6->value;
		} else
		if(key_string__->value == "itemID") {
			dict1_itemID = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: itemID is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) dict1_cur->second;
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SlimItem: truncating 64 bit into into 32 bit int for field itemID");
	}
	itemID = int_7->value;
		} else
		if(key_string__->value == "typeID") {
			dict1_typeID = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: typeID is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) dict1_cur->second;
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SlimItem: truncating 64 bit into into 32 bit int for field typeID");
	}
	typeID = int_8->value;
		} else
		if(key_string__->value == "allianceID") {
			dict1_allianceID = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: allianceID is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) dict1_cur->second;
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SlimItem: truncating 64 bit into into 32 bit int for field allianceID");
	}
	allianceID = int_9->value;
		} else
		if(key_string__->value == "corpID") {
			dict1_corpID = true;
	if(!dict1_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: corpID is not an int: %s", dict1_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) dict1_cur->second;
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SlimItem: truncating 64 bit into into 32 bit int for field corpID");
	}
	corpID = int_10->value;
		} else
		{
			_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Unknown key string '%s' in dict1", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict1_bounty) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Missing dict entry for 'bounty' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_ownerID) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Missing dict entry for 'ownerID' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_charID) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Missing dict entry for 'charID' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_modules) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Missing dict entry for 'modules' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_securityStatus) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Missing dict entry for 'securityStatus' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_itemID) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Missing dict entry for 'itemID' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_typeID) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Missing dict entry for 'typeID' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_allianceID) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Missing dict entry for 'allianceID' in dict1");
		delete packet;
		return(false);
	}
	
	if(!dict1_corpID) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SlimItem failed: Missing dict entry for 'corpID' in dict1");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

DoDestiny_SlimItem *DoDestiny_SlimItem::Clone() const {
	DoDestiny_SlimItem *res = new DoDestiny_SlimItem;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SlimItem::CloneFrom(const DoDestiny_SlimItem *from) {
	/* object of type foo.SlimItem */
	bounty = from->bounty;
	ownerID = from->ownerID;
	charID = from->charID;
	modules = from->modules;
	/* 		  <InlineList>
		    <InlineTuple>
			  <int name="integer10" />
			  <int name="integer11" />
		    </InlineTuple>
		    <InlineTuple>
			  <int name="integer12" />
			  <int name="integer13" />
		    </InlineTuple>

		  </InlineList>
 */
	securityStatus = from->securityStatus;
	itemID = from->itemID;
	typeID = from->typeID;
	allianceID = from->allianceID;
	corpID = from->corpID;
	
}


DoDestiny_AddBall::DoDestiny_AddBall() {
	/*  0: funcName  */
	update_name = "AddBalls";
	/*  1: args  */
	/*  0  */
	/*  0  */
	destiny_binary = "";
	/*  1: slims (hard coded to 1 right now)  */
	/*  0  */
	/*  <element name="slim" type="DoDestiny_SlimItem" /> */
	slim = NULL;
	/*  2  */
}

DoDestiny_AddBall::~DoDestiny_AddBall() {
	/*  0: funcName  */
	/*  1: args  */
	/*  0  */
	/*  0  */
	/*  1: slims (hard coded to 1 right now)  */
	/*  0  */
	/*  <element name="slim" type="DoDestiny_SlimItem" /> */
	delete slim;
	/*  2  */
	std::map<uint32, PyRep *>::iterator damages_cur, damages_end;
	//free any existing elements first
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		delete damages_cur->second;
	}
	
}

void DoDestiny_AddBall::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_AddBall", pfx);
	/*  0: funcName  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1: args  */
	/*  0  */
	/*  0  */
	_log(l_type, "%sdestiny_binary='%s'", pfx, destiny_binary.c_str());
	/*  1: slims (hard coded to 1 right now)  */
	/*  0  */
	/*  <element name="slim" type="DoDestiny_SlimItem" /> */
	_log(l_type, "%sslim:", pfx);
	std::string slim_n(pfx);
	slim_n += "    ";
	if(slim == NULL) {
		_log(l_type, "%sERROR: NULL REP!", slim_n.c_str());
	} else {
		slim->Dump(l_type, slim_n.c_str());
	}
	/*  2  */
	_log(l_type, "%sdamages: Dictionaty with %d enetires", pfx, damages.size());
	std::map<uint32, PyRep *>::const_iterator damages_cur, damages_end;
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, damages_cur->first);
		std::string n(pfx);
		n += "        ";
		damages_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *DoDestiny_AddBall::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: funcName  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1: args  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(3);
	/*  0  */
	tuple2->items[0] = new PyRepString(destiny_binary);
	/*  1: slims (hard coded to 1 right now)  */
	PyRepList *list3 = new PyRepList();
	list3->items.resize(1, NULL);
	/*  0  */
	/*  <element name="slim" type="DoDestiny_SlimItem" /> */
	if(slim == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_AddBall: slim is NULL! hacking in a PyRepNone");
		slim = new PyRepNone();
	}
	list3->items[0] = slim->Clone();
	tuple2->items[1] = list3;
	
	/*  2  */
	
	PyRepDict *dict4 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator damages_cur, damages_end;
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		dict4->items[
			new PyRepInteger(damages_cur->first)
		] = damages_cur->second->Clone();
	}
	tuple2->items[2] = dict4;
	
	tuple1->items[0] = tuple2;
	
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_AddBall::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: funcName  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1: args  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(3);
	/*  0  */
	tuple2->items[0] = new PyRepString(destiny_binary);
	/*  1: slims (hard coded to 1 right now)  */
	PyRepList *list3 = new PyRepList();
	list3->items.resize(1, NULL);
	/*  0  */
	/*  <element name="slim" type="DoDestiny_SlimItem" /> */
	if(slim == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_AddBall: slim is NULL! hacking in a PyRepNone");
		slim = new PyRepNone();
	}
	list3->items[0] = slim;
	slim = NULL;
	tuple2->items[1] = list3;
	
	/*  2  */
	
	PyRepDict *dict4 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator damages_cur, damages_end;
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		dict4->items[
			new PyRepInteger(damages_cur->first)
		] = damages_cur->second;
	}
	damages.clear();
	tuple2->items[2] = dict4;
	
	tuple1->items[0] = tuple2;
	
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_AddBall::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_AddBall::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: funcName  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1: args  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: tuple2 is the wrong size: expected 1, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: tuple3 is the wrong type: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple3 = (PyRepTuple *) tuple2->items[0];
	if(tuple3->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: tuple3 is the wrong size: expected 3, but got %d", tuple3->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple3->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: destiny_binary is not a string: %s", tuple3->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_4 = (PyRepString *) tuple3->items[0];
	destiny_binary = string_4->value;
	/*  1: slims (hard coded to 1 right now)  */
	if(!tuple3->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: list5 is not a list: %s", tuple3->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list5 = (PyRepList *) tuple3->items[1];
	if(list5->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: list5 is the wrong size: expected 1, but got %d", list5->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	/*  <element name="slim" type="DoDestiny_SlimItem" /> */
	delete slim;
	slim = list5->items[0];
	list5->items[0] = NULL;
	
	/*  2  */
	if(!tuple3->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: damages is not a dict: %s", tuple3->items[2]->TypeString());
		delete packet;
		return(false);
	}
	damages.clear();
	PyRepDict *dict_6 = (PyRepDict *) tuple3->items[2];
	PyRepDict::iterator damages_cur, damages_end;
	damages_cur = dict_6->items.begin();
	damages_end = dict_6->items.end();
	int damages_index;
	for(damages_index = 0; damages_cur != damages_end; damages_cur++, damages_index++) {
		if(!damages_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBall failed: Key %d in dict damages is not an integer: %s", damages_index, damages_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) damages_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode DoDestiny_AddBall: truncating 64 bit into into 32 bit int in key of entry %d in field damages", damages_index);
		}
		damages[k->value] = damages_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

DoDestiny_AddBall *DoDestiny_AddBall::Clone() const {
	DoDestiny_AddBall *res = new DoDestiny_AddBall;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_AddBall::CloneFrom(const DoDestiny_AddBall *from) {
	/*  0: funcName  */
	update_name = from->update_name;
	/*  1: args  */
	/*  0  */
	/*  0  */
	destiny_binary = from->destiny_binary;
	/*  1: slims (hard coded to 1 right now)  */
	/*  0  */
	/*  <element name="slim" type="DoDestiny_SlimItem" /> */
	delete slim;
	if(from->slim == NULL) {
		slim = NULL;
	} else {
		slim = from->slim->Clone();
	}
	/*  2  */
	std::map<uint32, PyRep *>::const_iterator damages_cur, damages_end;
	//free any existing elements first
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		delete damages_cur->second;
	}
	damages.clear();
	//now we can copy in the new ones...
	damages_cur = from->damages.begin();
	damages_end = from->damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		damages[damages_cur->first] = damages_cur->second->Clone();
	}
	
	
}


DoDestiny_AddBalls::DoDestiny_AddBalls() {
	/*  0  */
	update_name = "AddBalls";
	/*  1  */
	/*  0  */
	/*  0  */
	destiny_binary = NULL;
	/*  1: slims (list of DoDestiny_SlimItem)  */
	/*  2  */
}

DoDestiny_AddBalls::~DoDestiny_AddBalls() {
	/*  0  */
	/*  1  */
	/*  0  */
	/*  0  */
	delete destiny_binary;
	/*  1: slims (list of DoDestiny_SlimItem)  */
	/*  2  */
	std::map<uint32, PyRep *>::iterator damages_cur, damages_end;
	//free any existing elements first
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		delete damages_cur->second;
	}
	
}

void DoDestiny_AddBalls::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_AddBalls", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0  */
	/*  0  */
	_log(l_type, "%sdestiny_binary: ", pfx);
	std::string destiny_binary_n(pfx);
	destiny_binary_n += "    ";
	destiny_binary->Dump(l_type, destiny_binary_n.c_str());
	/*  1: slims (list of DoDestiny_SlimItem)  */
	_log(l_type, "%sslims: ", pfx);
	std::string slims_n(pfx);
	slims_n += "    ";
	slims.Dump(l_type, slims_n.c_str());
	/*  2  */
	_log(l_type, "%sdamages: Dictionaty with %d enetires", pfx, damages.size());
	std::map<uint32, PyRep *>::const_iterator damages_cur, damages_end;
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, damages_cur->first);
		std::string n(pfx);
		n += "        ";
		damages_cur->second->Dump(stdout, n.c_str());
	}
	
}

PyRepTuple *DoDestiny_AddBalls::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(3);
	/*  0  */
	if(destiny_binary == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_AddBalls: destiny_binary is NULL! hacking in an empty buffer.");
		destiny_binary = new PyRepBuffer(0);
	}
	tuple2->items[0] = destiny_binary->Clone();
	/*  1: slims (list of DoDestiny_SlimItem)  */
	tuple2->items[1] = slims.Clone();
	/*  2  */
	
	PyRepDict *dict3 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator damages_cur, damages_end;
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		dict3->items[
			new PyRepInteger(damages_cur->first)
		] = damages_cur->second->Clone();
	}
	tuple2->items[2] = dict3;
	
	tuple1->items[0] = tuple2;
	
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_AddBalls::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	PyRepTuple *tuple2 = new PyRepTuple(3);
	/*  0  */
	if(destiny_binary == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_AddBalls: destiny_binary is NULL! hacking in an empty buffer.");
		destiny_binary = new PyRepBuffer(0);
	}
	tuple2->items[0] = destiny_binary;
	destiny_binary = NULL;
	/*  1: slims (list of DoDestiny_SlimItem)  */
	
	PyRepList *list3 = new PyRepList();
	list3->items = slims.items;
	slims.items.clear();
	tuple2->items[1] = list3;
	/*  2  */
	
	PyRepDict *dict4 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator damages_cur, damages_end;
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		dict4->items[
			new PyRepInteger(damages_cur->first)
		] = damages_cur->second;
	}
	damages.clear();
	tuple2->items[2] = dict4;
	
	tuple1->items[0] = tuple2;
	
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_AddBalls::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_AddBalls::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: tuple2 is the wrong size: expected 1, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: tuple3 is the wrong type: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple3 = (PyRepTuple *) tuple2->items[0];
	if(tuple3->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: tuple3 is the wrong size: expected 3, but got %d", tuple3->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(tuple3->items[0]->CheckType(PyRep::Buffer)) {
		destiny_binary = (PyRepBuffer *) tuple3->items[0];
		tuple3->items[0] = NULL;
	} else if(tuple3->items[0]->CheckType(PyRep::String)) {
		PyRepString *__sss = (PyRepString *) tuple3->items[0];
		tuple3->items[0] = NULL;
		destiny_binary = new PyRepBuffer((const byte *) __sss->value.c_str(), __sss->value.length());
		delete __sss;
	} else {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: destiny_binary is not a buffer: %s", tuple3->items[0]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  1: slims (list of DoDestiny_SlimItem)  */
	if(!tuple3->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: slims is not a list: %s", tuple3->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_slims = (PyRepList *) tuple3->items[1];	slims.items = list_slims->items;
	list_slims->items.clear();
	
	/*  2  */
	if(!tuple3->items[2]->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: damages is not a dict: %s", tuple3->items[2]->TypeString());
		delete packet;
		return(false);
	}
	damages.clear();
	PyRepDict *dict_4 = (PyRepDict *) tuple3->items[2];
	PyRepDict::iterator damages_cur, damages_end;
	damages_cur = dict_4->items.begin();
	damages_end = dict_4->items.end();
	int damages_index;
	for(damages_index = 0; damages_cur != damages_end; damages_cur++, damages_index++) {
		if(!damages_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_AddBalls failed: Key %d in dict damages is not an integer: %s", damages_index, damages_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) damages_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode DoDestiny_AddBalls: truncating 64 bit into into 32 bit int in key of entry %d in field damages", damages_index);
		}
		damages[k->value] = damages_cur->second->Clone();
	}
	

	delete packet;
	return(true);
}

DoDestiny_AddBalls *DoDestiny_AddBalls::Clone() const {
	DoDestiny_AddBalls *res = new DoDestiny_AddBalls;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_AddBalls::CloneFrom(const DoDestiny_AddBalls *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0  */
	/*  0  */
	delete destiny_binary;
	if(from->destiny_binary == NULL) {
		destiny_binary = NULL;
	} else {
		destiny_binary = from->destiny_binary->TypedClone();
	}
	/*  1: slims (list of DoDestiny_SlimItem)  */
	slims.CloneFrom(&from->slims);
	/*  2  */
	std::map<uint32, PyRep *>::const_iterator damages_cur, damages_end;
	//free any existing elements first
	damages_cur = damages.begin();
	damages_end = damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		delete damages_cur->second;
	}
	damages.clear();
	//now we can copy in the new ones...
	damages_cur = from->damages.begin();
	damages_end = from->damages.end();
	for(; damages_cur != damages_end; damages_cur++) {
		damages[damages_cur->first] = damages_cur->second->Clone();
	}
	
	
}


DoDestiny_OnSpecialFX13::DoDestiny_OnSpecialFX13() {
	/*  0  */
	update_name = "OnSpecialFX";
	/*  1  */
	/*  0: shipID  */
	entityID = 0;
	/*  1: moduleID  */
	moduleID = 0;
	/*  2: moduleTypeID  */
	moduleTypeID = 0;
	/*  3: targetID  */
	targetID = 0;
	/*  4: otherTypeID  */
	otherTypeID = 0;
	/*  5: area, completely unknown contents, prolly not really an intlist  */
	/*  6: guid: see scripts/parklife/fxSequencer.py  */
	effect_type = "";
	/*  7: isOffensive: saw 0  */
	isOffensive = 0;
	/*  8: start: saw 1  */
	start = 0;
	/*  9: active: saw 0  */
	active = 0;
	/*  10: duration in milliseconds (optional)  */
	duration_ms = 0;
	/*  11: repeat (optional) (really defaults to None, but -1 seems to work too)  */
	repeat = 0;
	/*  12: startTime (optional)  */
	startTime = 0;
}

DoDestiny_OnSpecialFX13::~DoDestiny_OnSpecialFX13() {
	/*  0  */
	/*  1  */
	/*  0: shipID  */
	/*  1: moduleID  */
	/*  2: moduleTypeID  */
	/*  3: targetID  */
	/*  4: otherTypeID  */
	/*  5: area, completely unknown contents, prolly not really an intlist  */
	/*  6: guid: see scripts/parklife/fxSequencer.py  */
	/*  7: isOffensive: saw 0  */
	/*  8: start: saw 1  */
	/*  9: active: saw 0  */
	/*  10: duration in milliseconds (optional)  */
	/*  11: repeat (optional) (really defaults to None, but -1 seems to work too)  */
	/*  12: startTime (optional)  */
}

void DoDestiny_OnSpecialFX13::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_OnSpecialFX13", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0: shipID  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1: moduleID  */
	_log(l_type, "%smoduleID=%lu", pfx, moduleID);
	/*  2: moduleTypeID  */
	_log(l_type, "%smoduleTypeID=%lu", pfx, moduleTypeID);
	/*  3: targetID  */
	_log(l_type, "%stargetID=%lu", pfx, targetID);
	/*  4: otherTypeID  */
	_log(l_type, "%sotherTypeID=%lu", pfx, otherTypeID);
	/*  5: area, completely unknown contents, prolly not really an intlist  */
	_log(l_type, "%sarea: Integer list with %d enetires", pfx, area.size());
	std::vector<uint32>::const_iterator area_cur, area_end;
	area_cur = area.begin();
	area_end = area.end();
	int area_index;
	for(area_index = 0; area_cur != area_end; area_cur++, area_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, area_index, *area_cur);
	}
	
	/*  6: guid: see scripts/parklife/fxSequencer.py  */
	_log(l_type, "%seffect_type='%s'", pfx, effect_type.c_str());
	/*  7: isOffensive: saw 0  */
	_log(l_type, "%sisOffensive=%lu", pfx, isOffensive);
	/*  8: start: saw 1  */
	_log(l_type, "%sstart=%lu", pfx, start);
	/*  9: active: saw 0  */
	_log(l_type, "%sactive=%lu", pfx, active);
	/*  10: duration in milliseconds (optional)  */
	_log(l_type, "%sduration_ms=%.13f", pfx, duration_ms);
	/*  11: repeat (optional) (really defaults to None, but -1 seems to work too)  */
	_log(l_type, "%srepeat=%lu", pfx, repeat);
	/*  12: startTime (optional)  */
	_log(l_type, "%sstartTime=" I64u, pfx, startTime);
}

PyRepTuple *DoDestiny_OnSpecialFX13::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(13);
	/*  0: shipID  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1: moduleID  */
	if(moduleID == 0) {
		tuple1->items[1] = new PyRepNone();
	} else {
		tuple1->items[1] = new PyRepInteger(moduleID);
	}
	/*  2: moduleTypeID  */
	if(moduleTypeID == 0) {
		tuple1->items[2] = new PyRepNone();
	} else {
		tuple1->items[2] = new PyRepInteger(moduleTypeID);
	}
	/*  3: targetID  */
	if(targetID == 0) {
		tuple1->items[3] = new PyRepNone();
	} else {
		tuple1->items[3] = new PyRepInteger(targetID);
	}
	/*  4: otherTypeID  */
	if(otherTypeID == 0) {
		tuple1->items[4] = new PyRepNone();
	} else {
		tuple1->items[4] = new PyRepInteger(otherTypeID);
	}
	/*  5: area, completely unknown contents, prolly not really an intlist  */
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator area_cur, area_end;
	area_cur = area.begin();
	area_end = area.end();
	for(; area_cur != area_end; area_cur++) {
		list2->items.push_back(
			new PyRepInteger(*area_cur)
		);
	}
	tuple1->items[5] = list2;
	
	/*  6: guid: see scripts/parklife/fxSequencer.py  */
	tuple1->items[6] = new PyRepString(effect_type);
	/*  7: isOffensive: saw 0  */
	tuple1->items[7] = new PyRepInteger(isOffensive);
	/*  8: start: saw 1  */
	tuple1->items[8] = new PyRepInteger(start);
	/*  9: active: saw 0  */
	tuple1->items[9] = new PyRepInteger(active);
	/*  10: duration in milliseconds (optional)  */
	if(duration_ms == 0) {
		tuple1->items[10] = new PyRepNone();
	} else {
		tuple1->items[10] = new PyRepReal(duration_ms);
	}
	/*  11: repeat (optional) (really defaults to None, but -1 seems to work too)  */
	if(repeat == 0) {
		tuple1->items[11] = new PyRepNone();
	} else {
		tuple1->items[11] = new PyRepInteger(repeat);
	}
	/*  12: startTime (optional)  */
	if(startTime == 0) {
		tuple1->items[12] = new PyRepNone();
	} else {
		tuple1->items[12] = new PyRepInteger(startTime);
	}
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_OnSpecialFX13::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(13);
	/*  0: shipID  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1: moduleID  */
	if(moduleID == 0) {
		tuple1->items[1] = new PyRepNone();
	} else {
		tuple1->items[1] = new PyRepInteger(moduleID);
	}
	/*  2: moduleTypeID  */
	if(moduleTypeID == 0) {
		tuple1->items[2] = new PyRepNone();
	} else {
		tuple1->items[2] = new PyRepInteger(moduleTypeID);
	}
	/*  3: targetID  */
	if(targetID == 0) {
		tuple1->items[3] = new PyRepNone();
	} else {
		tuple1->items[3] = new PyRepInteger(targetID);
	}
	/*  4: otherTypeID  */
	if(otherTypeID == 0) {
		tuple1->items[4] = new PyRepNone();
	} else {
		tuple1->items[4] = new PyRepInteger(otherTypeID);
	}
	/*  5: area, completely unknown contents, prolly not really an intlist  */
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator area_cur, area_end;
	area_cur = area.begin();
	area_end = area.end();
	for(; area_cur != area_end; area_cur++) {
		list2->items.push_back(
			new PyRepInteger(*area_cur)
		);
	}
	tuple1->items[5] = list2;
	
	/*  6: guid: see scripts/parklife/fxSequencer.py  */
	tuple1->items[6] = new PyRepString(effect_type);
	/*  7: isOffensive: saw 0  */
	tuple1->items[7] = new PyRepInteger(isOffensive);
	/*  8: start: saw 1  */
	tuple1->items[8] = new PyRepInteger(start);
	/*  9: active: saw 0  */
	tuple1->items[9] = new PyRepInteger(active);
	/*  10: duration in milliseconds (optional)  */
	if(duration_ms == 0) {
		tuple1->items[10] = new PyRepNone();
	} else {
		tuple1->items[10] = new PyRepReal(duration_ms);
	}
	/*  11: repeat (optional) (really defaults to None, but -1 seems to work too)  */
	if(repeat == 0) {
		tuple1->items[11] = new PyRepNone();
	} else {
		tuple1->items[11] = new PyRepInteger(repeat);
	}
	/*  12: startTime (optional)  */
	if(startTime == 0) {
		tuple1->items[12] = new PyRepNone();
	} else {
		tuple1->items[12] = new PyRepInteger(startTime);
	}
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_OnSpecialFX13::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_OnSpecialFX13::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 13) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: tuple2 is the wrong size: expected 13, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0: shipID  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  1: moduleID  */
	if(tuple2->items[1]->CheckType(PyRep::None)) {
		moduleID = 0;
	} else {
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: moduleID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for field moduleID");
	}
	moduleID = int_4->value;
	}
	/*  2: moduleTypeID  */
	if(tuple2->items[2]->CheckType(PyRep::None)) {
		moduleTypeID = 0;
	} else {
	if(!tuple2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: moduleTypeID is not an int: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for field moduleTypeID");
	}
	moduleTypeID = int_5->value;
	}
	/*  3: targetID  */
	if(tuple2->items[3]->CheckType(PyRep::None)) {
		targetID = 0;
	} else {
	if(!tuple2->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: targetID is not an int: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple2->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for field targetID");
	}
	targetID = int_6->value;
	}
	/*  4: otherTypeID  */
	if(tuple2->items[4]->CheckType(PyRep::None)) {
		otherTypeID = 0;
	} else {
	if(!tuple2->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: otherTypeID is not an int: %s", tuple2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple2->items[4];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for field otherTypeID");
	}
	otherTypeID = int_7->value;
	}
	/*  5: area, completely unknown contents, prolly not really an intlist  */
	if(!tuple2->items[5]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: area is not a list: %s", tuple2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	area.clear();
	PyRepList *list_8 = (PyRepList *) tuple2->items[5];
	PyRepList::iterator area_cur, area_end;
	area_cur = list_8->items.begin();
	area_end = list_8->items.end();
	int area_index;
	for(area_index = 0; area_cur != area_end; area_cur++, area_index++) {
		if(!(*area_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: Element %d in list area is not an integer: %s", area_index, (*area_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*area_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for item %d in field area", area_index);
		}
		area.push_back(t->value);
	}

	/*  6: guid: see scripts/parklife/fxSequencer.py  */
	if(!tuple2->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: effect_type is not a string: %s", tuple2->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) tuple2->items[6];
	effect_type = string_9->value;
	/*  7: isOffensive: saw 0  */
	if(!tuple2->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: isOffensive is not an int: %s", tuple2->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) tuple2->items[7];
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for field isOffensive");
	}
	isOffensive = int_10->value;
	/*  8: start: saw 1  */
	if(!tuple2->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: start is not an int: %s", tuple2->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_11 = (PyRepInteger *) tuple2->items[8];
	if(int_11->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for field start");
	}
	start = int_11->value;
	/*  9: active: saw 0  */
	if(!tuple2->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: active is not an int: %s", tuple2->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_12 = (PyRepInteger *) tuple2->items[9];
	if(int_12->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for field active");
	}
	active = int_12->value;
	/*  10: duration in milliseconds (optional)  */
	if(tuple2->items[10]->CheckType(PyRep::None)) {
		duration_ms = 0;
	} else {
	if(!tuple2->items[10]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: duration_ms is not a real: %s", tuple2->items[10]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_13 = (PyRepReal *) tuple2->items[10];
	duration_ms = real_13->value;
	}
	/*  11: repeat (optional) (really defaults to None, but -1 seems to work too)  */
	if(tuple2->items[11]->CheckType(PyRep::None)) {
		repeat = 0;
	} else {
	if(!tuple2->items[11]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: repeat is not an int: %s", tuple2->items[11]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_14 = (PyRepInteger *) tuple2->items[11];
	if(int_14->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX13: truncating 64 bit into into 32 bit int for field repeat");
	}
	repeat = int_14->value;
	}
	/*  12: startTime (optional)  */
	if(tuple2->items[12]->CheckType(PyRep::None)) {
		startTime = 0;
	} else {
	if(!tuple2->items[12]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX13 failed: startTime is not an int: %s", tuple2->items[12]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_15 = (PyRepInteger *) tuple2->items[12];
	startTime = int64_15->value;
	}

	delete packet;
	return(true);
}

DoDestiny_OnSpecialFX13 *DoDestiny_OnSpecialFX13::Clone() const {
	DoDestiny_OnSpecialFX13 *res = new DoDestiny_OnSpecialFX13;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_OnSpecialFX13::CloneFrom(const DoDestiny_OnSpecialFX13 *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0: shipID  */
	entityID = from->entityID;
	/*  1: moduleID  */
	moduleID = from->moduleID;
	/*  2: moduleTypeID  */
	moduleTypeID = from->moduleTypeID;
	/*  3: targetID  */
	targetID = from->targetID;
	/*  4: otherTypeID  */
	otherTypeID = from->otherTypeID;
	/*  5: area, completely unknown contents, prolly not really an intlist  */
	area = from->area;
	/*  6: guid: see scripts/parklife/fxSequencer.py  */
	effect_type = from->effect_type;
	/*  7: isOffensive: saw 0  */
	isOffensive = from->isOffensive;
	/*  8: start: saw 1  */
	start = from->start;
	/*  9: active: saw 0  */
	active = from->active;
	/*  10: duration in milliseconds (optional)  */
	duration_ms = from->duration_ms;
	/*  11: repeat (optional) (really defaults to None, but -1 seems to work too)  */
	repeat = from->repeat;
	/*  12: startTime (optional)  */
	startTime = from->startTime;
	
}


DoDestiny_OnSpecialFX10::DoDestiny_OnSpecialFX10() {
	/*  0  */
	update_name = "OnSpecialFX";
	/*  1  */
	/*  0: shipID  */
	entityID = 0;
	/*  1: moduleID  */
	moduleID = 0;
	/*  2: moduleTypeID  */
	moduleTypeID = 0;
	/*  3: targetID  */
	targetID = 0;
	/*  4: otherTypeID  */
	otherTypeID = 0;
	/*  5: completely unknown contents, prolly not really an intlist  */
	/*  6: see scripts/parklife/fxSequencer.py  */
	effect_type = "effects.Warping";
	/*  7: isOffensive: soft boolean  */
	isOffensive = 0;
	/*  8: start: soft boolean  */
	start = 0;
	/*  9: active: soft boolean  */
	active = 0;
}

DoDestiny_OnSpecialFX10::~DoDestiny_OnSpecialFX10() {
	/*  0  */
	/*  1  */
	/*  0: shipID  */
	/*  1: moduleID  */
	/*  2: moduleTypeID  */
	/*  3: targetID  */
	/*  4: otherTypeID  */
	/*  5: completely unknown contents, prolly not really an intlist  */
	/*  6: see scripts/parklife/fxSequencer.py  */
	/*  7: isOffensive: soft boolean  */
	/*  8: start: soft boolean  */
	/*  9: active: soft boolean  */
}

void DoDestiny_OnSpecialFX10::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_OnSpecialFX10", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0: shipID  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1: moduleID  */
	_log(l_type, "%smoduleID=%lu", pfx, moduleID);
	/*  2: moduleTypeID  */
	_log(l_type, "%smoduleTypeID=%lu", pfx, moduleTypeID);
	/*  3: targetID  */
	_log(l_type, "%stargetID=%lu", pfx, targetID);
	/*  4: otherTypeID  */
	_log(l_type, "%sotherTypeID=%lu", pfx, otherTypeID);
	/*  5: completely unknown contents, prolly not really an intlist  */
	_log(l_type, "%sarea: Integer list with %d enetires", pfx, area.size());
	std::vector<uint32>::const_iterator area_cur, area_end;
	area_cur = area.begin();
	area_end = area.end();
	int area_index;
	for(area_index = 0; area_cur != area_end; area_cur++, area_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, area_index, *area_cur);
	}
	
	/*  6: see scripts/parklife/fxSequencer.py  */
	_log(l_type, "%seffect_type='%s'", pfx, effect_type.c_str());
	/*  7: isOffensive: soft boolean  */
	_log(l_type, "%sisOffensive=%lu", pfx, isOffensive);
	/*  8: start: soft boolean  */
	_log(l_type, "%sstart=%lu", pfx, start);
	/*  9: active: soft boolean  */
	_log(l_type, "%sactive=%lu", pfx, active);
}

PyRepTuple *DoDestiny_OnSpecialFX10::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(10);
	/*  0: shipID  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1: moduleID  */
	if(moduleID == 0) {
		tuple1->items[1] = new PyRepNone();
	} else {
		tuple1->items[1] = new PyRepInteger(moduleID);
	}
	/*  2: moduleTypeID  */
	if(moduleTypeID == 0) {
		tuple1->items[2] = new PyRepNone();
	} else {
		tuple1->items[2] = new PyRepInteger(moduleTypeID);
	}
	/*  3: targetID  */
	if(targetID == 0) {
		tuple1->items[3] = new PyRepNone();
	} else {
		tuple1->items[3] = new PyRepInteger(targetID);
	}
	/*  4: otherTypeID  */
	if(otherTypeID == 0) {
		tuple1->items[4] = new PyRepNone();
	} else {
		tuple1->items[4] = new PyRepInteger(otherTypeID);
	}
	/*  5: completely unknown contents, prolly not really an intlist  */
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator area_cur, area_end;
	area_cur = area.begin();
	area_end = area.end();
	for(; area_cur != area_end; area_cur++) {
		list2->items.push_back(
			new PyRepInteger(*area_cur)
		);
	}
	tuple1->items[5] = list2;
	
	/*  6: see scripts/parklife/fxSequencer.py  */
	tuple1->items[6] = new PyRepString(effect_type);
	/*  7: isOffensive: soft boolean  */
	tuple1->items[7] = new PyRepInteger(isOffensive);
	/*  8: start: soft boolean  */
	tuple1->items[8] = new PyRepInteger(start);
	/*  9: active: soft boolean  */
	tuple1->items[9] = new PyRepInteger(active);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_OnSpecialFX10::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(10);
	/*  0: shipID  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1: moduleID  */
	if(moduleID == 0) {
		tuple1->items[1] = new PyRepNone();
	} else {
		tuple1->items[1] = new PyRepInteger(moduleID);
	}
	/*  2: moduleTypeID  */
	if(moduleTypeID == 0) {
		tuple1->items[2] = new PyRepNone();
	} else {
		tuple1->items[2] = new PyRepInteger(moduleTypeID);
	}
	/*  3: targetID  */
	if(targetID == 0) {
		tuple1->items[3] = new PyRepNone();
	} else {
		tuple1->items[3] = new PyRepInteger(targetID);
	}
	/*  4: otherTypeID  */
	if(otherTypeID == 0) {
		tuple1->items[4] = new PyRepNone();
	} else {
		tuple1->items[4] = new PyRepInteger(otherTypeID);
	}
	/*  5: completely unknown contents, prolly not really an intlist  */
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator area_cur, area_end;
	area_cur = area.begin();
	area_end = area.end();
	for(; area_cur != area_end; area_cur++) {
		list2->items.push_back(
			new PyRepInteger(*area_cur)
		);
	}
	tuple1->items[5] = list2;
	
	/*  6: see scripts/parklife/fxSequencer.py  */
	tuple1->items[6] = new PyRepString(effect_type);
	/*  7: isOffensive: soft boolean  */
	tuple1->items[7] = new PyRepInteger(isOffensive);
	/*  8: start: soft boolean  */
	tuple1->items[8] = new PyRepInteger(start);
	/*  9: active: soft boolean  */
	tuple1->items[9] = new PyRepInteger(active);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_OnSpecialFX10::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_OnSpecialFX10::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 10) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: tuple2 is the wrong size: expected 10, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0: shipID  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX10: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  1: moduleID  */
	if(tuple2->items[1]->CheckType(PyRep::None)) {
		moduleID = 0;
	} else {
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: moduleID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX10: truncating 64 bit into into 32 bit int for field moduleID");
	}
	moduleID = int_4->value;
	}
	/*  2: moduleTypeID  */
	if(tuple2->items[2]->CheckType(PyRep::None)) {
		moduleTypeID = 0;
	} else {
	if(!tuple2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: moduleTypeID is not an int: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX10: truncating 64 bit into into 32 bit int for field moduleTypeID");
	}
	moduleTypeID = int_5->value;
	}
	/*  3: targetID  */
	if(tuple2->items[3]->CheckType(PyRep::None)) {
		targetID = 0;
	} else {
	if(!tuple2->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: targetID is not an int: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple2->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX10: truncating 64 bit into into 32 bit int for field targetID");
	}
	targetID = int_6->value;
	}
	/*  4: otherTypeID  */
	if(tuple2->items[4]->CheckType(PyRep::None)) {
		otherTypeID = 0;
	} else {
	if(!tuple2->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: otherTypeID is not an int: %s", tuple2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple2->items[4];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX10: truncating 64 bit into into 32 bit int for field otherTypeID");
	}
	otherTypeID = int_7->value;
	}
	/*  5: completely unknown contents, prolly not really an intlist  */
	if(!tuple2->items[5]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: area is not a list: %s", tuple2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	area.clear();
	PyRepList *list_8 = (PyRepList *) tuple2->items[5];
	PyRepList::iterator area_cur, area_end;
	area_cur = list_8->items.begin();
	area_end = list_8->items.end();
	int area_index;
	for(area_index = 0; area_cur != area_end; area_cur++, area_index++) {
		if(!(*area_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: Element %d in list area is not an integer: %s", area_index, (*area_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*area_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX10: truncating 64 bit into into 32 bit int for item %d in field area", area_index);
		}
		area.push_back(t->value);
	}

	/*  6: see scripts/parklife/fxSequencer.py  */
	if(!tuple2->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: effect_type is not a string: %s", tuple2->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_9 = (PyRepString *) tuple2->items[6];
	effect_type = string_9->value;
	/*  7: isOffensive: soft boolean  */
	if(!tuple2->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: isOffensive is not an int: %s", tuple2->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_10 = (PyRepInteger *) tuple2->items[7];
	if(int_10->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX10: truncating 64 bit into into 32 bit int for field isOffensive");
	}
	isOffensive = int_10->value;
	/*  8: start: soft boolean  */
	if(!tuple2->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: start is not an int: %s", tuple2->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_11 = (PyRepInteger *) tuple2->items[8];
	if(int_11->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX10: truncating 64 bit into into 32 bit int for field start");
	}
	start = int_11->value;
	/*  9: active: soft boolean  */
	if(!tuple2->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX10 failed: active is not an int: %s", tuple2->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_12 = (PyRepInteger *) tuple2->items[9];
	if(int_12->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX10: truncating 64 bit into into 32 bit int for field active");
	}
	active = int_12->value;

	delete packet;
	return(true);
}

DoDestiny_OnSpecialFX10 *DoDestiny_OnSpecialFX10::Clone() const {
	DoDestiny_OnSpecialFX10 *res = new DoDestiny_OnSpecialFX10;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_OnSpecialFX10::CloneFrom(const DoDestiny_OnSpecialFX10 *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0: shipID  */
	entityID = from->entityID;
	/*  1: moduleID  */
	moduleID = from->moduleID;
	/*  2: moduleTypeID  */
	moduleTypeID = from->moduleTypeID;
	/*  3: targetID  */
	targetID = from->targetID;
	/*  4: otherTypeID  */
	otherTypeID = from->otherTypeID;
	/*  5: completely unknown contents, prolly not really an intlist  */
	area = from->area;
	/*  6: see scripts/parklife/fxSequencer.py  */
	effect_type = from->effect_type;
	/*  7: isOffensive: soft boolean  */
	isOffensive = from->isOffensive;
	/*  8: start: soft boolean  */
	start = from->start;
	/*  9: active: soft boolean  */
	active = from->active;
	
}


DoDestiny_OnSpecialFX_JumpOut::DoDestiny_OnSpecialFX_JumpOut() {
	/*  0  */
	update_name = "OnSpecialFX";
	/*  1  */
	/*  0  */
	entityID = 0;
	/*  1  */
	/*  2  */
	/*  3  */
	usingGateID = 0;
	/*  4  */
	/*  5: completely unknown contents, prolly not really an intlist  */
	/*  6: see scripts/parklife/fxSequencer.py  */
	effect_type = "effects.JumpOut";
	/*  7: saw 0  */
	isOffensive = 0;
	/*  8: saw 1  */
	start = 1;
	/*  9: saw 0  */
	active = 0;
}

DoDestiny_OnSpecialFX_JumpOut::~DoDestiny_OnSpecialFX_JumpOut() {
	/*  0  */
	/*  1  */
	/*  0  */
	/*  1  */
	/*  2  */
	/*  3  */
	/*  4  */
	/*  5: completely unknown contents, prolly not really an intlist  */
	/*  6: see scripts/parklife/fxSequencer.py  */
	/*  7: saw 0  */
	/*  8: saw 1  */
	/*  9: saw 0  */
}

void DoDestiny_OnSpecialFX_JumpOut::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_OnSpecialFX_JumpOut", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1  */
	/*  2  */
	/*  3  */
	_log(l_type, "%susingGateID=%lu", pfx, usingGateID);
	/*  4  */
	/*  5: completely unknown contents, prolly not really an intlist  */
	_log(l_type, "%sarea: Integer list with %d enetires", pfx, area.size());
	std::vector<uint32>::const_iterator area_cur, area_end;
	area_cur = area.begin();
	area_end = area.end();
	int area_index;
	for(area_index = 0; area_cur != area_end; area_cur++, area_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, area_index, *area_cur);
	}
	
	/*  6: see scripts/parklife/fxSequencer.py  */
	_log(l_type, "%seffect_type='%s'", pfx, effect_type.c_str());
	/*  7: saw 0  */
	_log(l_type, "%sisOffensive=%lu", pfx, isOffensive);
	/*  8: saw 1  */
	_log(l_type, "%sstart=%lu", pfx, start);
	/*  9: saw 0  */
	_log(l_type, "%sactive=%lu", pfx, active);
}

PyRepTuple *DoDestiny_OnSpecialFX_JumpOut::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(10);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepNone();
	/*  2  */
	tuple1->items[2] = new PyRepNone();
	/*  3  */
	tuple1->items[3] = new PyRepInteger(usingGateID);
	/*  4  */
	tuple1->items[4] = new PyRepNone();
	/*  5: completely unknown contents, prolly not really an intlist  */
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator area_cur, area_end;
	area_cur = area.begin();
	area_end = area.end();
	for(; area_cur != area_end; area_cur++) {
		list2->items.push_back(
			new PyRepInteger(*area_cur)
		);
	}
	tuple1->items[5] = list2;
	
	/*  6: see scripts/parklife/fxSequencer.py  */
	tuple1->items[6] = new PyRepString(effect_type);
	/*  7: saw 0  */
	tuple1->items[7] = new PyRepInteger(isOffensive);
	/*  8: saw 1  */
	tuple1->items[8] = new PyRepInteger(start);
	/*  9: saw 0  */
	tuple1->items[9] = new PyRepInteger(active);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_OnSpecialFX_JumpOut::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(10);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepNone();
	/*  2  */
	tuple1->items[2] = new PyRepNone();
	/*  3  */
	tuple1->items[3] = new PyRepInteger(usingGateID);
	/*  4  */
	tuple1->items[4] = new PyRepNone();
	/*  5: completely unknown contents, prolly not really an intlist  */
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator area_cur, area_end;
	area_cur = area.begin();
	area_end = area.end();
	for(; area_cur != area_end; area_cur++) {
		list2->items.push_back(
			new PyRepInteger(*area_cur)
		);
	}
	tuple1->items[5] = list2;
	
	/*  6: see scripts/parklife/fxSequencer.py  */
	tuple1->items[6] = new PyRepString(effect_type);
	/*  7: saw 0  */
	tuple1->items[7] = new PyRepInteger(isOffensive);
	/*  8: saw 1  */
	tuple1->items[8] = new PyRepInteger(start);
	/*  9: saw 0  */
	tuple1->items[9] = new PyRepInteger(active);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_OnSpecialFX_JumpOut::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_OnSpecialFX_JumpOut::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 10) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: tuple2 is the wrong size: expected 10, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX_JumpOut: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: expecting a None but got a %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  2  */
	if(!tuple2->items[2]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: expecting a None but got a %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  3  */
	if(!tuple2->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: usingGateID is not an int: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[3];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX_JumpOut: truncating 64 bit into into 32 bit int for field usingGateID");
	}
	usingGateID = int_4->value;
	/*  4  */
	if(!tuple2->items[4]->CheckType(PyRep::None)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: expecting a None but got a %s", tuple2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	
	/*  5: completely unknown contents, prolly not really an intlist  */
	if(!tuple2->items[5]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: area is not a list: %s", tuple2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	area.clear();
	PyRepList *list_5 = (PyRepList *) tuple2->items[5];
	PyRepList::iterator area_cur, area_end;
	area_cur = list_5->items.begin();
	area_end = list_5->items.end();
	int area_index;
	for(area_index = 0; area_cur != area_end; area_cur++, area_index++) {
		if(!(*area_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: Element %d in list area is not an integer: %s", area_index, (*area_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*area_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX_JumpOut: truncating 64 bit into into 32 bit int for item %d in field area", area_index);
		}
		area.push_back(t->value);
	}

	/*  6: see scripts/parklife/fxSequencer.py  */
	if(!tuple2->items[6]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: effect_type is not a string: %s", tuple2->items[6]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_6 = (PyRepString *) tuple2->items[6];
	effect_type = string_6->value;
	/*  7: saw 0  */
	if(!tuple2->items[7]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: isOffensive is not an int: %s", tuple2->items[7]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple2->items[7];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX_JumpOut: truncating 64 bit into into 32 bit int for field isOffensive");
	}
	isOffensive = int_7->value;
	/*  8: saw 1  */
	if(!tuple2->items[8]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: start is not an int: %s", tuple2->items[8]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) tuple2->items[8];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX_JumpOut: truncating 64 bit into into 32 bit int for field start");
	}
	start = int_8->value;
	/*  9: saw 0  */
	if(!tuple2->items[9]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnSpecialFX_JumpOut failed: active is not an int: %s", tuple2->items[9]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) tuple2->items[9];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnSpecialFX_JumpOut: truncating 64 bit into into 32 bit int for field active");
	}
	active = int_9->value;

	delete packet;
	return(true);
}

DoDestiny_OnSpecialFX_JumpOut *DoDestiny_OnSpecialFX_JumpOut::Clone() const {
	DoDestiny_OnSpecialFX_JumpOut *res = new DoDestiny_OnSpecialFX_JumpOut;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_OnSpecialFX_JumpOut::CloneFrom(const DoDestiny_OnSpecialFX_JumpOut *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0  */
	entityID = from->entityID;
	/*  1  */
	/*  2  */
	/*  3  */
	usingGateID = from->usingGateID;
	/*  4  */
	/*  5: completely unknown contents, prolly not really an intlist  */
	area = from->area;
	/*  6: see scripts/parklife/fxSequencer.py  */
	effect_type = from->effect_type;
	/*  7: saw 0  */
	isOffensive = from->isOffensive;
	/*  8: saw 1  */
	start = from->start;
	/*  9: saw 0  */
	active = from->active;
	
}


DoDestiny_DamageDetails::DoDestiny_DamageDetails() {
	shield = 0.0;
	tau = 0.0;
	timestamp = 0;
	armor = 0.0;
	structure = 0.0;
}

DoDestiny_DamageDetails::~DoDestiny_DamageDetails() {
}

void DoDestiny_DamageDetails::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_DamageDetails", pfx);
	_log(l_type, "%sshield=%.13f", pfx, shield);
	_log(l_type, "%stau=%.13f", pfx, tau);
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	_log(l_type, "%sarmor=%.13f", pfx, armor);
	_log(l_type, "%sstructure=%.13f", pfx, structure);
}

PyRepList *DoDestiny_DamageDetails::Encode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(3, NULL);
	PyRepTuple *tuple1 = new PyRepTuple(3);
	tuple1->items[0] = new PyRepReal(shield);
	tuple1->items[1] = new PyRepReal(tau);
	tuple1->items[2] = new PyRepInteger(timestamp);
	list0->items[0] = tuple1;
	
	list0->items[1] = new PyRepReal(armor);
	list0->items[2] = new PyRepReal(structure);
	res = list0;
	

	return(res);
}

PyRepList *DoDestiny_DamageDetails::FastEncode() {
	PyRepList *res = NULL;
	PyRepList *list0 = new PyRepList();
	list0->items.resize(3, NULL);
	PyRepTuple *tuple1 = new PyRepTuple(3);
	tuple1->items[0] = new PyRepReal(shield);
	tuple1->items[1] = new PyRepReal(tau);
	tuple1->items[2] = new PyRepInteger(timestamp);
	list0->items[0] = tuple1;
	
	list0->items[1] = new PyRepReal(armor);
	list0->items[2] = new PyRepReal(structure);
	res = list0;
	

	return(res);
}

bool DoDestiny_DamageDetails::Decode(PyRepList **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_DamageDetails::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_DamageDetails failed: list0 is not a list: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list0 = (PyRepList *) packet;
	if(list0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_DamageDetails failed: list0 is the wrong size: expected 3, but got %d", list0->items.size());
		delete packet;
		return(false);
	}

	if(!list0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_DamageDetails failed: tuple1 is the wrong type: %s", list0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) list0->items[0];
	if(tuple1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_DamageDetails failed: tuple1 is the wrong size: expected 3, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	if(!tuple1->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_DamageDetails failed: shield is not a real: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_2 = (PyRepReal *) tuple1->items[0];
	shield = real_2->value;
	if(!tuple1->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_DamageDetails failed: tau is not a real: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_3 = (PyRepReal *) tuple1->items[1];
	tau = real_3->value;
	if(!tuple1->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_DamageDetails failed: timestamp is not an int: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple1->items[2];
	timestamp = int64_4->value;
	if(!list0->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_DamageDetails failed: armor is not a real: %s", list0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) list0->items[1];
	armor = real_5->value;
	if(!list0->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_DamageDetails failed: structure is not a real: %s", list0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) list0->items[2];
	structure = real_6->value;

	delete packet;
	return(true);
}

DoDestiny_DamageDetails *DoDestiny_DamageDetails::Clone() const {
	DoDestiny_DamageDetails *res = new DoDestiny_DamageDetails;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_DamageDetails::CloneFrom(const DoDestiny_DamageDetails *from) {
	shield = from->shield;
	tau = from->tau;
	timestamp = from->timestamp;
	armor = from->armor;
	structure = from->structure;
	
}


DoDestinyDamageState::DoDestinyDamageState() {
	/*  this is a ratio from 0-1  */
	shield = 0.0;
	/*  no idea what this is for, I have seen 100000 and 600000  */
	tau = 0.0;
	timestamp = 0;
	/*  this is a ratio from 0-1  */
	armor = 0.0;
	/*  this is a ratio from 0-1  */
	structure = 0.0;
}

DoDestinyDamageState::~DoDestinyDamageState() {
	/*  this is a ratio from 0-1  */
	/*  no idea what this is for, I have seen 100000 and 600000  */
	/*  this is a ratio from 0-1  */
	/*  this is a ratio from 0-1  */
}

void DoDestinyDamageState::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestinyDamageState", pfx);
	/*  this is a ratio from 0-1  */
	_log(l_type, "%sshield=%.13f", pfx, shield);
	/*  no idea what this is for, I have seen 100000 and 600000  */
	_log(l_type, "%stau=%.13f", pfx, tau);
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	/*  this is a ratio from 0-1  */
	_log(l_type, "%sarmor=%.13f", pfx, armor);
	/*  this is a ratio from 0-1  */
	_log(l_type, "%sstructure=%.13f", pfx, structure);
}

PyRepTuple *DoDestinyDamageState::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  this is a ratio from 0-1  */
	tuple1->items[0] = new PyRepReal(shield);
	/*  no idea what this is for, I have seen 100000 and 600000  */
	tuple1->items[1] = new PyRepReal(tau);
	tuple1->items[2] = new PyRepInteger(timestamp);
	tuple0->items[0] = tuple1;
	
	/*  this is a ratio from 0-1  */
	tuple0->items[1] = new PyRepReal(armor);
	/*  this is a ratio from 0-1  */
	tuple0->items[2] = new PyRepReal(structure);
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestinyDamageState::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  this is a ratio from 0-1  */
	tuple1->items[0] = new PyRepReal(shield);
	/*  no idea what this is for, I have seen 100000 and 600000  */
	tuple1->items[1] = new PyRepReal(tau);
	tuple1->items[2] = new PyRepInteger(timestamp);
	tuple0->items[0] = tuple1;
	
	/*  this is a ratio from 0-1  */
	tuple0->items[1] = new PyRepReal(armor);
	/*  this is a ratio from 0-1  */
	tuple0->items[2] = new PyRepReal(structure);
	res = tuple0;
	

	return(res);
}

bool DoDestinyDamageState::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestinyDamageState::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyDamageState failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyDamageState failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyDamageState failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyDamageState failed: tuple1 is the wrong size: expected 3, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  this is a ratio from 0-1  */
	if(!tuple1->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyDamageState failed: shield is not a real: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_2 = (PyRepReal *) tuple1->items[0];
	shield = real_2->value;
	/*  no idea what this is for, I have seen 100000 and 600000  */
	if(!tuple1->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyDamageState failed: tau is not a real: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_3 = (PyRepReal *) tuple1->items[1];
	tau = real_3->value;
	if(!tuple1->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyDamageState failed: timestamp is not an int: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple1->items[2];
	timestamp = int64_4->value;
	/*  this is a ratio from 0-1  */
	if(!tuple0->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyDamageState failed: armor is not a real: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple0->items[1];
	armor = real_5->value;
	/*  this is a ratio from 0-1  */
	if(!tuple0->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestinyDamageState failed: structure is not a real: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) tuple0->items[2];
	structure = real_6->value;

	delete packet;
	return(true);
}

DoDestinyDamageState *DoDestinyDamageState::Clone() const {
	DoDestinyDamageState *res = new DoDestinyDamageState;
	res->CloneFrom(this);
	return(res);
}

void DoDestinyDamageState::CloneFrom(const DoDestinyDamageState *from) {
	/*  this is a ratio from 0-1  */
	shield = from->shield;
	/*  no idea what this is for, I have seen 100000 and 600000  */
	tau = from->tau;
	timestamp = from->timestamp;
	/*  this is a ratio from 0-1  */
	armor = from->armor;
	/*  this is a ratio from 0-1  */
	structure = from->structure;
	
}


DoDestiny_OnDamageStateChange::DoDestiny_OnDamageStateChange() {
	/*  0  */
	update_name = "OnDamageStateChange";
	/*  1  */
	/*  0: shipID  */
	entityID = 0;
	/*  entry of type DoDestinyDamageState  */
	state = NULL;
}

DoDestiny_OnDamageStateChange::~DoDestiny_OnDamageStateChange() {
	/*  0  */
	/*  1  */
	/*  0: shipID  */
	/*  entry of type DoDestinyDamageState  */
	delete state;
}

void DoDestiny_OnDamageStateChange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_OnDamageStateChange", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0: shipID  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  entry of type DoDestinyDamageState  */
	_log(l_type, "%sstate:", pfx);
	std::string state_n(pfx);
	state_n += "    ";
	if(state == NULL) {
		_log(l_type, "%sERROR: NULL REP!", state_n.c_str());
	} else {
		state->Dump(l_type, state_n.c_str());
	}
}

PyRepTuple *DoDestiny_OnDamageStateChange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0: shipID  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  entry of type DoDestinyDamageState  */
	if(state == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_OnDamageStateChange: state is NULL! hacking in a PyRepNone");
		state = new PyRepNone();
	}
	tuple1->items[1] = state->Clone();
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_OnDamageStateChange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0: shipID  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  entry of type DoDestinyDamageState  */
	if(state == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_OnDamageStateChange: state is NULL! hacking in a PyRepNone");
		state = new PyRepNone();
	}
	tuple1->items[1] = state;
	state = NULL;
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_OnDamageStateChange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_OnDamageStateChange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDamageStateChange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDamageStateChange failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDamageStateChange failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDamageStateChange failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDamageStateChange failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0: shipID  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDamageStateChange failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnDamageStateChange: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  entry of type DoDestinyDamageState  */
	delete state;
	state = tuple2->items[1];
	tuple2->items[1] = NULL;
	

	delete packet;
	return(true);
}

DoDestiny_OnDamageStateChange *DoDestiny_OnDamageStateChange::Clone() const {
	DoDestiny_OnDamageStateChange *res = new DoDestiny_OnDamageStateChange;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_OnDamageStateChange::CloneFrom(const DoDestiny_OnDamageStateChange *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0: shipID  */
	entityID = from->entityID;
	/*  entry of type DoDestinyDamageState  */
	delete state;
	if(from->state == NULL) {
		state = NULL;
	} else {
		state = from->state->Clone();
	}
	
}


DoDestiny_SetSpeedFraction::DoDestiny_SetSpeedFraction() {
	/*  0  */
	update_name = "SetSpeedFraction";
	/*  1  */
	/*  0  */
	entityID = 0;
	/*  1  */
	fraction = 0.0;
}

DoDestiny_SetSpeedFraction::~DoDestiny_SetSpeedFraction() {
	/*  0  */
	/*  1  */
	/*  0  */
	/*  1  */
}

void DoDestiny_SetSpeedFraction::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetSpeedFraction", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1  */
	_log(l_type, "%sfraction=%.13f", pfx, fraction);
}

PyRepTuple *DoDestiny_SetSpeedFraction::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepReal(fraction);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetSpeedFraction::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepReal(fraction);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetSpeedFraction::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetSpeedFraction::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetSpeedFraction failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetSpeedFraction failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetSpeedFraction failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetSpeedFraction failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetSpeedFraction failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetSpeedFraction failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetSpeedFraction: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetSpeedFraction failed: fraction is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	fraction = real_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetSpeedFraction *DoDestiny_SetSpeedFraction::Clone() const {
	DoDestiny_SetSpeedFraction *res = new DoDestiny_SetSpeedFraction;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetSpeedFraction::CloneFrom(const DoDestiny_SetSpeedFraction *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0  */
	entityID = from->entityID;
	/*  1  */
	fraction = from->fraction;
	
}


DoDestiny_SetNotificationRange::DoDestiny_SetNotificationRange() {
	/*  0  */
	update_name = "SetNotificationRange";
	/*  1  */
	/*  0  */
	entityID = 0;
	/*  1  */
	range = 0.0;
}

DoDestiny_SetNotificationRange::~DoDestiny_SetNotificationRange() {
	/*  0  */
	/*  1  */
	/*  0  */
	/*  1  */
}

void DoDestiny_SetNotificationRange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetNotificationRange", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1  */
	_log(l_type, "%srange=%.13f", pfx, range);
}

PyRepTuple *DoDestiny_SetNotificationRange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepReal(range);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetNotificationRange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepReal(range);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetNotificationRange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetNotificationRange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetNotificationRange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetNotificationRange failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetNotificationRange failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetNotificationRange failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetNotificationRange failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetNotificationRange failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetNotificationRange: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetNotificationRange failed: range is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	range = real_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetNotificationRange *DoDestiny_SetNotificationRange::Clone() const {
	DoDestiny_SetNotificationRange *res = new DoDestiny_SetNotificationRange;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetNotificationRange::CloneFrom(const DoDestiny_SetNotificationRange *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0  */
	entityID = from->entityID;
	/*  1  */
	range = from->range;
	
}


DoDestiny_SetBallPosition::DoDestiny_SetBallPosition() {
	/*  0  */
	update_name = "SetBallPosition";
	/*  1  */
	entityID = 0;
	x = 0.0;
	y = 0.0;
	z = 0.0;
}

DoDestiny_SetBallPosition::~DoDestiny_SetBallPosition() {
	/*  0  */
	/*  1  */
}

void DoDestiny_SetBallPosition::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBallPosition", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sx=%.13f", pfx, x);
	_log(l_type, "%sy=%.13f", pfx, y);
	_log(l_type, "%sz=%.13f", pfx, z);
}

PyRepTuple *DoDestiny_SetBallPosition::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(4);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(x);
	tuple1->items[2] = new PyRepReal(y);
	tuple1->items[3] = new PyRepReal(z);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBallPosition::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(4);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(x);
	tuple1->items[2] = new PyRepReal(y);
	tuple1->items[3] = new PyRepReal(z);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBallPosition::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBallPosition::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallPosition failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallPosition failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallPosition failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallPosition failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallPosition failed: tuple2 is the wrong size: expected 4, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallPosition failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallPosition: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallPosition failed: x is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	x = real_4->value;
	if(!tuple2->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallPosition failed: y is not a real: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple2->items[2];
	y = real_5->value;
	if(!tuple2->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallPosition failed: z is not a real: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) tuple2->items[3];
	z = real_6->value;

	delete packet;
	return(true);
}

DoDestiny_SetBallPosition *DoDestiny_SetBallPosition::Clone() const {
	DoDestiny_SetBallPosition *res = new DoDestiny_SetBallPosition;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBallPosition::CloneFrom(const DoDestiny_SetBallPosition *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	x = from->x;
	y = from->y;
	z = from->z;
	
}


DoDestiny_SetBallVelocity::DoDestiny_SetBallVelocity() {
	/*  0  */
	update_name = "SetBallVelocity";
	/*  1  */
	entityID = 0;
	x = 0.0;
	y = 0.0;
	z = 0.0;
}

DoDestiny_SetBallVelocity::~DoDestiny_SetBallVelocity() {
	/*  0  */
	/*  1  */
}

void DoDestiny_SetBallVelocity::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBallVelocity", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sx=%.13f", pfx, x);
	_log(l_type, "%sy=%.13f", pfx, y);
	_log(l_type, "%sz=%.13f", pfx, z);
}

PyRepTuple *DoDestiny_SetBallVelocity::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(4);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(x);
	tuple1->items[2] = new PyRepReal(y);
	tuple1->items[3] = new PyRepReal(z);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBallVelocity::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(4);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(x);
	tuple1->items[2] = new PyRepReal(y);
	tuple1->items[3] = new PyRepReal(z);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBallVelocity::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBallVelocity::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallVelocity failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallVelocity failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallVelocity failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallVelocity failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallVelocity failed: tuple2 is the wrong size: expected 4, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallVelocity failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallVelocity: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallVelocity failed: x is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	x = real_4->value;
	if(!tuple2->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallVelocity failed: y is not a real: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple2->items[2];
	y = real_5->value;
	if(!tuple2->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallVelocity failed: z is not a real: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) tuple2->items[3];
	z = real_6->value;

	delete packet;
	return(true);
}

DoDestiny_SetBallVelocity *DoDestiny_SetBallVelocity::Clone() const {
	DoDestiny_SetBallVelocity *res = new DoDestiny_SetBallVelocity;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBallVelocity::CloneFrom(const DoDestiny_SetBallVelocity *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	x = from->x;
	y = from->y;
	z = from->z;
	
}


DoDestiny_FollowBall::DoDestiny_FollowBall() {
	/*  0  */
	update_name = "FollowBall";
	/*  1  */
	/*  0  */
	entityID = 0;
	ballID = 0;
	unknown = 0;
	/*  seen 50  */
}

DoDestiny_FollowBall::~DoDestiny_FollowBall() {
	/*  0  */
	/*  1  */
	/*  0  */
	/*  seen 50  */
}

void DoDestiny_FollowBall::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_FollowBall", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sballID=%lu", pfx, ballID);
	_log(l_type, "%sunknown=%lu", pfx, unknown);
	/*  seen 50  */
}

PyRepTuple *DoDestiny_FollowBall::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepInteger(ballID);
	tuple1->items[2] = new PyRepInteger(unknown);
	/*  seen 50  */
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_FollowBall::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepInteger(ballID);
	tuple1->items[2] = new PyRepInteger(unknown);
	/*  seen 50  */
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_FollowBall::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_FollowBall::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_FollowBall failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_FollowBall failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_FollowBall failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_FollowBall failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_FollowBall failed: tuple2 is the wrong size: expected 3, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_FollowBall failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_FollowBall: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_FollowBall failed: ballID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_FollowBall: truncating 64 bit into into 32 bit int for field ballID");
	}
	ballID = int_4->value;
	if(!tuple2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_FollowBall failed: unknown is not an int: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_FollowBall: truncating 64 bit into into 32 bit int for field unknown");
	}
	unknown = int_5->value;
	/*  seen 50  */

	delete packet;
	return(true);
}

DoDestiny_FollowBall *DoDestiny_FollowBall::Clone() const {
	DoDestiny_FollowBall *res = new DoDestiny_FollowBall;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_FollowBall::CloneFrom(const DoDestiny_FollowBall *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0  */
	entityID = from->entityID;
	ballID = from->ballID;
	unknown = from->unknown;
	/*  seen 50  */
	
}


DoDestiny_Stop::DoDestiny_Stop() {
	/*  0  */
	update_name = "Stop";
	/*  1  */
	/*  0  */
	entityID = 0;
}

DoDestiny_Stop::~DoDestiny_Stop() {
	/*  0  */
	/*  1  */
	/*  0  */
}

void DoDestiny_Stop::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_Stop", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
}

PyRepTuple *DoDestiny_Stop::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_Stop::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_Stop::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_Stop::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Stop failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Stop failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Stop failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Stop failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Stop failed: tuple2 is the wrong size: expected 1, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Stop failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_Stop: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;

	delete packet;
	return(true);
}

DoDestiny_Stop *DoDestiny_Stop::Clone() const {
	DoDestiny_Stop *res = new DoDestiny_Stop;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_Stop::CloneFrom(const DoDestiny_Stop *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0  */
	entityID = from->entityID;
	
}


DoDestiny_GotoDirection::DoDestiny_GotoDirection() {
	/*  0  */
	update_name = "GotoDirection";
	/*  1  */
	entityID = 0;
	x = 0.0;
	y = 0.0;
	z = 0.0;
}

DoDestiny_GotoDirection::~DoDestiny_GotoDirection() {
	/*  0  */
	/*  1  */
}

void DoDestiny_GotoDirection::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_GotoDirection", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sx=%.13f", pfx, x);
	_log(l_type, "%sy=%.13f", pfx, y);
	_log(l_type, "%sz=%.13f", pfx, z);
}

PyRepTuple *DoDestiny_GotoDirection::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(4);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(x);
	tuple1->items[2] = new PyRepReal(y);
	tuple1->items[3] = new PyRepReal(z);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_GotoDirection::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(4);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(x);
	tuple1->items[2] = new PyRepReal(y);
	tuple1->items[3] = new PyRepReal(z);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_GotoDirection::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_GotoDirection::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoDirection failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoDirection failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoDirection failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoDirection failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoDirection failed: tuple2 is the wrong size: expected 4, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoDirection failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_GotoDirection: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoDirection failed: x is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	x = real_4->value;
	if(!tuple2->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoDirection failed: y is not a real: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple2->items[2];
	y = real_5->value;
	if(!tuple2->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoDirection failed: z is not a real: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) tuple2->items[3];
	z = real_6->value;

	delete packet;
	return(true);
}

DoDestiny_GotoDirection *DoDestiny_GotoDirection::Clone() const {
	DoDestiny_GotoDirection *res = new DoDestiny_GotoDirection;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_GotoDirection::CloneFrom(const DoDestiny_GotoDirection *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	x = from->x;
	y = from->y;
	z = from->z;
	
}


DoDestiny_GotoPoint::DoDestiny_GotoPoint() {
	/*  0  */
	update_name = "GotoPoint";
	/*  1  */
	entityID = 0;
	x = 0.0;
	y = 0.0;
	z = 0.0;
}

DoDestiny_GotoPoint::~DoDestiny_GotoPoint() {
	/*  0  */
	/*  1  */
}

void DoDestiny_GotoPoint::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_GotoPoint", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sx=%.13f", pfx, x);
	_log(l_type, "%sy=%.13f", pfx, y);
	_log(l_type, "%sz=%.13f", pfx, z);
}

PyRepTuple *DoDestiny_GotoPoint::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(4);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(x);
	tuple1->items[2] = new PyRepReal(y);
	tuple1->items[3] = new PyRepReal(z);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_GotoPoint::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(4);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(x);
	tuple1->items[2] = new PyRepReal(y);
	tuple1->items[3] = new PyRepReal(z);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_GotoPoint::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_GotoPoint::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoPoint failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoPoint failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoPoint failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoPoint failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 4) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoPoint failed: tuple2 is the wrong size: expected 4, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoPoint failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_GotoPoint: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoPoint failed: x is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	x = real_4->value;
	if(!tuple2->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoPoint failed: y is not a real: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple2->items[2];
	y = real_5->value;
	if(!tuple2->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_GotoPoint failed: z is not a real: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) tuple2->items[3];
	z = real_6->value;

	delete packet;
	return(true);
}

DoDestiny_GotoPoint *DoDestiny_GotoPoint::Clone() const {
	DoDestiny_GotoPoint *res = new DoDestiny_GotoPoint;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_GotoPoint::CloneFrom(const DoDestiny_GotoPoint *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	x = from->x;
	y = from->y;
	z = from->z;
	
}


DoDestiny_SetBallMass::DoDestiny_SetBallMass() {
	/*  0  */
	update_name = "SetBallMass";
	/*  1  */
	entityID = 0;
	mass = 0.0;
}

DoDestiny_SetBallMass::~DoDestiny_SetBallMass() {
	/*  0  */
	/*  1  */
}

void DoDestiny_SetBallMass::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBallMass", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%smass=%.13f", pfx, mass);
}

PyRepTuple *DoDestiny_SetBallMass::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(mass);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBallMass::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(mass);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBallMass::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBallMass::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMass failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMass failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMass failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMass failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMass failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMass failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallMass: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMass failed: mass is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	mass = real_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetBallMass *DoDestiny_SetBallMass::Clone() const {
	DoDestiny_SetBallMass *res = new DoDestiny_SetBallMass;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBallMass::CloneFrom(const DoDestiny_SetBallMass *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	mass = from->mass;
	
}


DoDestiny_SetBallRadius::DoDestiny_SetBallRadius() {
	/*  0  */
	update_name = "SetBallRadius";
	/*  1  */
	entityID = 0;
	radius = 0.0;
}

DoDestiny_SetBallRadius::~DoDestiny_SetBallRadius() {
	/*  0  */
	/*  1  */
}

void DoDestiny_SetBallRadius::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBallRadius", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sradius=%.13f", pfx, radius);
}

PyRepTuple *DoDestiny_SetBallRadius::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(radius);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBallRadius::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(radius);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBallRadius::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBallRadius::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallRadius failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallRadius failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallRadius failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallRadius failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallRadius failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallRadius failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallRadius: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallRadius failed: radius is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	radius = real_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetBallRadius *DoDestiny_SetBallRadius::Clone() const {
	DoDestiny_SetBallRadius *res = new DoDestiny_SetBallRadius;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBallRadius::CloneFrom(const DoDestiny_SetBallRadius *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	radius = from->radius;
	
}


DoDestiny_SetBallMassive::DoDestiny_SetBallMassive() {
	/*  0  */
	update_name = "SetBallMassive";
	/*  1  */
	entityID = 0;
	/*  integer boolean  */
	is_massive = 0;
}

DoDestiny_SetBallMassive::~DoDestiny_SetBallMassive() {
	/*  0  */
	/*  1  */
	/*  integer boolean  */
}

void DoDestiny_SetBallMassive::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBallMassive", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  integer boolean  */
	_log(l_type, "%sis_massive=%lu", pfx, is_massive);
}

PyRepTuple *DoDestiny_SetBallMassive::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  integer boolean  */
	tuple1->items[1] = new PyRepInteger(is_massive);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBallMassive::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  integer boolean  */
	tuple1->items[1] = new PyRepInteger(is_massive);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBallMassive::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBallMassive::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMassive failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMassive failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMassive failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMassive failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMassive failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMassive failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallMassive: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  integer boolean  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallMassive failed: is_massive is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallMassive: truncating 64 bit into into 32 bit int for field is_massive");
	}
	is_massive = int_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetBallMassive *DoDestiny_SetBallMassive::Clone() const {
	DoDestiny_SetBallMassive *res = new DoDestiny_SetBallMassive;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBallMassive::CloneFrom(const DoDestiny_SetBallMassive *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	/*  integer boolean  */
	is_massive = from->is_massive;
	
}


DoDestiny_SetBallFree::DoDestiny_SetBallFree() {
	/*  0  */
	update_name = "SetBallFree";
	/*  1  */
	entityID = 0;
	/*  integer boolean I think  */
	is_free = 0;
}

DoDestiny_SetBallFree::~DoDestiny_SetBallFree() {
	/*  0  */
	/*  1  */
	/*  integer boolean I think  */
}

void DoDestiny_SetBallFree::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBallFree", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  integer boolean I think  */
	_log(l_type, "%sis_free=%lu", pfx, is_free);
}

PyRepTuple *DoDestiny_SetBallFree::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  integer boolean I think  */
	tuple1->items[1] = new PyRepInteger(is_free);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBallFree::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  integer boolean I think  */
	tuple1->items[1] = new PyRepInteger(is_free);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBallFree::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBallFree::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallFree failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallFree failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallFree failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallFree failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallFree failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallFree failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallFree: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  integer boolean I think  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallFree failed: is_free is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallFree: truncating 64 bit into into 32 bit int for field is_free");
	}
	is_free = int_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetBallFree *DoDestiny_SetBallFree::Clone() const {
	DoDestiny_SetBallFree *res = new DoDestiny_SetBallFree;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBallFree::CloneFrom(const DoDestiny_SetBallFree *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	/*  integer boolean I think  */
	is_free = from->is_free;
	
}


DoDestiny_SetBallGlobal::DoDestiny_SetBallGlobal() {
	/*  0  */
	update_name = "SetBallGlobal";
	/*  1  */
	entityID = 0;
	/*  integer boolean I think  */
	is_global = 0;
}

DoDestiny_SetBallGlobal::~DoDestiny_SetBallGlobal() {
	/*  0  */
	/*  1  */
	/*  integer boolean I think  */
}

void DoDestiny_SetBallGlobal::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBallGlobal", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  integer boolean I think  */
	_log(l_type, "%sis_global=%lu", pfx, is_global);
}

PyRepTuple *DoDestiny_SetBallGlobal::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  integer boolean I think  */
	tuple1->items[1] = new PyRepInteger(is_global);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBallGlobal::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  integer boolean I think  */
	tuple1->items[1] = new PyRepInteger(is_global);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBallGlobal::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBallGlobal::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallGlobal failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallGlobal failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallGlobal failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallGlobal failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallGlobal failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallGlobal failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallGlobal: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  integer boolean I think  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallGlobal failed: is_global is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallGlobal: truncating 64 bit into into 32 bit int for field is_global");
	}
	is_global = int_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetBallGlobal *DoDestiny_SetBallGlobal::Clone() const {
	DoDestiny_SetBallGlobal *res = new DoDestiny_SetBallGlobal;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBallGlobal::CloneFrom(const DoDestiny_SetBallGlobal *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	/*  integer boolean I think  */
	is_global = from->is_global;
	
}


DoDestiny_SetMaxSpeed::DoDestiny_SetMaxSpeed() {
	/*  0  */
	update_name = "SetMaxSpeed";
	/*  1  */
	entityID = 0;
	speed = 0.0;
}

DoDestiny_SetMaxSpeed::~DoDestiny_SetMaxSpeed() {
	/*  0  */
	/*  1  */
}

void DoDestiny_SetMaxSpeed::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetMaxSpeed", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sspeed=%.13f", pfx, speed);
}

PyRepTuple *DoDestiny_SetMaxSpeed::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(speed);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetMaxSpeed::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepReal(speed);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetMaxSpeed::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetMaxSpeed::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetMaxSpeed failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetMaxSpeed failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetMaxSpeed failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetMaxSpeed failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetMaxSpeed failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetMaxSpeed failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetMaxSpeed: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetMaxSpeed failed: speed is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	speed = real_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetMaxSpeed *DoDestiny_SetMaxSpeed::Clone() const {
	DoDestiny_SetMaxSpeed *res = new DoDestiny_SetMaxSpeed;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetMaxSpeed::CloneFrom(const DoDestiny_SetMaxSpeed *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	speed = from->speed;
	
}


DoDestiny_WarpTo::DoDestiny_WarpTo() {
	/*  0  */
	update_name = "WarpTo";
	/*  1  */
	/*  0  */
	entityID = 0;
	/*  1  */
	dest_x = 0.0;
	/*  2  */
	dest_y = 0.0;
	/*  3  */
	dest_z = 0.0;
	/*  4  */
	distance = 0;
	/*  5  */
	u5 = 0;
}

DoDestiny_WarpTo::~DoDestiny_WarpTo() {
	/*  0  */
	/*  1  */
	/*  0  */
	/*  1  */
	/*  2  */
	/*  3  */
	/*  4  */
	/*  5  */
}

void DoDestiny_WarpTo::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_WarpTo", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1  */
	_log(l_type, "%sdest_x=%.13f", pfx, dest_x);
	/*  2  */
	_log(l_type, "%sdest_y=%.13f", pfx, dest_y);
	/*  3  */
	_log(l_type, "%sdest_z=%.13f", pfx, dest_z);
	/*  4  */
	_log(l_type, "%sdistance=%lu", pfx, distance);
	/*  5  */
	_log(l_type, "%su5=%lu", pfx, u5);
}

PyRepTuple *DoDestiny_WarpTo::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(6);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepReal(dest_x);
	/*  2  */
	tuple1->items[2] = new PyRepReal(dest_y);
	/*  3  */
	tuple1->items[3] = new PyRepReal(dest_z);
	/*  4  */
	tuple1->items[4] = new PyRepInteger(distance);
	/*  5  */
	tuple1->items[5] = new PyRepInteger(u5);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_WarpTo::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(6);
	/*  0  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1  */
	tuple1->items[1] = new PyRepReal(dest_x);
	/*  2  */
	tuple1->items[2] = new PyRepReal(dest_y);
	/*  3  */
	tuple1->items[3] = new PyRepReal(dest_z);
	/*  4  */
	tuple1->items[4] = new PyRepInteger(distance);
	/*  5  */
	tuple1->items[5] = new PyRepInteger(u5);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_WarpTo::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_WarpTo::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: tuple2 is the wrong size: expected 6, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_WarpTo: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  1  */
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: dest_x is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	dest_x = real_4->value;
	/*  2  */
	if(!tuple2->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: dest_y is not a real: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple2->items[2];
	dest_y = real_5->value;
	/*  3  */
	if(!tuple2->items[3]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: dest_z is not a real: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) tuple2->items[3];
	dest_z = real_6->value;
	/*  4  */
	if(!tuple2->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: distance is not an int: %s", tuple2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple2->items[4];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_WarpTo: truncating 64 bit into into 32 bit int for field distance");
	}
	distance = int_7->value;
	/*  5  */
	if(!tuple2->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_WarpTo failed: u5 is not an int: %s", tuple2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) tuple2->items[5];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_WarpTo: truncating 64 bit into into 32 bit int for field u5");
	}
	u5 = int_8->value;

	delete packet;
	return(true);
}

DoDestiny_WarpTo *DoDestiny_WarpTo::Clone() const {
	DoDestiny_WarpTo *res = new DoDestiny_WarpTo;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_WarpTo::CloneFrom(const DoDestiny_WarpTo *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0  */
	entityID = from->entityID;
	/*  1  */
	dest_x = from->dest_x;
	/*  2  */
	dest_y = from->dest_y;
	/*  3  */
	dest_z = from->dest_z;
	/*  4  */
	distance = from->distance;
	/*  5  */
	u5 = from->u5;
	
}


DoDestiny_SetBallTroll::DoDestiny_SetBallTroll() {
	/*  0  */
	update_name = "SetBallTroll";
	/*  1  */
	entityID = 0;
	maybeAnotherEntityID = 0;
}

DoDestiny_SetBallTroll::~DoDestiny_SetBallTroll() {
	/*  0  */
	/*  1  */
}

void DoDestiny_SetBallTroll::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBallTroll", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%smaybeAnotherEntityID=%lu", pfx, maybeAnotherEntityID);
}

PyRepTuple *DoDestiny_SetBallTroll::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepInteger(maybeAnotherEntityID);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBallTroll::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepInteger(maybeAnotherEntityID);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBallTroll::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBallTroll::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallTroll failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallTroll failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallTroll failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallTroll failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallTroll failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallTroll failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallTroll: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallTroll failed: maybeAnotherEntityID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallTroll: truncating 64 bit into into 32 bit int for field maybeAnotherEntityID");
	}
	maybeAnotherEntityID = int_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetBallTroll *DoDestiny_SetBallTroll::Clone() const {
	DoDestiny_SetBallTroll *res = new DoDestiny_SetBallTroll;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBallTroll::CloneFrom(const DoDestiny_SetBallTroll *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	maybeAnotherEntityID = from->maybeAnotherEntityID;
	
}


DoDestiny_SetBoid::DoDestiny_SetBoid() {
	/*  0  */
	update_name = "SetBoid";
	/*  1  */
	entityID = 0;
	maybeAnotherEntityID = 0;
}

DoDestiny_SetBoid::~DoDestiny_SetBoid() {
	/*  0  */
	/*  1  */
}

void DoDestiny_SetBoid::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBoid", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%smaybeAnotherEntityID=%lu", pfx, maybeAnotherEntityID);
}

PyRepTuple *DoDestiny_SetBoid::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepInteger(maybeAnotherEntityID);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBoid::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepInteger(maybeAnotherEntityID);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBoid::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBoid::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBoid failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBoid failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBoid failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBoid failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBoid failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBoid failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBoid: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBoid failed: maybeAnotherEntityID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBoid: truncating 64 bit into into 32 bit int for field maybeAnotherEntityID");
	}
	maybeAnotherEntityID = int_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetBoid *DoDestiny_SetBoid::Clone() const {
	DoDestiny_SetBoid *res = new DoDestiny_SetBoid;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBoid::CloneFrom(const DoDestiny_SetBoid *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	maybeAnotherEntityID = from->maybeAnotherEntityID;
	
}


DoDestiny_Orbit::DoDestiny_Orbit() {
	/*  0  */
	update_name = "Orbit";
	/*  1  */
	entityID = 0;
	orbitEntityID = 0;
	distance = 0;
}

DoDestiny_Orbit::~DoDestiny_Orbit() {
	/*  0  */
	/*  1  */
}

void DoDestiny_Orbit::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_Orbit", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%sorbitEntityID=%lu", pfx, orbitEntityID);
	_log(l_type, "%sdistance=%lu", pfx, distance);
}

PyRepTuple *DoDestiny_Orbit::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(3);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepInteger(orbitEntityID);
	tuple1->items[2] = new PyRepInteger(distance);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_Orbit::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(3);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepInteger(orbitEntityID);
	tuple1->items[2] = new PyRepInteger(distance);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_Orbit::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_Orbit::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Orbit failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Orbit failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Orbit failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Orbit failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Orbit failed: tuple2 is the wrong size: expected 3, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Orbit failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_Orbit: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Orbit failed: orbitEntityID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_Orbit: truncating 64 bit into into 32 bit int for field orbitEntityID");
	}
	orbitEntityID = int_4->value;
	if(!tuple2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_Orbit failed: distance is not an int: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_Orbit: truncating 64 bit into into 32 bit int for field distance");
	}
	distance = int_5->value;

	delete packet;
	return(true);
}

DoDestiny_Orbit *DoDestiny_Orbit::Clone() const {
	DoDestiny_Orbit *res = new DoDestiny_Orbit;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_Orbit::CloneFrom(const DoDestiny_Orbit *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	orbitEntityID = from->orbitEntityID;
	distance = from->distance;
	
}


DoDestiny_AddMushroom::DoDestiny_AddMushroom() {
	/*  0  */
	update_name = "AddMushroom";
	/*  1  */
	parentID = 0;
	/*  might be range  */
	unknown2 = 0.0;
	unknown3 = 0.0;
}

DoDestiny_AddMushroom::~DoDestiny_AddMushroom() {
	/*  0  */
	/*  1  */
	/*  might be range  */
}

void DoDestiny_AddMushroom::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_AddMushroom", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sparentID=%lu", pfx, parentID);
	/*  might be range  */
	_log(l_type, "%sunknown2=%.13f", pfx, unknown2);
	_log(l_type, "%sunknown3=%.13f", pfx, unknown3);
}

PyRepTuple *DoDestiny_AddMushroom::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(3);
	tuple1->items[0] = new PyRepInteger(parentID);
	/*  might be range  */
	tuple1->items[1] = new PyRepReal(unknown2);
	tuple1->items[2] = new PyRepReal(unknown3);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_AddMushroom::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(3);
	tuple1->items[0] = new PyRepInteger(parentID);
	/*  might be range  */
	tuple1->items[1] = new PyRepReal(unknown2);
	tuple1->items[2] = new PyRepReal(unknown3);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_AddMushroom::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_AddMushroom::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddMushroom failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddMushroom failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddMushroom failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddMushroom failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddMushroom failed: tuple2 is the wrong size: expected 3, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddMushroom failed: parentID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_AddMushroom: truncating 64 bit into into 32 bit int for field parentID");
	}
	parentID = int_3->value;
	/*  might be range  */
	if(!tuple2->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddMushroom failed: unknown2 is not a real: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) tuple2->items[1];
	unknown2 = real_4->value;
	if(!tuple2->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_AddMushroom failed: unknown3 is not a real: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple2->items[2];
	unknown3 = real_5->value;

	delete packet;
	return(true);
}

DoDestiny_AddMushroom *DoDestiny_AddMushroom::Clone() const {
	DoDestiny_AddMushroom *res = new DoDestiny_AddMushroom;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_AddMushroom::CloneFrom(const DoDestiny_AddMushroom *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	parentID = from->parentID;
	/*  might be range  */
	unknown2 = from->unknown2;
	unknown3 = from->unknown3;
	
}


DoDestiny_CloakBall::DoDestiny_CloakBall() {
	/*  0  */
	update_name = "CloakBall";
	/*  1  */
	entityID = 0;
	cloaked = false;
	/*  optional: maybe <real name="cloakMode" />  */
}

DoDestiny_CloakBall::~DoDestiny_CloakBall() {
	/*  0  */
	/*  1  */
	/*  optional: maybe <real name="cloakMode" />  */
}

void DoDestiny_CloakBall::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_CloakBall", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	_log(l_type, "%scloaked=%s", pfx, cloaked?"true":"false");
	/*  optional: maybe <real name="cloakMode" />  */
}

PyRepTuple *DoDestiny_CloakBall::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepBoolean(cloaked);
	/*  optional: maybe <real name="cloakMode" />  */
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_CloakBall::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	tuple1->items[1] = new PyRepBoolean(cloaked);
	/*  optional: maybe <real name="cloakMode" />  */
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_CloakBall::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_CloakBall::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_CloakBall failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_CloakBall failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_CloakBall failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_CloakBall failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_CloakBall failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_CloakBall failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_CloakBall: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	if(!tuple2->items[1]->CheckType(PyRep::Boolean)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_CloakBall failed: cloaked is not a boolean: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepBoolean *bool_4 = (PyRepBoolean *) tuple2->items[1];
	cloaked = bool_4->value;
	/*  optional: maybe <real name="cloakMode" />  */

	delete packet;
	return(true);
}

DoDestiny_CloakBall *DoDestiny_CloakBall::Clone() const {
	DoDestiny_CloakBall *res = new DoDestiny_CloakBall;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_CloakBall::CloneFrom(const DoDestiny_CloakBall *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	cloaked = from->cloaked;
	/*  optional: maybe <real name="cloakMode" />  */
	
}


OnDockingAccepted::OnDockingAccepted() {
	/*  0  */
	start_x = 0.0;
	start_y = 0.0;
	start_z = 0.0;
	/*  1: dup of previous list?  */
	end_x = 0.0;
	end_y = 0.0;
	end_z = 0.0;
	/*  2  */
	stationID = 0;
}

OnDockingAccepted::~OnDockingAccepted() {
	/*  0  */
	/*  1: dup of previous list?  */
	/*  2  */
}

void OnDockingAccepted::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sOnDockingAccepted", pfx);
	/*  0  */
	_log(l_type, "%sstart_x=%.13f", pfx, start_x);
	_log(l_type, "%sstart_y=%.13f", pfx, start_y);
	_log(l_type, "%sstart_z=%.13f", pfx, start_z);
	/*  1: dup of previous list?  */
	_log(l_type, "%send_x=%.13f", pfx, end_x);
	_log(l_type, "%send_y=%.13f", pfx, end_y);
	_log(l_type, "%send_z=%.13f", pfx, end_z);
	/*  2  */
	_log(l_type, "%sstationID=%lu", pfx, stationID);
}

PyRepTuple *OnDockingAccepted::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	list1->items[0] = new PyRepReal(start_x);
	list1->items[1] = new PyRepReal(start_y);
	list1->items[2] = new PyRepReal(start_z);
	tuple0->items[0] = list1;
	
	/*  1: dup of previous list?  */
	PyRepList *list2 = new PyRepList();
	list2->items.resize(3, NULL);
	list2->items[0] = new PyRepReal(end_x);
	list2->items[1] = new PyRepReal(end_y);
	list2->items[2] = new PyRepReal(end_z);
	tuple0->items[1] = list2;
	
	/*  2  */
	tuple0->items[2] = new PyRepInteger(stationID);
	res = tuple0;
	

	return(res);
}

PyRepTuple *OnDockingAccepted::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	PyRepList *list1 = new PyRepList();
	list1->items.resize(3, NULL);
	list1->items[0] = new PyRepReal(start_x);
	list1->items[1] = new PyRepReal(start_y);
	list1->items[2] = new PyRepReal(start_z);
	tuple0->items[0] = list1;
	
	/*  1: dup of previous list?  */
	PyRepList *list2 = new PyRepList();
	list2->items.resize(3, NULL);
	list2->items[0] = new PyRepReal(end_x);
	list2->items[1] = new PyRepReal(end_y);
	list2->items[2] = new PyRepReal(end_z);
	tuple0->items[1] = list2;
	
	/*  2  */
	tuple0->items[2] = new PyRepInteger(stationID);
	res = tuple0;
	

	return(res);
}

bool OnDockingAccepted::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool OnDockingAccepted::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: list1 is not a list: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list1 = (PyRepList *) tuple0->items[0];
	if(list1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: list1 is the wrong size: expected 3, but got %d", list1->items.size());
		delete packet;
		return(false);
	}

	if(!list1->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: start_x is not a real: %s", list1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_2 = (PyRepReal *) list1->items[0];
	start_x = real_2->value;
	if(!list1->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: start_y is not a real: %s", list1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_3 = (PyRepReal *) list1->items[1];
	start_y = real_3->value;
	if(!list1->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: start_z is not a real: %s", list1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_4 = (PyRepReal *) list1->items[2];
	start_z = real_4->value;
	/*  1: dup of previous list?  */
	if(!tuple0->items[1]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: list5 is not a list: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list5 = (PyRepList *) tuple0->items[1];
	if(list5->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: list5 is the wrong size: expected 3, but got %d", list5->items.size());
		delete packet;
		return(false);
	}

	if(!list5->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: end_x is not a real: %s", list5->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) list5->items[0];
	end_x = real_6->value;
	if(!list5->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: end_y is not a real: %s", list5->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_7 = (PyRepReal *) list5->items[1];
	end_y = real_7->value;
	if(!list5->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: end_z is not a real: %s", list5->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_8 = (PyRepReal *) list5->items[2];
	end_z = real_8->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode OnDockingAccepted failed: stationID is not an int: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_9 = (PyRepInteger *) tuple0->items[2];
	if(int_9->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode OnDockingAccepted: truncating 64 bit into into 32 bit int for field stationID");
	}
	stationID = int_9->value;

	delete packet;
	return(true);
}

OnDockingAccepted *OnDockingAccepted::Clone() const {
	OnDockingAccepted *res = new OnDockingAccepted;
	res->CloneFrom(this);
	return(res);
}

void OnDockingAccepted::CloneFrom(const OnDockingAccepted *from) {
	/*  0  */
	start_x = from->start_x;
	start_y = from->start_y;
	start_z = from->start_z;
	/*  1: dup of previous list?  */
	end_x = from->end_x;
	end_y = from->end_y;
	end_z = from->end_z;
	/*  2  */
	stationID = from->stationID;
	
}


DoDestiny_RemoveBall::DoDestiny_RemoveBall() {
	/*  0: method  */
	update_name = "RemoveBall";
	/*  1: arguments  */
	entityID = 0;
	/*  there is an unknown optional int arg which may follow  */
}

DoDestiny_RemoveBall::~DoDestiny_RemoveBall() {
	/*  0: method  */
	/*  1: arguments  */
	/*  there is an unknown optional int arg which may follow  */
}

void DoDestiny_RemoveBall::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_RemoveBall", pfx);
	/*  0: method  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1: arguments  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  there is an unknown optional int arg which may follow  */
}

PyRepTuple *DoDestiny_RemoveBall::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: method  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1: arguments  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  there is an unknown optional int arg which may follow  */
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_RemoveBall::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: method  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1: arguments  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  there is an unknown optional int arg which may follow  */
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_RemoveBall::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_RemoveBall::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBall failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBall failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: method  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBall failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1: arguments  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBall failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBall failed: tuple2 is the wrong size: expected 1, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBall failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_RemoveBall: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  there is an unknown optional int arg which may follow  */

	delete packet;
	return(true);
}

DoDestiny_RemoveBall *DoDestiny_RemoveBall::Clone() const {
	DoDestiny_RemoveBall *res = new DoDestiny_RemoveBall;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_RemoveBall::CloneFrom(const DoDestiny_RemoveBall *from) {
	/*  0: method  */
	update_name = from->update_name;
	/*  1: arguments  */
	entityID = from->entityID;
	/*  there is an unknown optional int arg which may follow  */
	
}


DoDestiny_RemoveBalls::DoDestiny_RemoveBalls() {
	/*  0: method  */
	update_name = "RemoveBalls";
	/*  1: arguments  */
}

DoDestiny_RemoveBalls::~DoDestiny_RemoveBalls() {
	/*  0: method  */
	/*  1: arguments  */
}

void DoDestiny_RemoveBalls::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_RemoveBalls", pfx);
	/*  0: method  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1: arguments  */
	_log(l_type, "%sballs: Integer list with %d enetires", pfx, balls.size());
	std::vector<uint32>::const_iterator balls_cur, balls_end;
	balls_cur = balls.begin();
	balls_end = balls.end();
	int balls_index;
	for(balls_index = 0; balls_cur != balls_end; balls_cur++, balls_index++) {
		_log(l_type, "%s   [%02d] %d", pfx, balls_index, *balls_cur);
	}
	
}

PyRepTuple *DoDestiny_RemoveBalls::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: method  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1: arguments  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator balls_cur, balls_end;
	balls_cur = balls.begin();
	balls_end = balls.end();
	for(; balls_cur != balls_end; balls_cur++) {
		list2->items.push_back(
			new PyRepInteger(*balls_cur)
		);
	}
	tuple1->items[0] = list2;
	
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_RemoveBalls::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0: method  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1: arguments  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	
	PyRepList *list2 = new PyRepList();
	std::vector<uint32>::iterator balls_cur, balls_end;
	balls_cur = balls.begin();
	balls_end = balls.end();
	for(; balls_cur != balls_end; balls_cur++) {
		list2->items.push_back(
			new PyRepInteger(*balls_cur)
		);
	}
	tuple1->items[0] = list2;
	
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_RemoveBalls::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_RemoveBalls::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBalls failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBalls failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0: method  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBalls failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1: arguments  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBalls failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBalls failed: tuple2 is the wrong size: expected 1, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBalls failed: balls is not a list: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	balls.clear();
	PyRepList *list_3 = (PyRepList *) tuple2->items[0];
	PyRepList::iterator balls_cur, balls_end;
	balls_cur = list_3->items.begin();
	balls_end = list_3->items.end();
	int balls_index;
	for(balls_index = 0; balls_cur != balls_end; balls_cur++, balls_index++) {
		if(!(*balls_cur)->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_RemoveBalls failed: Element %d in list balls is not an integer: %s", balls_index, (*balls_cur)->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *t = (PyRepInteger *) (*balls_cur);
		if(t->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode DoDestiny_RemoveBalls: truncating 64 bit into into 32 bit int for item %d in field balls", balls_index);
		}
		balls.push_back(t->value);
	}


	delete packet;
	return(true);
}

DoDestiny_RemoveBalls *DoDestiny_RemoveBalls::Clone() const {
	DoDestiny_RemoveBalls *res = new DoDestiny_RemoveBalls;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_RemoveBalls::CloneFrom(const DoDestiny_RemoveBalls *from) {
	/*  0: method  */
	update_name = from->update_name;
	/*  1: arguments  */
	balls = from->balls;
	
}


SetState_DamageState::SetState_DamageState() {
	/*  0  */
	/*  0  */
	unknown00 = 0.0;
	/*  1  */
	unknown01 = 0.0;
	/*  2  */
	timestamp = 0;
	/*  1  */
	unknown1 = 0.0;
	/*  2  */
	unknown2 = 0.0;
}

SetState_DamageState::~SetState_DamageState() {
	/*  0  */
	/*  0  */
	/*  1  */
	/*  2  */
	/*  1  */
	/*  2  */
}

void SetState_DamageState::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sSetState_DamageState", pfx);
	/*  0  */
	/*  0  */
	_log(l_type, "%sunknown00=%.13f", pfx, unknown00);
	/*  1  */
	_log(l_type, "%sunknown01=%.13f", pfx, unknown01);
	/*  2  */
	_log(l_type, "%stimestamp=" I64u, pfx, timestamp);
	/*  1  */
	_log(l_type, "%sunknown1=%.13f", pfx, unknown1);
	/*  2  */
	_log(l_type, "%sunknown2=%.13f", pfx, unknown2);
}

PyRepTuple *SetState_DamageState::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	tuple1->items[0] = new PyRepReal(unknown00);
	/*  1  */
	tuple1->items[1] = new PyRepReal(unknown01);
	/*  2  */
	tuple1->items[2] = new PyRepInteger(timestamp);
	tuple0->items[0] = tuple1;
	
	/*  1  */
	tuple0->items[1] = new PyRepReal(unknown1);
	/*  2  */
	tuple0->items[2] = new PyRepReal(unknown2);
	res = tuple0;
	

	return(res);
}

PyRepTuple *SetState_DamageState::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(3);
	/*  0  */
	PyRepTuple *tuple1 = new PyRepTuple(3);
	/*  0  */
	tuple1->items[0] = new PyRepReal(unknown00);
	/*  1  */
	tuple1->items[1] = new PyRepReal(unknown01);
	/*  2  */
	tuple1->items[2] = new PyRepInteger(timestamp);
	tuple0->items[0] = tuple1;
	
	/*  1  */
	tuple0->items[1] = new PyRepReal(unknown1);
	/*  2  */
	tuple0->items[2] = new PyRepReal(unknown2);
	res = tuple0;
	

	return(res);
}

bool SetState_DamageState::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool SetState_DamageState::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode SetState_DamageState failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode SetState_DamageState failed: tuple0 is the wrong size: expected 3, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode SetState_DamageState failed: tuple1 is the wrong type: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple1 = (PyRepTuple *) tuple0->items[0];
	if(tuple1->items.size() != 3) {
		_log(NET__PACKET_ERROR, "Decode SetState_DamageState failed: tuple1 is the wrong size: expected 3, but got %d", tuple1->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple1->items[0]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode SetState_DamageState failed: unknown00 is not a real: %s", tuple1->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_2 = (PyRepReal *) tuple1->items[0];
	unknown00 = real_2->value;
	/*  1  */
	if(!tuple1->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode SetState_DamageState failed: unknown01 is not a real: %s", tuple1->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_3 = (PyRepReal *) tuple1->items[1];
	unknown01 = real_3->value;
	/*  2  */
	if(!tuple1->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode SetState_DamageState failed: timestamp is not an int: %s", tuple1->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int64_4 = (PyRepInteger *) tuple1->items[2];
	timestamp = int64_4->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode SetState_DamageState failed: unknown1 is not a real: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_5 = (PyRepReal *) tuple0->items[1];
	unknown1 = real_5->value;
	/*  2  */
	if(!tuple0->items[2]->CheckType(PyRep::Real)) {
		_log(NET__PACKET_ERROR, "Decode SetState_DamageState failed: unknown2 is not a real: %s", tuple0->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepReal *real_6 = (PyRepReal *) tuple0->items[2];
	unknown2 = real_6->value;

	delete packet;
	return(true);
}

SetState_DamageState *SetState_DamageState::Clone() const {
	SetState_DamageState *res = new SetState_DamageState;
	res->CloneFrom(this);
	return(res);
}

void SetState_DamageState::CloneFrom(const SetState_DamageState *from) {
	/*  0  */
	/*  0  */
	unknown00 = from->unknown00;
	/*  1  */
	unknown01 = from->unknown01;
	/*  2  */
	timestamp = from->timestamp;
	/*  1  */
	unknown1 = from->unknown1;
	/*  2  */
	unknown2 = from->unknown2;
	
}


DoDestiny_SetState::DoDestiny_SetState() {
	/*  0  */
	update_name = "SetState";
	/*  1  */
	/*  0  */
	/* object of type util.KeyVal */
	stamp = 0;
	/*  List of tuples, 3 elements: (gangID? int 7072859, int 692524420, None) */
	/*  this is the big nasty state buffer  */
	destiny_state = NULL;
	ego = 0;
	/*  maps from an entity ID (I think) to a SetState_DamageState struct  */
	/*  maps from an entity ID (I think) to a tuple: (entityID, timestamp)  */
	/*  rowset: droneID, ownerID, controllerID, activityState, typeID, controllerOwnerID  */
	/* <element type="util_Rowset" name="droneState" /> */
	droneState = NULL;
	/*  DBRow itemID,typeID,ownerID,locationID,flag,contraband,singleton,quantity,groupID,categoryID,customInfo    */
	solItem = NULL;
	/*  not really an intlist, only seen it smpty right now  */
	/*  not really an intlist, each element should be a tuple: (694930434, 7088433)  */
}

DoDestiny_SetState::~DoDestiny_SetState() {
	/*  0  */
	/*  1  */
	/*  0  */
	/*  List of tuples, 3 elements: (gangID? int 7072859, int 692524420, None) */
	/*  this is the big nasty state buffer  */
	delete destiny_state;
	/*  maps from an entity ID (I think) to a SetState_DamageState struct  */
	std::map<uint32, PyRep *>::iterator damageState_cur, damageState_end;
	//free any existing elements first
	damageState_cur = damageState.begin();
	damageState_end = damageState.end();
	for(; damageState_cur != damageState_end; damageState_cur++) {
		delete damageState_cur->second;
	}
	
	/*  maps from an entity ID (I think) to a tuple: (entityID, timestamp)  */
	std::map<uint32, PyRep *>::iterator aggressors_cur, aggressors_end;
	//free any existing elements first
	aggressors_cur = aggressors.begin();
	aggressors_end = aggressors.end();
	for(; aggressors_cur != aggressors_end; aggressors_cur++) {
		delete aggressors_cur->second;
	}
	
	/*  rowset: droneID, ownerID, controllerID, activityState, typeID, controllerOwnerID  */
	/* <element type="util_Rowset" name="droneState" /> */
	delete droneState;
	/*  DBRow itemID,typeID,ownerID,locationID,flag,contraband,singleton,quantity,groupID,categoryID,customInfo    */
	delete solItem;
	/*  not really an intlist, only seen it smpty right now  */
	/*  not really an intlist, each element should be a tuple: (694930434, 7088433)  */
}

void DoDestiny_SetState::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetState", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0  */
	_log(l_type, "%sObject of type util.KeyVal:", pfx);
	_log(l_type, "%sstamp=%lu", pfx, stamp);
	/*  List of tuples, 3 elements: (gangID? int 7072859, int 692524420, None) */
	_log(l_type, "%sgangCorps: ", pfx);
	std::string gangCorps_n(pfx);
	gangCorps_n += "    ";
	gangCorps.Dump(l_type, gangCorps_n.c_str());
	/*  this is the big nasty state buffer  */
	_log(l_type, "%sdestiny_state: ", pfx);
	std::string destiny_state_n(pfx);
	destiny_state_n += "    ";
	destiny_state->Dump(l_type, destiny_state_n.c_str());
	_log(l_type, "%sego=%lu", pfx, ego);
	/*  maps from an entity ID (I think) to a SetState_DamageState struct  */
	_log(l_type, "%sdamageState: Dictionaty with %d enetires", pfx, damageState.size());
	std::map<uint32, PyRep *>::const_iterator damageState_cur, damageState_end;
	damageState_cur = damageState.begin();
	damageState_end = damageState.end();
	for(; damageState_cur != damageState_end; damageState_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, damageState_cur->first);
		std::string n(pfx);
		n += "        ";
		damageState_cur->second->Dump(stdout, n.c_str());
	}
	
	/*  maps from an entity ID (I think) to a tuple: (entityID, timestamp)  */
	_log(l_type, "%saggressors: Dictionaty with %d enetires", pfx, aggressors.size());
	std::map<uint32, PyRep *>::const_iterator aggressors_cur, aggressors_end;
	aggressors_cur = aggressors.begin();
	aggressors_end = aggressors.end();
	for(; aggressors_cur != aggressors_end; aggressors_cur++) {
		_log(l_type, "%s   Key: %lu", pfx, aggressors_cur->first);
		std::string n(pfx);
		n += "        ";
		aggressors_cur->second->Dump(stdout, n.c_str());
	}
	
	/*  rowset: droneID, ownerID, controllerID, activityState, typeID, controllerOwnerID  */
	/* <element type="util_Rowset" name="droneState" /> */
	_log(l_type, "%sdroneState:", pfx);
	std::string droneState_n(pfx);
	droneState_n += "    ";
	if(droneState == NULL) {
		_log(l_type, "%sERROR: NULL REP!", droneState_n.c_str());
	} else {
		droneState->Dump(l_type, droneState_n.c_str());
	}
	_log(l_type, "%sslims: ", pfx);
	std::string slims_n(pfx);
	slims_n += "    ";
	slims.Dump(l_type, slims_n.c_str());
	/*  DBRow itemID,typeID,ownerID,locationID,flag,contraband,singleton,quantity,groupID,categoryID,customInfo    */
	_log(l_type, "%ssolItem:", pfx);
	std::string solItem_n(pfx);
	solItem_n += "    ";
	if(solItem == NULL) {
		_log(l_type, "%sERROR: NULL REP!", solItem_n.c_str());
	} else {
		solItem->Dump(l_type, solItem_n.c_str());
	}
	/*  not really an intlist, only seen it smpty right now  */
	_log(l_type, "%seffectStates: ", pfx);
	std::string effectStates_n(pfx);
	effectStates_n += "    ";
	effectStates.Dump(l_type, effectStates_n.c_str());
	/*  not really an intlist, each element should be a tuple: (694930434, 7088433)  */
	_log(l_type, "%scharGangs: ", pfx);
	std::string charGangs_n(pfx);
	charGangs_n += "    ";
	charGangs.Dump(l_type, charGangs_n.c_str());
}

PyRepTuple *DoDestiny_SetState::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	PyRep *args2;
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	dict3_0 = new PyRepInteger(stamp);
	dict3->items[
		new PyRepString("stamp")
	] = dict3_0;
	PyRep *dict3_1;
	/*  List of tuples, 3 elements: (gangID? int 7072859, int 692524420, None) */
	dict3_1 = gangCorps.Clone();
	dict3->items[
		new PyRepString("gangCorps")
	] = dict3_1;
	PyRep *dict3_2;
	/*  this is the big nasty state buffer  */
	if(destiny_state == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_SetState: destiny_state is NULL! hacking in an empty buffer.");
		destiny_state = new PyRepBuffer(0);
	}
	dict3_2 = destiny_state->Clone();
	dict3->items[
		new PyRepString("state")
	] = dict3_2;
	PyRep *dict3_3;
	dict3_3 = new PyRepInteger(ego);
	dict3->items[
		new PyRepString("ego")
	] = dict3_3;
	PyRep *dict3_4;
	/*  maps from an entity ID (I think) to a SetState_DamageState struct  */
	
	PyRepDict *dict4 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator damageState_cur, damageState_end;
	damageState_cur = damageState.begin();
	damageState_end = damageState.end();
	for(; damageState_cur != damageState_end; damageState_cur++) {
		dict4->items[
			new PyRepInteger(damageState_cur->first)
		] = damageState_cur->second->Clone();
	}
	dict3_4 = dict4;
	
	dict3->items[
		new PyRepString("damageState")
	] = dict3_4;
	PyRep *dict3_5;
	/*  maps from an entity ID (I think) to a tuple: (entityID, timestamp)  */
	
	PyRepDict *dict5 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator aggressors_cur, aggressors_end;
	aggressors_cur = aggressors.begin();
	aggressors_end = aggressors.end();
	for(; aggressors_cur != aggressors_end; aggressors_cur++) {
		dict5->items[
			new PyRepInteger(aggressors_cur->first)
		] = aggressors_cur->second->Clone();
	}
	dict3_5 = dict5;
	
	dict3->items[
		new PyRepString("aggressors")
	] = dict3_5;
	PyRep *dict3_6;
	/*  rowset: droneID, ownerID, controllerID, activityState, typeID, controllerOwnerID  */
	/* <element type="util_Rowset" name="droneState" /> */
	if(droneState == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_SetState: droneState is NULL! hacking in a PyRepNone");
		droneState = new PyRepNone();
	}
	dict3_6 = droneState->Clone();
	dict3->items[
		new PyRepString("droneState")
	] = dict3_6;
	PyRep *dict3_7;
	dict3_7 = slims.Clone();
	dict3->items[
		new PyRepString("slims")
	] = dict3_7;
	PyRep *dict3_8;
	/*  DBRow itemID,typeID,ownerID,locationID,flag,contraband,singleton,quantity,groupID,categoryID,customInfo    */
	if(solItem == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_SetState: solItem is NULL! hacking in a PyRepNone");
		solItem = new PyRepNone();
	}
	dict3_8 = solItem->Clone();
	dict3->items[
		new PyRepString("solItem")
	] = dict3_8;
	PyRep *dict3_9;
	/*  not really an intlist, only seen it smpty right now  */
	dict3_9 = effectStates.Clone();
	dict3->items[
		new PyRepString("effectStates")
	] = dict3_9;
	PyRep *dict3_10;
	/*  not really an intlist, each element should be a tuple: (694930434, 7088433)  */
	dict3_10 = charGangs.Clone();
	dict3->items[
		new PyRepString("charGangs")
	] = dict3_10;
	args2 = dict3;
	
	tuple1->items[0] = new PyRepObject(
			"util.KeyVal",
			args2
		);
	
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetState::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(1);
	/*  0  */
	PyRep *args2;
	PyRepDict *dict3 = new PyRepDict();
	PyRep *dict3_0;
	dict3_0 = new PyRepInteger(stamp);
	dict3->items[
		new PyRepString("stamp")
	] = dict3_0;
	PyRep *dict3_1;
	/*  List of tuples, 3 elements: (gangID? int 7072859, int 692524420, None) */
	
	PyRepList *list4 = new PyRepList();
	list4->items = gangCorps.items;
	gangCorps.items.clear();
	dict3_1 = list4;
	dict3->items[
		new PyRepString("gangCorps")
	] = dict3_1;
	PyRep *dict3_2;
	/*  this is the big nasty state buffer  */
	if(destiny_state == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_SetState: destiny_state is NULL! hacking in an empty buffer.");
		destiny_state = new PyRepBuffer(0);
	}
	dict3_2 = destiny_state;
	destiny_state = NULL;
	dict3->items[
		new PyRepString("state")
	] = dict3_2;
	PyRep *dict3_3;
	dict3_3 = new PyRepInteger(ego);
	dict3->items[
		new PyRepString("ego")
	] = dict3_3;
	PyRep *dict3_4;
	/*  maps from an entity ID (I think) to a SetState_DamageState struct  */
	
	PyRepDict *dict5 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator damageState_cur, damageState_end;
	damageState_cur = damageState.begin();
	damageState_end = damageState.end();
	for(; damageState_cur != damageState_end; damageState_cur++) {
		dict5->items[
			new PyRepInteger(damageState_cur->first)
		] = damageState_cur->second;
	}
	damageState.clear();
	dict3_4 = dict5;
	
	dict3->items[
		new PyRepString("damageState")
	] = dict3_4;
	PyRep *dict3_5;
	/*  maps from an entity ID (I think) to a tuple: (entityID, timestamp)  */
	
	PyRepDict *dict6 = new PyRepDict();
	std::map<uint32, PyRep *>::iterator aggressors_cur, aggressors_end;
	aggressors_cur = aggressors.begin();
	aggressors_end = aggressors.end();
	for(; aggressors_cur != aggressors_end; aggressors_cur++) {
		dict6->items[
			new PyRepInteger(aggressors_cur->first)
		] = aggressors_cur->second;
	}
	aggressors.clear();
	dict3_5 = dict6;
	
	dict3->items[
		new PyRepString("aggressors")
	] = dict3_5;
	PyRep *dict3_6;
	/*  rowset: droneID, ownerID, controllerID, activityState, typeID, controllerOwnerID  */
	/* <element type="util_Rowset" name="droneState" /> */
	if(droneState == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_SetState: droneState is NULL! hacking in a PyRepNone");
		droneState = new PyRepNone();
	}
	dict3_6 = droneState;
	droneState = NULL;
	dict3->items[
		new PyRepString("droneState")
	] = dict3_6;
	PyRep *dict3_7;
	
	PyRepList *list7 = new PyRepList();
	list7->items = slims.items;
	slims.items.clear();
	dict3_7 = list7;
	dict3->items[
		new PyRepString("slims")
	] = dict3_7;
	PyRep *dict3_8;
	/*  DBRow itemID,typeID,ownerID,locationID,flag,contraband,singleton,quantity,groupID,categoryID,customInfo    */
	if(solItem == NULL) {
		_log(NET__PACKET_ERROR, "Encode DoDestiny_SetState: solItem is NULL! hacking in a PyRepNone");
		solItem = new PyRepNone();
	}
	dict3_8 = solItem;
	solItem = NULL;
	dict3->items[
		new PyRepString("solItem")
	] = dict3_8;
	PyRep *dict3_9;
	/*  not really an intlist, only seen it smpty right now  */
	
	PyRepList *list8 = new PyRepList();
	list8->items = effectStates.items;
	effectStates.items.clear();
	dict3_9 = list8;
	dict3->items[
		new PyRepString("effectStates")
	] = dict3_9;
	PyRep *dict3_10;
	/*  not really an intlist, each element should be a tuple: (694930434, 7088433)  */
	
	PyRepList *list9 = new PyRepList();
	list9->items = charGangs.items;
	charGangs.items.clear();
	dict3_10 = list9;
	dict3->items[
		new PyRepString("charGangs")
	] = dict3_10;
	args2 = dict3;
	
	tuple1->items[0] = new PyRepObject(
			"util.KeyVal",
			args2
		);
	
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetState::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetState::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 1) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: tuple2 is the wrong size: expected 1, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple2->items[0]->CheckType(PyRep::Object)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: obj_3 is the wrong type: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepObject *obj_3 = (PyRepObject *) tuple2->items[0];
	
	if(obj_3->type != "util.KeyVal") {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: obj_3 is the wrong object type. Expected 'util.KeyVal', got '%s'", obj_3->type.c_str());
		delete packet;
		return(false);
	}
	
	if(!obj_3->arguments->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: dict4 is the wrong type: %s", obj_3->arguments->TypeString());
		delete packet;
		return(false);
	}
	bool dict4_stamp = false;
	bool dict4_gangCorps = false;
	bool dict4_destiny_state = false;
	bool dict4_ego = false;
	bool dict4_damageState = false;
	bool dict4_aggressors = false;
	bool dict4_droneState = false;
	bool dict4_slims = false;
	bool dict4_solItem = false;
	bool dict4_effectStates = false;
	bool dict4_charGangs = false;
	PyRepDict *dict4 = (PyRepDict *) obj_3->arguments;
	
	PyRepDict::iterator dict4_cur, dict4_end;
	dict4_cur = dict4->items.begin();
	dict4_end = dict4->items.end();
	for(; dict4_cur != dict4_end; dict4_cur++) {
		PyRep *key__ = dict4_cur->first;
		if(!key__->CheckType(PyRep::String)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: a key in dict4 is the wrong type: %s", key__->TypeString());
			delete packet;
			return(false);
		}
		PyRepString *key_string__ = (PyRepString *) key__;
		
		if(key_string__->value == "stamp") {
			dict4_stamp = true;
	if(!dict4_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: stamp is not an int: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) dict4_cur->second;
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetState: truncating 64 bit into into 32 bit int for field stamp");
	}
	stamp = int_5->value;
		} else
		if(key_string__->value == "gangCorps") {
			dict4_gangCorps = true;
	/*  List of tuples, 3 elements: (gangID? int 7072859, int 692524420, None) */
	if(!dict4_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: gangCorps is not a list: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_gangCorps = (PyRepList *) dict4_cur->second;	gangCorps.items = list_gangCorps->items;
	list_gangCorps->items.clear();
	
		} else
		if(key_string__->value == "state") {
			dict4_destiny_state = true;
	/*  this is the big nasty state buffer  */
	if(dict4_cur->second->CheckType(PyRep::Buffer)) {
		destiny_state = (PyRepBuffer *) dict4_cur->second;
		dict4_cur->second = NULL;
	} else if(dict4_cur->second->CheckType(PyRep::String)) {
		PyRepString *__sss = (PyRepString *) dict4_cur->second;
		dict4_cur->second = NULL;
		destiny_state = new PyRepBuffer((const byte *) __sss->value.c_str(), __sss->value.length());
		delete __sss;
	} else {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: destiny_state is not a buffer: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	
		} else
		if(key_string__->value == "ego") {
			dict4_ego = true;
	if(!dict4_cur->second->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: ego is not an int: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) dict4_cur->second;
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetState: truncating 64 bit into into 32 bit int for field ego");
	}
	ego = int_6->value;
		} else
		if(key_string__->value == "damageState") {
			dict4_damageState = true;
	/*  maps from an entity ID (I think) to a SetState_DamageState struct  */
	if(!dict4_cur->second->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: damageState is not a dict: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	damageState.clear();
	PyRepDict *dict_7 = (PyRepDict *) dict4_cur->second;
	PyRepDict::iterator damageState_cur, damageState_end;
	damageState_cur = dict_7->items.begin();
	damageState_end = dict_7->items.end();
	int damageState_index;
	for(damageState_index = 0; damageState_cur != damageState_end; damageState_cur++, damageState_index++) {
		if(!damageState_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Key %d in dict damageState is not an integer: %s", damageState_index, damageState_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) damageState_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode DoDestiny_SetState: truncating 64 bit into into 32 bit int in key of entry %d in field damageState", damageState_index);
		}
		damageState[k->value] = damageState_cur->second->Clone();
	}
	
		} else
		if(key_string__->value == "aggressors") {
			dict4_aggressors = true;
	/*  maps from an entity ID (I think) to a tuple: (entityID, timestamp)  */
	if(!dict4_cur->second->CheckType(PyRep::Dict)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: aggressors is not a dict: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	aggressors.clear();
	PyRepDict *dict_8 = (PyRepDict *) dict4_cur->second;
	PyRepDict::iterator aggressors_cur, aggressors_end;
	aggressors_cur = dict_8->items.begin();
	aggressors_end = dict_8->items.end();
	int aggressors_index;
	for(aggressors_index = 0; aggressors_cur != aggressors_end; aggressors_cur++, aggressors_index++) {
		if(!aggressors_cur->first->CheckType(PyRep::Integer)) {
			_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Key %d in dict aggressors is not an integer: %s", aggressors_index, aggressors_cur->first->TypeString());
			delete packet;
			return(false);
		}
		PyRepInteger *k = (PyRepInteger *) aggressors_cur->first;
		if(k->value > 0xFFFFFFFFLL) {
			_log(NET__PACKET_WARNING, "Decode DoDestiny_SetState: truncating 64 bit into into 32 bit int in key of entry %d in field aggressors", aggressors_index);
		}
		aggressors[k->value] = aggressors_cur->second->Clone();
	}
	
		} else
		if(key_string__->value == "droneState") {
			dict4_droneState = true;
	/*  rowset: droneID, ownerID, controllerID, activityState, typeID, controllerOwnerID  */
	/* <element type="util_Rowset" name="droneState" /> */
	delete droneState;
	droneState = dict4_cur->second;
	dict4_cur->second = NULL;
	
		} else
		if(key_string__->value == "slims") {
			dict4_slims = true;
	if(!dict4_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: slims is not a list: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_slims = (PyRepList *) dict4_cur->second;	slims.items = list_slims->items;
	list_slims->items.clear();
	
		} else
		if(key_string__->value == "solItem") {
			dict4_solItem = true;
	/*  DBRow itemID,typeID,ownerID,locationID,flag,contraband,singleton,quantity,groupID,categoryID,customInfo    */
	delete solItem;
	solItem = dict4_cur->second;
	dict4_cur->second = NULL;
	
		} else
		if(key_string__->value == "effectStates") {
			dict4_effectStates = true;
	/*  not really an intlist, only seen it smpty right now  */
	if(!dict4_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: effectStates is not a list: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_effectStates = (PyRepList *) dict4_cur->second;	effectStates.items = list_effectStates->items;
	list_effectStates->items.clear();
	
		} else
		if(key_string__->value == "charGangs") {
			dict4_charGangs = true;
	/*  not really an intlist, each element should be a tuple: (694930434, 7088433)  */
	if(!dict4_cur->second->CheckType(PyRep::List)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: charGangs is not a list: %s", dict4_cur->second->TypeString());
		delete packet;
		return(false);
	}
	PyRepList *list_charGangs = (PyRepList *) dict4_cur->second;	charGangs.items = list_charGangs->items;
	list_charGangs->items.clear();
	
		} else
		{
			_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Unknown key string '%s' in dict4", key_string__->value.c_str());
			delete packet;
			return(false);
		}
	}
	
	if(!dict4_stamp) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'stamp' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_gangCorps) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'gangCorps' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_destiny_state) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'destiny_state' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_ego) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'ego' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_damageState) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'damageState' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_aggressors) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'aggressors' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_droneState) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'droneState' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_slims) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'slims' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_solItem) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'solItem' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_effectStates) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'effectStates' in dict4");
		delete packet;
		return(false);
	}
	
	if(!dict4_charGangs) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetState failed: Missing dict entry for 'charGangs' in dict4");
		delete packet;
		return(false);
	}
	

	delete packet;
	return(true);
}

DoDestiny_SetState *DoDestiny_SetState::Clone() const {
	DoDestiny_SetState *res = new DoDestiny_SetState;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetState::CloneFrom(const DoDestiny_SetState *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0  */
	/* object of type util.KeyVal */
	stamp = from->stamp;
	/*  List of tuples, 3 elements: (gangID? int 7072859, int 692524420, None) */
	gangCorps.CloneFrom(&from->gangCorps);
	/*  this is the big nasty state buffer  */
	delete destiny_state;
	if(from->destiny_state == NULL) {
		destiny_state = NULL;
	} else {
		destiny_state = from->destiny_state->TypedClone();
	}
	ego = from->ego;
	/*  maps from an entity ID (I think) to a SetState_DamageState struct  */
	std::map<uint32, PyRep *>::const_iterator damageState_cur, damageState_end;
	//free any existing elements first
	damageState_cur = damageState.begin();
	damageState_end = damageState.end();
	for(; damageState_cur != damageState_end; damageState_cur++) {
		delete damageState_cur->second;
	}
	damageState.clear();
	//now we can copy in the new ones...
	damageState_cur = from->damageState.begin();
	damageState_end = from->damageState.end();
	for(; damageState_cur != damageState_end; damageState_cur++) {
		damageState[damageState_cur->first] = damageState_cur->second->Clone();
	}
	
	/*  maps from an entity ID (I think) to a tuple: (entityID, timestamp)  */
	std::map<uint32, PyRep *>::const_iterator aggressors_cur, aggressors_end;
	//free any existing elements first
	aggressors_cur = aggressors.begin();
	aggressors_end = aggressors.end();
	for(; aggressors_cur != aggressors_end; aggressors_cur++) {
		delete aggressors_cur->second;
	}
	aggressors.clear();
	//now we can copy in the new ones...
	aggressors_cur = from->aggressors.begin();
	aggressors_end = from->aggressors.end();
	for(; aggressors_cur != aggressors_end; aggressors_cur++) {
		aggressors[aggressors_cur->first] = aggressors_cur->second->Clone();
	}
	
	/*  rowset: droneID, ownerID, controllerID, activityState, typeID, controllerOwnerID  */
	/* <element type="util_Rowset" name="droneState" /> */
	delete droneState;
	if(from->droneState == NULL) {
		droneState = NULL;
	} else {
		droneState = from->droneState->Clone();
	}
	slims.CloneFrom(&from->slims);
	/*  DBRow itemID,typeID,ownerID,locationID,flag,contraband,singleton,quantity,groupID,categoryID,customInfo    */
	delete solItem;
	if(from->solItem == NULL) {
		solItem = NULL;
	} else {
		solItem = from->solItem->Clone();
	}
	/*  not really an intlist, only seen it smpty right now  */
	effectStates.CloneFrom(&from->effectStates);
	/*  not really an intlist, each element should be a tuple: (694930434, 7088433)  */
	charGangs.CloneFrom(&from->charGangs);
	
}


DoDestiny_OnDroneStateChange::DoDestiny_OnDroneStateChange() {
	/*  0  */
	update_name = "OnDroneStateChange";
	/*  1  */
	/*  0: droneID  */
	droneID = 0;
	/*  1: ownerID  */
	ownerID = 0;
	/*  2: controllerID (ship ID)  */
	controllerID = 0;
	/*  3: activityState  */
	activityState = 0;
	/*  4: droneTypeID  */
	droneTypeID = 0;
	/*  2: controllerOwnerID (ship's owner ID)  */
	controllerOwnerID = 0;
}

DoDestiny_OnDroneStateChange::~DoDestiny_OnDroneStateChange() {
	/*  0  */
	/*  1  */
	/*  0: droneID  */
	/*  1: ownerID  */
	/*  2: controllerID (ship ID)  */
	/*  3: activityState  */
	/*  4: droneTypeID  */
	/*  2: controllerOwnerID (ship's owner ID)  */
}

void DoDestiny_OnDroneStateChange::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_OnDroneStateChange", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0: droneID  */
	_log(l_type, "%sdroneID=%lu", pfx, droneID);
	/*  1: ownerID  */
	_log(l_type, "%sownerID=%lu", pfx, ownerID);
	/*  2: controllerID (ship ID)  */
	_log(l_type, "%scontrollerID=%lu", pfx, controllerID);
	/*  3: activityState  */
	_log(l_type, "%sactivityState=%lu", pfx, activityState);
	/*  4: droneTypeID  */
	_log(l_type, "%sdroneTypeID=%lu", pfx, droneTypeID);
	/*  2: controllerOwnerID (ship's owner ID)  */
	_log(l_type, "%scontrollerOwnerID=%lu", pfx, controllerOwnerID);
}

PyRepTuple *DoDestiny_OnDroneStateChange::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(6);
	/*  0: droneID  */
	tuple1->items[0] = new PyRepInteger(droneID);
	/*  1: ownerID  */
	tuple1->items[1] = new PyRepInteger(ownerID);
	/*  2: controllerID (ship ID)  */
	tuple1->items[2] = new PyRepInteger(controllerID);
	/*  3: activityState  */
	tuple1->items[3] = new PyRepInteger(activityState);
	/*  4: droneTypeID  */
	tuple1->items[4] = new PyRepInteger(droneTypeID);
	/*  2: controllerOwnerID (ship's owner ID)  */
	tuple1->items[5] = new PyRepInteger(controllerOwnerID);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_OnDroneStateChange::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(6);
	/*  0: droneID  */
	tuple1->items[0] = new PyRepInteger(droneID);
	/*  1: ownerID  */
	tuple1->items[1] = new PyRepInteger(ownerID);
	/*  2: controllerID (ship ID)  */
	tuple1->items[2] = new PyRepInteger(controllerID);
	/*  3: activityState  */
	tuple1->items[3] = new PyRepInteger(activityState);
	/*  4: droneTypeID  */
	tuple1->items[4] = new PyRepInteger(droneTypeID);
	/*  2: controllerOwnerID (ship's owner ID)  */
	tuple1->items[5] = new PyRepInteger(controllerOwnerID);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_OnDroneStateChange::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_OnDroneStateChange::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 6) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: tuple2 is the wrong size: expected 6, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0: droneID  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: droneID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnDroneStateChange: truncating 64 bit into into 32 bit int for field droneID");
	}
	droneID = int_3->value;
	/*  1: ownerID  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: ownerID is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnDroneStateChange: truncating 64 bit into into 32 bit int for field ownerID");
	}
	ownerID = int_4->value;
	/*  2: controllerID (ship ID)  */
	if(!tuple2->items[2]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: controllerID is not an int: %s", tuple2->items[2]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_5 = (PyRepInteger *) tuple2->items[2];
	if(int_5->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnDroneStateChange: truncating 64 bit into into 32 bit int for field controllerID");
	}
	controllerID = int_5->value;
	/*  3: activityState  */
	if(!tuple2->items[3]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: activityState is not an int: %s", tuple2->items[3]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_6 = (PyRepInteger *) tuple2->items[3];
	if(int_6->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnDroneStateChange: truncating 64 bit into into 32 bit int for field activityState");
	}
	activityState = int_6->value;
	/*  4: droneTypeID  */
	if(!tuple2->items[4]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: droneTypeID is not an int: %s", tuple2->items[4]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_7 = (PyRepInteger *) tuple2->items[4];
	if(int_7->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnDroneStateChange: truncating 64 bit into into 32 bit int for field droneTypeID");
	}
	droneTypeID = int_7->value;
	/*  2: controllerOwnerID (ship's owner ID)  */
	if(!tuple2->items[5]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_OnDroneStateChange failed: controllerOwnerID is not an int: %s", tuple2->items[5]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_8 = (PyRepInteger *) tuple2->items[5];
	if(int_8->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_OnDroneStateChange: truncating 64 bit into into 32 bit int for field controllerOwnerID");
	}
	controllerOwnerID = int_8->value;

	delete packet;
	return(true);
}

DoDestiny_OnDroneStateChange *DoDestiny_OnDroneStateChange::Clone() const {
	DoDestiny_OnDroneStateChange *res = new DoDestiny_OnDroneStateChange;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_OnDroneStateChange::CloneFrom(const DoDestiny_OnDroneStateChange *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0: droneID  */
	droneID = from->droneID;
	/*  1: ownerID  */
	ownerID = from->ownerID;
	/*  2: controllerID (ship ID)  */
	controllerID = from->controllerID;
	/*  3: activityState  */
	activityState = from->activityState;
	/*  4: droneTypeID  */
	droneTypeID = from->droneTypeID;
	/*  2: controllerOwnerID (ship's owner ID)  */
	controllerOwnerID = from->controllerOwnerID;
	
}


DoDestiny_SetBallInteractive::DoDestiny_SetBallInteractive() {
	/*  0  */
	update_name = "SetBallInteractive";
	/*  1  */
	/*  0: entityID  */
	entityID = 0;
	/*  1: interactive: on/off  */
	interactive = 0;
}

DoDestiny_SetBallInteractive::~DoDestiny_SetBallInteractive() {
	/*  0  */
	/*  1  */
	/*  0: entityID  */
	/*  1: interactive: on/off  */
}

void DoDestiny_SetBallInteractive::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_SetBallInteractive", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	/*  0: entityID  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  1: interactive: on/off  */
	_log(l_type, "%sinteractive=%lu", pfx, interactive);
}

PyRepTuple *DoDestiny_SetBallInteractive::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0: entityID  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1: interactive: on/off  */
	tuple1->items[1] = new PyRepInteger(interactive);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_SetBallInteractive::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	/*  0: entityID  */
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  1: interactive: on/off  */
	tuple1->items[1] = new PyRepInteger(interactive);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_SetBallInteractive::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_SetBallInteractive::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallInteractive failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallInteractive failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallInteractive failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallInteractive failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallInteractive failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	/*  0: entityID  */
	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallInteractive failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallInteractive: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  1: interactive: on/off  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_SetBallInteractive failed: interactive is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_SetBallInteractive: truncating 64 bit into into 32 bit int for field interactive");
	}
	interactive = int_4->value;

	delete packet;
	return(true);
}

DoDestiny_SetBallInteractive *DoDestiny_SetBallInteractive::Clone() const {
	DoDestiny_SetBallInteractive *res = new DoDestiny_SetBallInteractive;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_SetBallInteractive::CloneFrom(const DoDestiny_SetBallInteractive *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	/*  0: entityID  */
	entityID = from->entityID;
	/*  1: interactive: on/off  */
	interactive = from->interactive;
	
}


DoDestiny_TerminalExplosion::DoDestiny_TerminalExplosion() {
	/*  0  */
	update_name = "TerminalExplosion";
	/*  1  */
	entityID = 0;
	/*  seen 1206  */
	unknown = 0;
}

DoDestiny_TerminalExplosion::~DoDestiny_TerminalExplosion() {
	/*  0  */
	/*  1  */
	/*  seen 1206  */
}

void DoDestiny_TerminalExplosion::Dump(LogType l_type, const char *pfx) const {
	_log(l_type, "%sDoDestiny_TerminalExplosion", pfx);
	/*  0  */
	_log(l_type, "%supdate_name='%s'", pfx, update_name.c_str());
	/*  1  */
	_log(l_type, "%sentityID=%lu", pfx, entityID);
	/*  seen 1206  */
	_log(l_type, "%sunknown=%lu", pfx, unknown);
}

PyRepTuple *DoDestiny_TerminalExplosion::Encode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  seen 1206  */
	tuple1->items[1] = new PyRepInteger(unknown);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

PyRepTuple *DoDestiny_TerminalExplosion::FastEncode() {
	PyRepTuple *res = NULL;
	PyRepTuple *tuple0 = new PyRepTuple(2);
	/*  0  */
	tuple0->items[0] = new PyRepString(update_name);
	/*  1  */
	PyRepTuple *tuple1 = new PyRepTuple(2);
	tuple1->items[0] = new PyRepInteger(entityID);
	/*  seen 1206  */
	tuple1->items[1] = new PyRepInteger(unknown);
	tuple0->items[1] = tuple1;
	
	res = tuple0;
	

	return(res);
}

bool DoDestiny_TerminalExplosion::Decode(PyRepTuple **in_packet) {
	//quick forwarder to avoid making the user cast it if they have a properly typed object
	PyRep *packet = *in_packet;
	*in_packet = NULL;
	return(Decode(&packet));
}

bool DoDestiny_TerminalExplosion::Decode(PyRep **in_packet) {
	PyRep *packet = *in_packet;
	*in_packet = NULL;

	if(!packet->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_TerminalExplosion failed: tuple0 is the wrong type: %s", packet->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple0 = (PyRepTuple *) packet;
	if(tuple0->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_TerminalExplosion failed: tuple0 is the wrong size: expected 2, but got %d", tuple0->items.size());
		delete packet;
		return(false);
	}

	/*  0  */
	if(!tuple0->items[0]->CheckType(PyRep::String)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_TerminalExplosion failed: update_name is not a string: %s", tuple0->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepString *string_1 = (PyRepString *) tuple0->items[0];
	update_name = string_1->value;
	/*  1  */
	if(!tuple0->items[1]->CheckType(PyRep::Tuple)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_TerminalExplosion failed: tuple2 is the wrong type: %s", tuple0->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepTuple *tuple2 = (PyRepTuple *) tuple0->items[1];
	if(tuple2->items.size() != 2) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_TerminalExplosion failed: tuple2 is the wrong size: expected 2, but got %d", tuple2->items.size());
		delete packet;
		return(false);
	}

	if(!tuple2->items[0]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_TerminalExplosion failed: entityID is not an int: %s", tuple2->items[0]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_3 = (PyRepInteger *) tuple2->items[0];
	if(int_3->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_TerminalExplosion: truncating 64 bit into into 32 bit int for field entityID");
	}
	entityID = int_3->value;
	/*  seen 1206  */
	if(!tuple2->items[1]->CheckType(PyRep::Integer)) {
		_log(NET__PACKET_ERROR, "Decode DoDestiny_TerminalExplosion failed: unknown is not an int: %s", tuple2->items[1]->TypeString());
		delete packet;
		return(false);
	}
	PyRepInteger *int_4 = (PyRepInteger *) tuple2->items[1];
	if(int_4->value > 0xFFFFFFFF) {
		_log(NET__PACKET_WARNING, "Decode DoDestiny_TerminalExplosion: truncating 64 bit into into 32 bit int for field unknown");
	}
	unknown = int_4->value;

	delete packet;
	return(true);
}

DoDestiny_TerminalExplosion *DoDestiny_TerminalExplosion::Clone() const {
	DoDestiny_TerminalExplosion *res = new DoDestiny_TerminalExplosion;
	res->CloneFrom(this);
	return(res);
}

void DoDestiny_TerminalExplosion::CloneFrom(const DoDestiny_TerminalExplosion *from) {
	/*  0  */
	update_name = from->update_name;
	/*  1  */
	entityID = from->entityID;
	/*  seen 1206  */
	unknown = from->unknown;
	
}



