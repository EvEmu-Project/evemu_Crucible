/*  EVEmu: EVE Online Server Emulator
  
  **************************************************************
  This file is automatically generated, DO NOT EDIT IT DIRECTLY.
  **************************************************************
  
  (If you need to customize an object, you must copy that object
  into another source file, and give up the ability to generate it)
  
  
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; version 2 of the License.
  
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY except by those people which sell it, which
  are required to give you total support for your newly bought product;
  without even the implied warranty of MERCHANTABILITY or FITNESS FOR
  A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
  
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#ifndef __Inventory_h__
#define __Inventory_h__

#include <string>
#include <vector>
#include <map>
#include "../common/common.h"
#include "../common/logsys.h"
#include "../common/PyRep.h"



class NotifyOnItemChange {
public:
	NotifyOnItemChange();
	~NotifyOnItemChange();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	NotifyOnItemChange *Clone() const;
	void CloneFrom(const NotifyOnItemChange *from);
	
	/*  0: this is a util.Row  */
	PyRep		*itemRow;
	/*  1: map from row index (ix* constants) to the old value for the item.   */
	std::map<uint32, PyRep *>	changes;


};


class NotifyOnSkillStartTraining {
public:
	NotifyOnSkillStartTraining();
	~NotifyOnSkillStartTraining();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	NotifyOnSkillStartTraining *Clone() const;
	void CloneFrom(const NotifyOnSkillStartTraining *from);
	
	uint32		itemID;
	uint64		endOfTraining;


};


class NotifyOnSkillTrainingStopped {
public:
	NotifyOnSkillTrainingStopped();
	~NotifyOnSkillTrainingStopped();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	NotifyOnSkillTrainingStopped *Clone() const;
	void CloneFrom(const NotifyOnSkillTrainingStopped *from);
	
	uint32		itemID;
	uint64		endOfTraining;


};


class CallSetLabel {
public:
	CallSetLabel();
	~CallSetLabel();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	CallSetLabel *Clone() const;
	void CloneFrom(const CallSetLabel *from);
	
	uint32		itemID;
	std::string	itemName;


};


class InvBroker_BindArgs {
public:
	InvBroker_BindArgs();
	~InvBroker_BindArgs();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	InvBroker_BindArgs *Clone() const;
	void CloneFrom(const InvBroker_BindArgs *from);
	
	uint32		entityID;
	PyRep		*unknown1;


};


class Inventory_GetInventory {
public:
	Inventory_GetInventory();
	~Inventory_GetInventory();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_GetInventory *Clone() const;
	void CloneFrom(const Inventory_GetInventory *from);
	
	uint32		container;
	PyRep		*argument;


};


class Inventory_CallAdd {
public:
	Inventory_CallAdd();
	~Inventory_CallAdd();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallAdd *Clone() const;
	void CloneFrom(const Inventory_CallAdd *from);
	
	uint32		itemID;
	uint32		quantity;
	uint32		flag;


};


class Inventory_CallAddCargoContainer {
public:
	Inventory_CallAddCargoContainer();
	~Inventory_CallAddCargoContainer();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallAddCargoContainer *Clone() const;
	void CloneFrom(const Inventory_CallAddCargoContainer *from);
	
	uint32		itemID;
	uint32		quantity;


};


class Inventory_CallMultiAdd {
public:
	Inventory_CallMultiAdd();
	~Inventory_CallMultiAdd();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallMultiAdd *Clone() const;
	void CloneFrom(const Inventory_CallMultiAdd *from);
	
	std::vector<uint32>	itemIDs;
	uint32		quantity;
	/*  almost always 1 on a multiadd  */
	uint32		flag;


};


class Inventory_CallReplaceCharges {
public:
	Inventory_CallReplaceCharges();
	~Inventory_CallReplaceCharges();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallReplaceCharges *Clone() const;
	void CloneFrom(const Inventory_CallReplaceCharges *from);
	
	uint32		flag;
	uint32		itemID;
	uint32		quantity;


};


class Inventory_CallMultiMergeElement {
public:
	Inventory_CallMultiMergeElement();
	~Inventory_CallMultiMergeElement();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallMultiMergeElement *Clone() const;
	void CloneFrom(const Inventory_CallMultiMergeElement *from);
	
	uint32		draggedItemID;
	uint32		stationaryItemID;
	uint32		draggedQty;


};


class Inventory_CallMultiMerge {
public:
	Inventory_CallMultiMerge();
	~Inventory_CallMultiMerge();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallMultiMerge *Clone() const;
	void CloneFrom(const Inventory_CallMultiMerge *from);
	
	PyRepList	MMElements;


};


class Inventory_QuantityLessThanMinimumPortionException {
public:
	Inventory_QuantityLessThanMinimumPortionException();
	~Inventory_QuantityLessThanMinimumPortionException();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Inventory_QuantityLessThanMinimumPortionException *Clone() const;
	void CloneFrom(const Inventory_QuantityLessThanMinimumPortionException *from);
	
	/* object of type ccp_exceptions.UserError */
	std::string	exceptionType;
	std::string	typeName;
	uint32		portionSize;
	std::string	exceptTypeDict;
	std::string	typeName_dict;
	uint32		portionSize_dict;


};


class Inventory_CallStackAll {
public:
	Inventory_CallStackAll();
	~Inventory_CallStackAll();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Inventory_CallStackAll *Clone() const;
	void CloneFrom(const Inventory_CallStackAll *from);
	
	uint32		locationFlag;


};


class OnModuleAttributeChange {
public:
	OnModuleAttributeChange();
	~OnModuleAttributeChange();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	OnModuleAttributeChange *Clone() const;
	void CloneFrom(const OnModuleAttributeChange *from);
	
	/*  0  */
	/*  0  */
	/*  0  */
	std::string	string0;
	/*  1  */
	uint32		ownerID;
	/*  2  */
	uint32		itemKey;
	/*  3  */
	uint32		attributeID;
	/*  4  */
	uint64		time;
	/*  5  */
	double		newValue;
	/*  6  */
	/*  0  */
	double		newValue2;
	/*  1  */
	uint64		time2;
	/*  2  */
	double		real8;
	/*  3  */
	double		oldValue;


};


class Call_GetJournal {
public:
	Call_GetJournal();
	~Call_GetJournal();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Call_GetJournal *Clone() const;
	void CloneFrom(const Call_GetJournal *from);
	
	uint32		accountKey;
	uint64		fromDate;
	/*  may be None (but prolly wont be)  */
	uint32		refTypeID;
	/*  may be None  */
	PyRep		*corpAccount;
	/*  soft bool  */
	PyRep		*refID;
	/*  may be None  */
	uint32		rev;


};


class Call_AssembleShip {
public:
	Call_AssembleShip();
	~Call_AssembleShip();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Call_AssembleShip *Clone() const;
	void CloneFrom(const Call_AssembleShip *from);
	
	std::vector<uint32>	items;


};


class EntityEffectState {
public:
	EntityEffectState();
	~EntityEffectState();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepList **packet);
	PyRepList *Encode();
	PyRepList *FastEncode();
	EntityEffectState *Clone() const;
	void CloneFrom(const EntityEffectState *from);
	
	/*  the first 7 fields are the standard effect `environment`
         fields indexed by ENV_IDX_*, see OnGodmaShipEffect  */
	/*  Begin Environment  */
	uint32		env_itemID;
	uint32		env_charID;
	uint32		env_shipID;
	uint32		env_target;
	/*  optional  */
	uint32		env_other;
	/*  optional (not positive that this is an int)  */
	PyRepList	env_area;
	/*  not sure what data goes in here.  */
	uint32		env_effectID;
	/*  End Environment  */
	uint64		startTime;
	uint32		duration;
	/*  saw 0x7 placeholder  */
	uint32		repeat;
	/*  saw 0  */
	/*  randomSeed  */


};


class Rsp_CommonGetInfo_Entry {
public:
	Rsp_CommonGetInfo_Entry();
	~Rsp_CommonGetInfo_Entry();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepList **packet);
	PyRepList *Encode();
	PyRepList *FastEncode();
	Rsp_CommonGetInfo_Entry *Clone() const;
	void CloneFrom(const Rsp_CommonGetInfo_Entry *from);
	
	uint32		itemID;
	/*  this is an EntityRowObject  */
	PyRep		*invItem;
	/*  this maps effectType to EntityEffectState  */
	std::map<uint32, PyRep *>	activeEffects;
	/*  maps attribute ID to it's value, which may be int or real  */
	std::map<uint32, PyRep *>	attributes;
	uint64		time;


};


class Rsp_ItemGetInfo {
public:
	Rsp_ItemGetInfo();
	~Rsp_ItemGetInfo();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Rsp_ItemGetInfo *Clone() const;
	void CloneFrom(const Rsp_ItemGetInfo *from);
	
	/* object of type util.Row */
	std::string	head_itemID;
	std::string	head_invItem;
	std::string	head_activeEffects;
	std::string	head_attributes;
	std::string	head_time;
	Rsp_CommonGetInfo_Entry	entry;


};


class Rsp_CommonGetInfo {
public:
	Rsp_CommonGetInfo();
	~Rsp_CommonGetInfo();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Rsp_CommonGetInfo *Clone() const;
	void CloneFrom(const Rsp_CommonGetInfo *from);
	
	/* object of type util.IndexRowset */
	std::string	head_itemID;
	std::string	head_invItem;
	std::string	head_activeEffects;
	std::string	head_attributes;
	std::string	head_time;
	std::string	rowclass;
	std::string	idName;
	/*  For ShipGetInfo: contains a single Rsp_CommonGetInfo_Entry for the ship  */
	/*  For CharGetInfo: contains an Rsp_CommonGetInfo_Entry for the char and each of their skills (and implants?)  */
	std::map<uint32, PyRep *>	items;


};


class EntityRowObject {
public:
	EntityRowObject();
	~EntityRowObject();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	EntityRowObject *Clone() const;
	void CloneFrom(const EntityRowObject *from);
	
	/* object of type util.Row */
	std::string	head_itemID;
	std::string	head_typeID;
	std::string	head_ownerID;
	std::string	head_locationID;
	std::string	head_flag;
	std::string	head_contraband;
	std::string	head_singleton;
	std::string	head_quantity;
	std::string	head_groupID;
	std::string	head_categoryID;
	std::string	head_customInfo;
	uint32		itemID;
	uint32		typeID;
	uint32		ownerID;
	uint32		locationID;
	uint32		flag;
	uint32		contraband;
	uint32		singleton;
	uint32		quantity;
	uint32		groupID;
	uint32		categoryID;
	std::string	customInfo;


};


class Call_GetOptionsForItemTypes {
public:
	Call_GetOptionsForItemTypes();
	~Call_GetOptionsForItemTypes();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Call_GetOptionsForItemTypes *Clone() const;
	void CloneFrom(const Call_GetOptionsForItemTypes *from);
	
	std::map<uint32, PyRep *>	typeIDs;


};


class Rsp_GetOptionsForItemTypes {
public:
	Rsp_GetOptionsForItemTypes();
	~Rsp_GetOptionsForItemTypes();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepDict **packet);
	PyRepDict *Encode();
	PyRepDict *FastEncode();
	Rsp_GetOptionsForItemTypes *Clone() const;
	void CloneFrom(const Rsp_GetOptionsForItemTypes *from);
	
	std::map<uint32, PyRep *>	typeIDs;


};


class Rsp_GetOptionsForItemTypes_Arg {
public:
	Rsp_GetOptionsForItemTypes_Arg();
	~Rsp_GetOptionsForItemTypes_Arg();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Rsp_GetOptionsForItemTypes_Arg *Clone() const;
	void CloneFrom(const Rsp_GetOptionsForItemTypes_Arg *from);
	
	/* object of type util.KeyVal */
	bool		isRecyclable;
	bool		isRefinable;


};


class Rsp_GetReprocessingInfo {
public:
	Rsp_GetReprocessingInfo();
	~Rsp_GetReprocessingInfo();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepDict **packet);
	PyRepDict *Encode();
	PyRepDict *FastEncode();
	Rsp_GetReprocessingInfo *Clone() const;
	void CloneFrom(const Rsp_GetReprocessingInfo *from);
	
	double		tax;
	double		reputation;
	double		yield;
	double		combinedyield;


};

	/*  this is ugly, but we dont really have a better way to deal with it right now.  */
	/*  Don't change headerX !  */

class Rsp_GetQuote {
public:
	Rsp_GetQuote();
	~Rsp_GetQuote();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepObject **packet);
	PyRepObject *Encode();
	PyRepObject *FastEncode();
	Rsp_GetQuote *Clone() const;
	void CloneFrom(const Rsp_GetQuote *from);
	
	/* object of type util.Row */
	std::string	header1;
	std::string	header2;
	std::string	header3;
	std::string	header4;
	uint32		quantityToProcess;
	uint32		leftOvers;
	double		playerStanding;
	/* object of type util.Rowset */
	std::string	header5;
	std::string	header6;
	std::string	header7;
	std::string	header8;
	std::string	RowClass;
	PyRepList	lines;


};


class Rsp_GetQuotes {
public:
	Rsp_GetQuotes();
	~Rsp_GetQuotes();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepDict **packet);
	PyRepDict *Encode();
	PyRepDict *FastEncode();
	Rsp_GetQuotes *Clone() const;
	void CloneFrom(const Rsp_GetQuotes *from);
	
	std::map<uint32, PyRep *>	quotes;


};


class Rsp_GetQuote_Recoverables_Line {
public:
	Rsp_GetQuote_Recoverables_Line();
	~Rsp_GetQuote_Recoverables_Line();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepList **packet);
	PyRepList *Encode();
	PyRepList *FastEncode();
	Rsp_GetQuote_Recoverables_Line *Clone() const;
	void CloneFrom(const Rsp_GetQuote_Recoverables_Line *from);
	
	uint32		typeID;
	uint32		unrecoverable;
	uint32		station;
	uint32		client;


};


class Call_Reprocess {
public:
	Call_Reprocess();
	~Call_Reprocess();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Call_Reprocess *Clone() const;
	void CloneFrom(const Call_Reprocess *from);
	
	std::vector<uint32>	itemIDs;


};


class Call_GetQuotes {
public:
	Call_GetQuotes();
	~Call_GetQuotes();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepTuple **packet);
	PyRepTuple *Encode();
	PyRepTuple *FastEncode();
	Call_GetQuotes *Clone() const;
	void CloneFrom(const Call_GetQuotes *from);
	
	std::vector<uint32>	itemIDs;


};


class Rsp_GetBlueprintAttributes {
public:
	Rsp_GetBlueprintAttributes();
	~Rsp_GetBlueprintAttributes();
	
	void Dump(LogType type, const char *pfx = "") const;
	bool Decode(PyRep **packet);	//consumes packet
	bool Decode(PyRepDict **packet);
	PyRepDict *Encode();
	PyRepDict *FastEncode();
	Rsp_GetBlueprintAttributes *Clone() const;
	void CloneFrom(const Rsp_GetBlueprintAttributes *from);
	
	uint32		blueprintID;
	uint32		productTypeID;
	bool		copy;
	uint32		productivityLevel;
	uint32		materialLevel;
	double		wastageFactor;
	uint32		manufacturingTime;
	uint32		maxProductionLimit;
	uint32		licensedProductionRunsRemaining;
	uint32		researchMaterialTime;
	uint32		researchTechTime;
	uint32		researchProductivityTime;
	uint32		researchCopyTime;


};



#endif


